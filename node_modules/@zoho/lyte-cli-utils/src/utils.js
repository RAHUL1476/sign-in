var path = require('path');
var fs = require('fs'),
    htmlMinifier = require("html-minifier").minify,
    terser = require("terser"),
    Concat =  require("concat-with-sourcemaps"),
    sourceMap  = require("source-map"),
    CleanCSS = require("clean-css"),
    execSync = require("child_process").execSync;
let fileTypeFnMap = {".js" : "minifyJs", ".css" :  "minifyCss", ".html" : "minifyHtml"},
    extToApplyBeforeCompilation = {".js" : "js",".html" : "html",".css" :"css",".txt" : "txt"},
    isExistInIgnoreArray = function(ignoreFolderLists,filePath) {
        for(var i = 0 ; i < ignoreFolderLists.length ;i++) {
            if(filePath.indexOf(ignoreFolderLists[i]) != -1) {
                return true;
            } 
        }
        return false;
    },
    checkForMinifyErrorInSourceFiles = function(fn,sourceFileList,callback,to,cssMinify) {
        let sourceFileListLen = sourceFileList.length;
        let fileManipulation = utils.fileManipulation;
        let cb = function(index,msg){
            if(index == sourceFileListLen-1) {
                callback(new Error(msg),to);
            }
        };
        let msg = "Error occur in the minification of "+to+"\n\t";
        let index  = 0;
        sourceFileList.forEach(function(file) { 
            if(fileManipulation.fileExist(file)){
                fn["minify"](fileManipulation.readSync(file,'utf-8')).catch(function(err){
                    if(cssMinify) {
                        msg +="Syntax error in the file "+file;
                        err.forEach(function(e) {
                            msg+=e;
                        });
                    } else {
                        msg += "Syntax error in the file "+file+" at line no : "+err.line+'\n\t'; 
                    }
                    cb(index++,msg);
                }).then(function(){
                    cb(index++,msg);
                });
            } else {
                cb(index++,msg);
            }
        });
    },
    checkTheExtOfFile = function(file,ext,extLen) {
        var strLen = file.length;
        return file.indexOf(ext,strLen - extLen);
    },
    getFileContent = function(options,file,callback) {
        var content = options.fileContent[file];
        if(content){
            callback(null,content);
        } else {
            this.read(file,'utf-8',function(err,data){
                if(err) {
                    callback("Warning: file not found "+file);
                } else {
                    options.fileContent[file] = data;
                    callback(null,data);
                }
            }.bind(this));
        }
    },
    predictLineNo = function(str,position) {
        var tempString = str.substring(0, position);
        var tempStringArray = tempString.split('\n');
        var lastLine = tempStringArray[tempStringArray.length-1];
        if(lastLine.trim().length) {
            return tempStringArray.length;
        } 
        return tempStringArray.length-1;
        
    };
/*variable for fileManipulation */
let  fingerPrintOpt,systemLog,userLog,es6Path,production,sourceMapFlag;
let utils = {
    stringManipulation : {
        pluralize : function(str) {
            return str+(this.isUpperCase(str) ? "S" : "s");
        },
        
        isUpperCase : function(str) {
            return str == str.toUpperCase() ? true : false;
        },
        
        escapeSpecialChar : function(content){
            return JSON.stringify(content);
        },
        
        replaceSpecialCharWithHTML : function(str) {
            return str.replace(/>/g,"&gt;").replace(/>=/g,"&gt;=").replace(/</g,"&lt;").replace(/<=/g,"&lt;=").replace(/\"/g,'&quot;');
        }
    },
    fileManipulation : {
        init : function(options) {
            fingerPrintOpt = options.fingerPrint;
            systemLog = options.log.system;
            userLog = options.log.user;
            sourceMapFlag = options.sourceMap;
            production = options.production;
            es6Path = options.es6Path;
        },

        validateFile : function(file) {
            return file.indexOf('.') && !file.includes('.orig') && !file.includes(".rej") && !file.includes(".DS_store");
        },

        access : function(file,callback) {
            fs.access(file,fs.constants.F_OK,function(err){
                err ? callback(new Error(err)) : callback();
            });
        },
        
        fileExist : function(file) {
            return fs.existsSync(file);
        },

        lstatSync : function(file) {    
            return fs.lstatSync(file);      
        },
    
        lstat : function(file,callback) {
            fs.lstat(file,function(err,stats){
                if(err) {
                    callback(new Error(err));
                } else {
                    callback(null,stats);
                }
            });
        },
        
        mkdir : function(dir,callback) {
            fs.mkdir(dir,{recursive : true},function(err) {
                err ? callback(new Error(err)) : callback();
            });
        },
        
        mkdirSync : function(dir) {
            fs.mkdirSync(dir,{recursive : true});
        },
        
    
        readdirSync : function(folder) {
            return fs.readdirSync(folder);
        },

        readdir : function(file,callback) {
            fs.readdir(file,function(err,files){
                err ? callback(new Error(err)) : callback(null,files)
            });
           
        },
    
        truncate : function(file) {     
            if(this.validateFile(file)) {
                var dir = path.parse(file).dir;     
                this.mkdirSync(dir);            
                this.writeSync(file,'');
            } else {
                //console.log(chalk.red(file +' is not a valid file.'));
            }
        },
        writeSync : function(file,content,options){
            if(options) {
                if(typeof options == "object") {
                    fs.writeFileSync(file,content,options); 
                } else {
                    fs.writeFileSync(file,content);
                }
            } else {            
                fs.writeFileSync(file,content);
            }
        },
        write : function(file,data,callback) {
            fs.writeFile(file,data,function(err) {
                if(err) {
                    callback(new Error(err));
                } else {
                    callback();
                }
            });
        },
        append : function(file,data,callback) {
            fs.appendFile(file,data,function(err){
                err ? callback(new Error(err)) : callback();
            });
        },
        appendSync : function(fileName,content,options){
            if(this.validateFile(fileName)) {               
                if(typeof options == "object") {
                    fs.appendFileSync(fileName,content,options);
                } else {                    
                    fs.appendFileSync(fileName,content);    
                }                       
            }
        },

        readSync : function(file,type) {
            type  = type || "utf-8"
            if(fs.existsSync(file)) {
                return fs.readFileSync(file,type);  
            }  
            throw "No such file or directory "+file
            
            // console.log('There is no file named ' +file);
        },
    
        read : function() {
            fs.readFile.apply(null,arguments);
        },

        createReadStream : function() {
            return fs.createReadStream.apply(null,arguments);
        },

        remove : function(file,callback) {
            let removeTheFile = function(file,callback) {
                fs.unlink(file,callback);
            };
            let self = this;
            let removeCount = 0;
            let len;
            let allFilesIterated = false;
            let cb = function(err,isDir) {
                if(allFilesIterated){
                    if(removeCount == len) {
                        if(err) {
                            callback(err);
                        } else {
                            if(isDir) {
                                self.removeSync(file,true);
                            } 
                            callback();
                        }
                    }
                }
            };
            
            self.lstat(file,function(err,stats){
                if(err) {
                    callback(err);
                } else {
                    if(stats.isDirectory()) {
                        self.getFilesList(file,null,function(err,items) {
                            if(err) {
                                cb(err);
                            } else {
                                allFilesIterated = true;
                                len = items.length;
                                cb(err,true);
                            }
                        },function(item) {
                            removeTheFile(item,function(err) {                                  
                                removeCount++;
                                cb(err,true);
                            });
                        });
                    } else {
                        removeTheFile(file,callback);
                    }
                }
            });
    
        },
        removeSync : function(file,permitFlag){  
            if(this.fileExist(file)) {          
                if(!permitFlag){
                    if(process.env.PRODUCTION) {
                        console.log("Files don't have permission to delete");
                    } else {
                        permitFlag = this.prompt('The '+file+' to be going to deleted , Are you sure to continue ?? Y/N');
                    }
                }
            }
            if(permitFlag){ 
                try {
                    if(process.platform == "win32") {
                        execSync('rmdir /q /s '+file);
                    } else {
                        execSync('rm -rf '+file);
                    }
                } catch(e) {
                    var deleteFolderRecursive = function(filePath) {
                        this.readdirSync(filePath).forEach(function(file){
                            var curPath = filePath + path.sep + file;
                            if(this.lstatSync(curPath).isDirectory()) { // recurse
                                deleteFolderRecursive.call(this,curPath);
                            } else { // delete file
                                fs.unlinkSync(curPath);
                            }
                        }.bind(this));
                        fs.rmdirSync(filePath);
                        
                    };
                    if(this.fileExist(file)) {
                        if(this.lstatSync(file).isDirectory()){
                            deleteFolderRecursive.call(this,file);
                        } else {    
                            fs.unlinkSync(file);    
                        }    
                    }
                    
                }
            }
        },


        getFilesList : function(dir,validationFn,done,callback,throwError) {
            let self = this;
            var results = [];
            validationFn = validationFn || function() { return true; };
            callback  = callback || function(){};
            self.readdir(dir, function(err, list) {
                if (err)  { return done(err,[]) };
                var pending = list.length;
                if (!pending) { return done(null, results) };
                list.forEach(function(file) {
                    if(self.validateFile(file)) {
                        file = path.join(dir, file);
                        self.lstat(file, function(err, stat) {
                            if (err) { return done(err,[]) };
                            if(stat.isSymbolicLink()) {
                                if(validationFn(file)) {
                                    callback(file,true);
                                    results.push(file);
                                }
                                completedCheck(true);
                            } else {
                                if (stat.isDirectory()) {
                                    self.getFilesList(file,validationFn,function(err, res) {
                                        if (err) { return done(err,[]) };
                                        results = results.concat(res);
                                        completedCheck();
                                    },callback);
                                } else {
                                    if(validationFn(file)) {
                                        callback(file);
                                        results.push(file);
                                    } else {
                                        if(throwError) {
                                            callback(file,"Not an valid File")
                                        }
                                    }
                                    completedCheck();
                                }
                            }
                        });
                    } else {
                       
                        completedCheck();
                    }
                });
                function completedCheck(isSymbolicLink) {
                    if (!--pending) {
                        done(null, results,isSymbolicLink);
                    }
                }
            });
        },
    
        getFilesListSync : function(from) {
            var files = [];
                this.readdirSync(from).forEach(function(file) {
                    var fromPath = path.join(from,file);
                    if(this.validateFile(fromPath)) {
                        if(this.lstatSync(fromPath).isDirectory()) {     
                            files.push.apply(files,this.getFilesListSync(fromPath));         
                        }else{
                            if(!files.includes(fromPath)){
                                files.push(fromPath);
                            }
                        }
                }
                }.bind(this));   
            return files;  
        },

        copyWithSymbolicLink : function(obj,callback) {
            let file = obj.src;
            let copyTo = obj.dist;      
            this.mkdir(path.parse(copyTo).dir,function(err){
                if(err) {
                    callback(err);
                } else {
                    fs.symlink(file,copyTo,function(err){
                        callback(err,copyTo);
                    }); 
                }
            }.bind(this));
        },
    
        copy : function(options,obj,callback) {
            let file = obj.src;
            let copyTo = obj.dist;
            let self = this;
            let fileExt = self.getTheFileExt(file),
                errorOccurs = false;
            var beforeCompilation = obj.beforeCompilation,
                afterCompilation = obj.afterCompilation,	
			    compilation = obj.compilation,
                returnValue;
            if(extToApplyBeforeCompilation[fileExt]) {
                self.read(file,function(err,data){
                    if(err) {
                        callback(new Error(err));
                        return;
                    }
                    data = data.toString();         
                    if(beforeCompilation) {  
                        try {   
                            returnValue = beforeCompilation.call({
                                data : data,
                                file : file
                            });
                            let code;
                            if(returnValue.code) {
                                code = returnValue.code;
                                let map = returnValue.map;
                                if(map != "undefined" && typeof map == "string") {
                                    options.fileContent[copyTo+'.map'] = map;
                                }
                            } else {
                                code = returnValue;
                            }
                            if(code != data) {
                                data = (code != undefined && code != null) ? code : data;
                            }
                        } catch(e) {
                            errorOccurs = true;
                            e.message = "Error occur while running beforeCompilation function for the file  \n"+file+"\n "+e.message;
                            callback(e);
                        }
                    }
                    if(!errorOccurs) {
                        if(compilation) {	
                            var returnObj = compilation(options,data,file,"registerClosure");	
                            if(returnObj.error) {	
                                callback(returnObj.error);	
                            } else {	
                                data = returnObj.content;	
                            }	
                        }	
                        self.customFsWriteFn(options,data,copyTo,afterCompilation,obj.minify,callback);
                    }
                });  
            } else {
                var copyToObj = path.parse(copyTo);
                self.mkdir(copyToObj.dir,function(err) {
                    if(err) {
                        callback(err);
                    } else {
                        if(afterCompilation) {
                            self.read(file,function(err,data){
                                var result = afterCompilation.call({file : copyToObj,data : data});
                                copyTo = result.file;
                                self.write(copyTo,data,callback);
                            })
                        } else {
                            fs.copyFile(file,copyTo,function(err){
                                err ? callback(new Error(err)) : callback();
                            });
                        }
                    }
                });
            }                   
        },
        concat : function(options,obj,convertToAsyncAndAwait) { 
            let errorClass = utils.errorClass,
                minify = obj.minify,
                transpileOpt = options.transpile,
                outputFolder = options.inapp ? options.parentOutputFolder : options._appOutputFolder,
                self = this,
                toFolder = obj.dist,
                afterCompilation = obj.afterCompilation,
                fileArray = obj.src,
                callback = function(err) {
                    if(err) { 
                        obj.callback(err)
                    } else {
                        if(completedState.es5File && (completedState.es6File == undefined || completedState.es6File)){
                            obj.callback();
                        }   
                    }       
                },
                es6FileArray = [],
                completedState = {
                    es5File : false
                },
                setContent = function(to,toFolderObj,content,sourceMap,callback,sourceFileArray){
                    minify ? self.minify(options,{
                            src : to,
                            dist : to,
                            content : content
                    },callback,sourceFileArray) : self.mkdir(toFolderObj.dir,function(err) {
                        err ?  callback(err) : self.write(to,content,function(err) {
                            err ?  callback(err) : ((sourceMap && toFolderObj.ext == ".js") ? self.write(to+'.map',options.fileContent[to+'.map'],callback) :callback());
                        });
                    });     
                },
                concat = new Concat(sourceMapFlag,toFolder,'\n'), 
                cb = function(to,toFolderObj,incremental,len,type,nextCall) {
                    if(incremental == len) {
                        let distcontent = concat.content.toString();
                        
                        if(afterCompilation) {
                            distcontent = afterCompilation(options,distcontent,to).content;
                        }
                        options.fileContent[to] = distcontent;
                        let callToWrite = function() {
                            if(sourceMapFlag && toFolderObj.ext == ".js") {
                                distcontent = distcontent + '\n//# sourceMappingURL='+toFolderObj.name+toFolderObj.ext+".map";
                                options.fileContent[to+'.map'] = JSON.stringify(JSON.parse(concat.sourceMap));                                                              
                            }
                            if(transpileOpt) {
                                transpileOpt = false;
                                let es6DistPath = toFolder.replace(outputFolder,es6Path);
                                concat = new Concat(sourceMapFlag,es6DistPath,'\n'),
                                completedState.es6File = false;
                                iterateTheFileArray(es6FileArray,transpileOpt,"es6File",es6DistPath);
                            }
                            setContent(to,toFolderObj,distcontent,sourceMapFlag,function(err) {                                 
                                completedState[type] = true;
                                callback(err,to);                                   
                            },fileArray);
                        }                       
                        systemLog({msg :"Consolidated file created in the "+path.relative(options.root,to)+'\n',timestamp : new Date().getTime(),type :"INFO"});   
                     
                        if(convertToAsyncAndAwait && toFolderObj.ext == ".js") {
                            try {                              
                                let result = self.convertToAsyncAndAwait({
                                    content : distcontent
                                });
                                distcontent = result;
                                callToWrite();
                            } catch(e) {
                                callback(e,to);
                            }
                        } else {
                            callToWrite();
                        }
                    } else {
                        nextCall(incremental);
                    }
                },
                concatFn = function(value,callback)  {
                    let map;

                    let content = value.source;
                    let fullPath = value.sourceFile;
                    
                    let file = path.relative(outputFolder,fullPath);                    
                    if(sourceMapFlag && file.includes(".js")) {                                                     
                        getFileContent.call(self,options,fullPath+'.map',function(err,prevMapContent) {                 
                            if(err) {
                                map = new sourceMap.SourceMapGenerator({
                                    file : file,
                                    sourceRoot : outputFolder
                                });
                                map = JSON.parse(map);
                                map.sources = [file];
                                map.sourcesContent = [content];
                                map.sourceRoot =  outputFolder;      
                                concat.add(file,content,map);
                                callback();
                            } else {                                            
                                sourceMap.SourceMapConsumer.with(JSON.parse(prevMapContent), null, consumer => {                            
                                    map = JSON.parse(sourceMap.SourceMapGenerator.fromSourceMap(consumer));
                                    concat.add(file,content,map);
                                    callback();
                                });
                            }
                        });                     
                    } else {                                            
                        concat.add(file,content);
                        callback();
                    }
                },
                handleWarnings = function(message) {
                    errorClass.handleWarnings(options,{
                        message :message,
                        userLog : userLog,
                        systemLog : systemLog
                    },options.verbose);
                },
                iterateTheFileArray = function(fileArray,transpileOpt,type,toFolder) {
                    let incremental = 0;
                    let length = fileArray.length;
                    let toFolderObj = path.parse(toFolder),
                        toFolderExt = toFolderObj.ext,
                        toFolderExtLen = toFolderExt.length;
                    if(toFolderExt) {
                        if(length) {
                            let nextCall = function(inc) {
                                loopFn(fileArray[inc]);
                            }
                            let callbackFn = function() {
                                incremental++;            
                                cb(toFolder,toFolderObj,incremental,length,type,nextCall)
                            }
                            let loopFn = function(file) {
                                if(toFolder != file) {
                                    if(checkTheExtOfFile(file,toFolderExt,toFolderExtLen) != -1) {
                                        getFileContent.call(self,options,file,function(err,fileData){
                                            if(err) {
                                                handleWarnings("Warning : file not found "+file);
                                                callbackFn();
                                            } else {
                                                if(transpileOpt) {
                                                    es6FileArray.push(file.replace(outputFolder,es6Path));
                                                }   
                                                concatFn({
                                                    source : fileData,
                                                    sourceFile: file
                                                },function() {
                                                    callbackFn();
                                                });             
                                            }
                                        });
                                    } else {
                                        handleWarnings(file+" file with not valid ext found while consolidating the file "+toFolder);
                                        callbackFn();
                                    }
                                } else {
                                    completedState.es5File = true;
                                    callback(new Error("Destination file :"+path.relative(options.root,toFolder)+". Source and destination file should not be in the same location for consolidation"));            
                                }
                            }
                            loopFn(fileArray[0]);
                        } else {
                            completedState.es5File = true;
                            callback();
                        }
                    } else {
                        callback(new Error("Destination should be a file\n.Key "+toFolder+' not contain the extension'));            
                    }
                    
                }
            iterateTheFileArray(fileArray,transpileOpt,'es5File',toFolder)
        },


        minify : function(options,obj,callback,sourceFileArray) {   
            var from = obj.src,
                to = obj.dist,
                content = obj.content,
                toCall,
                toObj = path.parse(to),
                extTo = toObj.ext,
                self = this,
                extFrom = self.getTheFileExt(from),
                callMinify = function() {
                    if(toCall = fileTypeFnMap[extTo]) {
                        self[toCall].call(self,options,to,content,callback,sourceFileArray);
                    } else {         
                        self.mkdir(toObj.dir,function(err) {
                            err ? callback(err) : self.write(to,content,callback);
                        });
                    }
                };
            if(extFrom != extTo) {
                callback(new Error("Error in the minification of the file"+to+"\n"+"Mismatch in the extension of src and dist file"));
                return;
            }   
            if(content) {
                callMinify();
            } else {
                if(from != to) {
                    self.read(from,'utf-8',function(err,data){
                        if(err)  {
                            callback(err) 
                        } else {
                            content = data;
                            callMinify();
                        }
                    });
                } else {
                    callback();
                }
            }
            
        },

        minifyJs : function(options,to,content,callback,sourceFileList)    {       
            let outputFolder = options._appOutputFolder,
                relativeToPath = path.relative(outputFolder,to),
                mapString = '',
                fnScopeMapContent,
                mapFilePath = to+'.map',
                uglifyEsOptions = {},
                code = {},
                sourceMapFlag = options.sourceMap;
            code[relativeToPath] = content;
            var callTerserFn = function() {
                var self = this;
                options.minifyCount++;
                terser.minify(code,uglifyEsOptions).then(function(result){
                    let code = result.code;
                    let map = result.map;
                    self.mkdir(toObj.dir,function(err){   
                        if(err) {
                            callback(err);
                            return;
                        }   
                        if(fingerPrintOpt) {
                            to = self.generateFingerPrint(options,toObj,code);
                            if(sourceMapFlag) {
                                mapFilePath = self.generateFingerPrint(options,mapFilePath,map.toString());
                            }
                        }           
                        self.write(to,result.code,function(err){        
                            err ? callback(err) : (sourceMapFlag ?  self.append(to,mapString,function(err){
                                err ? callback(err) :  self.write(mapFilePath,map.toString(),callback);
                            }) : callback(null)); 
                        });
                    });                 
                }).catch(function(err){
                    let errFileName = err.filename;
                    if(fnScopeMapContent){
                        sourceMap.SourceMapConsumer.with(JSON.parse(fnScopeMapContent),null,function(consumer){
                            var originalFileObj = consumer.originalPositionFor({
                                line: err.line,
                                column: err.col
                            });
                            if(originalFileObj.source) {
                                var msg = "Error occur in the minification of "+errFileName+"\n\t Syntax error in the file "+originalFileObj.source+" at line no :"+originalFileObj.line; 
                                callback(new Error(msg),to);
                            } else {
                                checkForMinifyErrorInSourceFiles(terser,sourceFileList,callback,to);
                            }
                        });
                    } else {
                        if(sourceFileList) {
                            checkForMinifyErrorInSourceFiles(terser,sourceFileList,callback,to);
                        } else {
                            callback(new Error(err),to);
                        }
                    }
                });
            };
            let toObj = path.parse(to);
            if(sourceMapFlag) {
                mapString = '\n//# sourceMappingURL='+toObj.name+toObj.ext+".map";
                let sourceMapOptions = {};
                sourceMapOptions.includeSources = true ;            
                getFileContent.call(this,options,mapFilePath,function(err,mapContent){
                    fnScopeMapContent = mapContent;
                    if(!err) {
                        sourceMapOptions.content = mapContent;
                    }
                    uglifyEsOptions.sourceMap = sourceMapOptions;
                    callTerserFn.call(this);
                }.bind(this));
            } else {
                callTerserFn.call(this);
            }
        },
    
        minifyCss : function(options,to,data,callback,sourceFileList) {
            var cleanCSSOptions = {
                level : {
                    2 : {
                        mergeAdjacentRules: true,
                        removeDuplicateRules: true
                    }
                }
            }
            var cleanCssDef = new CleanCSS(cleanCSSOptions);
            options.minifyCount++;
            cleanCssDef.minify(data,function(err,result) {
                
                if(err) {
                    if(sourceFileList) {
                        cleanCSSOptions.returnPromise = true;
                        checkForMinifyErrorInSourceFiles(new CleanCSS(cleanCSSOptions),sourceFileList,callback,to,true);
                    } else {
                        var errStr = 'Error occur in the minification of the file '+to+"\n";
                        err.forEach(function(e){
                            errStr+=e;
                        })
                        callback(new Error(errStr),to);
                    }
                } else { 
                    let styleStr = result.styles
                    let toObj = path.parse(to);
                    fingerPrintOpt && (to = this.generateFingerPrint(options,toObj,styleStr));
                    this.mkdir(toObj.dir,function(error){
                        error ? callback(error) : this.write(to,styleStr,callback);
                    }.bind(this));
                }
            }.bind(this)); 
        },
    
        minifyHtml : function(options,to,min,callback) {       
            try {
                min = htmlMinifier(min);
                fingerPrintOpt && (to = this.generateFingerPrint(options,to,min));
                var toObj = path.parse(to);
                this.mkdir(toObj.dir,function(err){
                    err ?  callback(err) : this.write(to,min,callback);
                }.bind(this));
            } catch(e) {
                callback(e);
            }   
        },


        getTheFileExt : function(fileName) {
            // return fileName.substring((fileName.lastIndexOf(".") -1 >>> 0) + 1);
            return path.parse(fileName).ext;
        },
        
        merge_array : function(array,array1) {
            array1.forEach(function(e) {
                if(array.indexOf(e) == -1) {
                    array.push(e);
                }
            });
        },
    
        merge_object : function(obj,obj1){
            var objVal;
            var obj1Val;
            for(var key in obj1) {
                objVal = obj[key];
                obj1Val = obj1[key];
                if(objVal && typeof objVal == 'object') {
                    obj[key] = this.merge_object(objVal,obj1Val);
                } else {
                    obj[key] = obj1Val;
                }
            }
        },
        transpileFn : function(options,obj,callback) {
            let file = obj.src,
                copyTo = obj.dist,
                content = obj.content,  
                outputFolder = options._appOutputFolder,
                minify = obj.minify,
                beforeCompilation = obj.beforeCompilation,
                self = this,
                afterCompilation  = obj.afterCompilation;   
            let wrapperCbFn = function(err) {
                if(err){
                    callback(err);
                } else {
                    let distes6Path = copyTo.replace(outputFolder,es6Path);
                    obj.dist = distes6Path;
                    if(beforeCompilation) {
                        result = beforeCompilation.call({
                            file : file,
                            data : content
                        })
                        content = result;
                    }
                    content ? self.customFsWriteFn(options,content,distes6Path,afterCompilation,minify,callback) : self.copy(options,obj,callback);
                }
            };
            let transpileCall = function(data,file) {
                try {
                    data = self.transpileUtil({
                        transpileOptions : options.transpileOpt,
                        file : file,
                        content : data,
                        beforeCompilation : beforeCompilation
                    },true);
                    self.customFsWriteFn(options,data,copyTo,afterCompilation,minify,wrapperCbFn);
                } catch(e) {
                    wrapperCbFn(e);
                }               
            };
            if(self.getTheFileExt(file) == ".js") {
                if(!(isExistInIgnoreArray(options.ignoreFoldersFromTranspile || [],file))) {
                    if(content) {
                        transpileCall(content);
                    } else {
                        self.read(file,function(err,data){
                            if(err) {
                                wrapperCbFn(err);
                            } else {
                                data = data.toString();
                                transpileCall(data,file);
                            }
                        });
                    }
                } else {
                    content ? self.customFsWriteFn(options,content,copyTo,afterCompilation,minify,wrapperCbFn): self.copy(options,obj,wrapperCbFn);
                }
            } else {
                content ?  self.customFsWriteFn(options,content,copyTo,afterCompilation,minify,wrapperCbFn) : self.copy(options,obj,wrapperCbFn);           
            }
        },
        generateFingerPrint : function(options,file,code) {
            let resultOfFingerPrint  = this.fingerPrintFn(file,code,options.fingerPrintKeyRelativeTo);          
            options.fingerPrintMapping[resultOfFingerPrint.originalPath] = resultOfFingerPrint.hashPath; 
            return resultOfFingerPrint.absoluteHashPath;
        },

        prompt : function(question,color){      
            if(!color){
                color ="blue";
            }
            var chalk = require("chalk");
            var readLineSync = require('readline-sync');
            var result = readLineSync.question(chalk[color](question));
            if(result.toUpperCase() == 'YES'||result.toUpperCase() == 'Y') {
                return true;
            } 
            return false;
        },

        customFsWriteFn : function(options,data,copyTo,afterCompilation,minify,callback) {
            var copyToObj = path.parse(copyTo);
            if(afterCompilation) {
                var result;
                result = afterCompilation.call({
                    data : data,
                    file : copyToObj
                });
                if(result.data != data) {
                    let newData = result.data;
                    data = (newData  != undefined && newData  != null) ? newData : data;
                }
                copyTo = result.file;
            }
            options.fileContent[copyTo] = data;
            var copyToObj = path.parse(copyTo);
            this.mkdir(copyToObj.dir,function(err) {
                if(err) {
                    callback(err);
                    return;
                }
                minify ? this.minify(options,{
                    src : copyTo,
                    content : data,
                    dist : copyTo
                },callback) : this.write(copyTo,data,callback);
            }.bind(this));
        }
    },
    errorClass : {
        createErrorObj : function(options,obj) {
            try {
                const {codeFrameColumns} = require("@babel/code-frame");
                var pushingTheErrorObj = function(file,message,line,column,sourceCode,tag){
                    options.errorObj[file] = options.errorObj[file] || [];
                    var formattedSourceCode = '';
                    if(sourceCode){
                        formattedSourceCode = codeFrameColumns(sourceCode,line,column,{highlightCode:false});
                    }
                    options.errorObj[file].push({
                        message : message,
                        line : line,
                        column : column,
                        tag : tag,
                        source : formattedSourceCode,
                        level : "error"
                    });
                };
                var result = obj.errMsg || obj.message;
                if(Array.isArray(result)){
                    result.forEach(function(report){
                        if(report.messages.length){
                            report.messages.forEach(function(message){
                                pushingTheErrorObj(report.filePath,message.message,message.line,message.column,report.source,message.tag);
                            });
                        }
                    });
                } else {
                    var file = obj.file;
                    if(file){
                        pushingTheErrorObj(file,result,obj.line,obj.column,obj.sourceCode,obj.tag);
                    }
                }
            } catch(e) {
    
            }
        },
    
        handleWarnings : function(options,obj,disableLogs) {  
            var level = obj.level;
            var warningLevel = options.showWarningLevel || level;
            obj.systemLog({msg : obj.message,type :"WARNING",_zl_timestamp: new Date().getTime()});
            if(warningLevel != level) {         
                return;
            }
            if(options.production && level == 2) {
                return;
            }
            if(!disableLogs) {
                if(obj.tableDisplay) {
                    options.groupLogMessage[obj.commonContent].msg.push(obj.tableContent);
                } else {
                    options.warningsCount++;
                    obj.userLog({msg :obj.message,color:"yellow"});
                }
            }
    
        },
    
        handleErrors: function(options,obj,reject,resolve,alwaysExit) {  
            options.errorCount++; 
            var message = obj.message;   
            
            obj.systemLog({msg : message,throwable : obj.stack,type : "SEVERE",_zl_timestamp:obj._zl_timestamp});    
            if(!options.watch || alwaysExit) {
                reject(obj);
            } else {
                obj.userLog({msg : message,color:"red"});
                if(!options.production){
                    // The error object must have file name,line,column,source code,error message and tag(for html errors).
                    this.createErrorObj(options,obj);
                }
                if(resolve) {
                    resolve(obj);
                }
            }
        }
    },
    commonCliUtils : {
        loopedTheArrayAddMapping : function(array,srcFileName,ob) {
            let {originalLineOffset,generatedLineOffset,sourceMapObj} = ob;
            array.forEach(function() {
                sourceMapObj.addMapping({
                    source : srcFileName,
                    original : {
                        line : ++originalLineOffset,
                        column : 0
                    },
                    generated : {
                        line : ++generatedLineOffset,
                        column :  0
                    }
                })
            })
           return (ob = {originalLineOffset,generatedLineOffset,sourceMapObj});
        },
        constructMappingForComponents : function(beforeStr,template,afterStr,sourceFileName,distFileName,originalSource,callback) {
            try {
                let data = '';
                let sourceMapObj = new sourceMap.SourceMapGenerator({
                    file : distFileName
                });
                let originalLineOffset = 0,generatedLineOffset = 0;
                let ob = {sourceMapObj,generatedLineOffset,originalLineOffset};
                ({ sourceMapObj,generatedLineOffset,originalLineOffset } = this.loopedTheArrayAddMapping(beforeStr.split("\n"),sourceFileName,ob));
                template.split('\n').forEach(function(){
                    sourceMapObj.addMapping({
                        source : sourceFileName,
                        original : {
                            line : originalLineOffset,
                            column : 0
                        },
                        generated : {
                            line : ++generatedLineOffset,
                            column : 0
                        }
                    })
                });
                ({sourceMapObj} =  this.loopedTheArrayAddMapping(afterStr.split("\n"),sourceFileName,{sourceMapObj,generatedLineOffset,originalLineOffset}));
                data += beforeStr+"\n"+template+afterStr;
                sourceMapObj.setSourceContent(sourceFileName,originalSource);
                callback(null,data,sourceMapObj.toString());
            } catch(e){
                callback(e);
            } 
        },
        minifyHTMLContent : function(content) {
            if(!(content.includes("<pre ") || content.includes("<pre>"))) {
                content = content.replace(/\r?\n|\r/g,' ').replace(/\s+/g,' ');
            } else {
                var count = 0;
                var preContentArr = [];
                var matchingReturn = function(html) {
                    var match= [null];
                    match[0] = html.indexOf('<pre ') 
                    match[1] = html.indexOf('<pre>')
                    return match[0] == -1 ? ( match[1] == -1 ? null : match[1]) : ( match[1] == -1 ? match[0] : (match[0] < match[1] ?  match[0] : match[1]));
                }
                var preTagRemover = function(html,nextIndex) {
                    var startIndex = nextIndex || matchingReturn(html);
                    var endIndex = html.indexOf('</pre>')+6;
                    var preContent = html.substring(startIndex+4,endIndex);
                    var remContent = html.substring(endIndex);
                    var nextPreIndex,
                        nextEndIndex;
                    while((nextPreIndex = matchingReturn(preContent))) {
                        preContent = preContent.substring(nextPreIndex+4,endIndex);
                        nextEndIndex = remContent.indexOf('</pre>')+6;
                        endIndex = endIndex+nextEndIndex;
                        remContent = remContent.substring(nextEndIndex);
                    }
                    preContent = html.substring(startIndex,endIndex);
                    preContentArr.push(preContent);
                    html = html.replace(preContent,'<<<_pre'+count+'>>>');
                    if((nextIndex = matchingReturn(html))) {
                        count++;
                        return preTagRemover(html,nextIndex);
                    } 
                    return html;
                    
                };
                content = preTagRemover(content);
                content = content.replace(/\r?\n|\r/g,' ').replace(/\s+/g,' ')
                for(var index = 0;index<=count;index++) {
                    content = content.replace('<<<_pre'+index+'>>>',preContentArr[index]);
                }
            }
            return content;	
        },
        createAnHTMLObject : function(options,errorObj) {
            var htmlObj ='',
            styleData = utils.fileManipulation.readSync(path.join(options.cliRoot,"lib","webSocket","error-page.css"),'utf-8')
            
            htmlObj += `<html><head><style>`+styleData+`</style>
            </head><body>`+
            `<div class="lyteErrorPageContainer">
            <div class="errorBoxWrap">`;	
            var str =''	;
            for(var fileName in errorObj) {
                str += `<div class="lyteErrorBox">
                <div> <span class="FileNameLabel">`+fileName+`</span></div>`
                errorObj[fileName].forEach(function(value,index) {
                    str += `<div class="messageList"> <span class="errorNo">`+(index+1)+`</span>`;
                    str += `<span class="mainErrorMsg">`+value.message+`</span>`;
                    if(value.line) {
                        str+=` in line number `+value.line;
                    }
                    if(value.column) {
                        str+=`:`+value.column;
                    }
                    if(value.tag) {
                        str+=`=> `+value.tag.replace(/\</g,'&lt').replace(/\>/g,'&gt')+"";
                    }
                    if(value.source) {
                        str+=`<div class="errorPreWrap"><pre class="errorCode">`+value.source.replace(/\</g,'&lt').replace(/\>/g,'&gt')+`</pre></div>`
                    }
                    str +='</div>'	
                })
                str+='</div>'
            }
            htmlObj += str;
            htmlObj += `</div></div>`		
            htmlObj+`</body></html>`;
    
            return htmlObj;
        },
        convertStringToCamelCase : function(input) {
            const preserveCamelCase = (string, locale) => {
                let isLastCharLower = false;
                let isLastCharUpper = false;
                let isLastLastCharUpper = false;
                for (let i = 0; i < string.length; i++) {
                    const character = string[i];	
                    if (isLastCharLower && /[\p{Lu}]/u.test(character)) {
                        string = string.slice(0, i) + '-' + string.slice(i);
                        isLastCharLower = false;
                        isLastLastCharUpper = isLastCharUpper;
                        isLastCharUpper = true;
                        i++;
                    } else if (isLastCharUpper && isLastLastCharUpper && /[\p{Ll}]/u.test(character)) {
                        string = string.slice(0, i - 1) + '-' + string.slice(i - 1);
                        isLastLastCharUpper = isLastCharUpper;
                        isLastCharUpper = false;
                        isLastCharLower = true;
                    } else {
                        isLastCharLower = character.toLocaleLowerCase(locale) === character && character.toLocaleUpperCase(locale) !== character;
                        isLastLastCharUpper = isLastCharUpper;
                        isLastCharUpper = character.toLocaleUpperCase(locale) === character && character.toLocaleLowerCase(locale) !== character;
                    }
                }
            
                return string;
            };
            const postProcess = (input) => {
                return input.replace(/[_.\- ]+([\p{Alpha}\p{N}_]|$)/gu, (_, p1) => p1.toLocaleUpperCase(locale))
                    .replace(/\d+([\p{Alpha}\p{N}_]|$)/gu, m => m.toLocaleUpperCase(locale));
            };
            
            
            let locale = 'en-US'
            if (input.length === 1) {
                return input.toLocaleLowerCase(locale);
            }
        
            const hasUpperCase = input !== input.toLocaleLowerCase(locale);
        
            if (hasUpperCase) {
                input = preserveCamelCase(input,locale)
            }
        
            input = input.replace(/^[_.\- ]+/, '');
            input = input.toLocaleLowerCase();
            return postProcess(input);	
        },
    
        tryCatch : function(fn,optName,package) {
            try {
                fn();
            } catch(e) {
                throw (optName ? new Error("Dependencies of "+optName+' named '+package+' missing.\nInstall the dependencies using npm') : e);
            }
        },
        convertHTMLToJS : function(options,obj,callback) {
            let fileName = obj.htmlFile,
                name = obj.name,
                concatenatedString = function(filePath) {
                    return "/*--System generated component concatenation "+filePath+"---*/\n"
                },
                lyteFilePath = obj.lyteFilePath,
                fileContent = obj.htmlContent;	
            var data = fileContent.replace(/forEach\s+\(.*?}\)/g,"$&"+";"),
                reg = /<\s*%|%\s*>|<\s*!\s*-\s*-/g;	 
            let errorCallback = function(type,line){
                let err = new Error("Unexpected "+type+" parenthesis in "+path.relative(options.root,fileName)+" at the line number "+line);
                err.line = line;
                err.errMsg = "Unexpected "+type+" parenthesis";
                err.file = fileName;
                err.timestamp = new Date().getTime();
                callback(err);
            };     
            let escapeSpecialChar = utils.stringManipulation.escapeSpecialChar;
            let minifyHTMLContent = this.minifyHTMLContent;
            if(data.includes("<%") || data.includes("<!--") || data.includes("%>")) {
                var lastIndex = 0,
                    match,
                    matchedIndex,
                    loopCnt = 0,
                    stack = [],
                    content,
                    functionSyntax = "function "+name.replace(/-/g,'$')+"(){ ";
                    functionSyntax += "\n\t";
                
                while(match = reg.exec(data))  {  
                    matchedIndex = match.index;					
                    content = data.substring(lastIndex,matchedIndex);				
                    if(match[0] == "<%" || match[0] == "<!--") { 				
                        if(match[0] != "<!--") {										
                            if(stack.length != 0) {
                                errorCallback("opening",predictLineNo(fileContent,matchedIndex)+1);
                                return;
                            }
                            stack.push("<%");
                        }        	           	
                        if(loopCnt == 0 ) {
                            functionSyntax += 'var str=';
                        } else {
                            functionSyntax += '\nstr +=';
                        }
                        content = escapeSpecialChar(content);
                        functionSyntax +=  content +";";	              
                    } else  {            	
                        if(match[0] == "%>") {
                            if(stack.length != 1) {
                                errorCallback("closing",predictLineNo(fileContent,matchedIndex))
                                return;
                            }
                            stack.pop();
                        }	
                        functionSyntax += content;
                    }
                    if(match[0] == "<!--") {					
                        reg.lastIndex = lastIndex = data.indexOf("-->",match.index)+"-->".length; 
                    } else {
                        lastIndex = match.index + 2;
                    }			
                    loopCnt++;
                }	
                if(stack.length != 0) {
                    errorCallback("opening",predictLineNo(fileContent,matchedIndex));
                    return;
                }
                content = data.substring(lastIndex);
                if(content) {   
                    if(loopCnt == 0 ) {
                        functionSyntax += 'var str=';
                    } else {
                        functionSyntax += '\nstr +=';
                    }
                    functionSyntax += escapeSpecialChar(content) +";";
                }
                functionSyntax += "}";            
                functionSyntax = concatenatedString(lyteFilePath)+functionSyntax;
                callback(null,{
                    functionSyntax : functionSyntax,
                    htmlContent : ''
                });
            } else {
                callback(null,{
                    htmlContent : minifyHTMLContent(data)
                });
            }
        },
        checkAnyKeyInObj : function(obj) {
            var anyKeyExist = false;
            for(let key in obj) {
                anyKeyExist = true;
                break;
            }
            return anyKeyExist;
        },

        returnDiffPairsInObj : function(obj,obj1) {
            var newObj = {
                deletedKeys : [],
                newPairsInObj : {}
            };
            var isEqual;
            function compareTheValues(array,array1) {
                var lengthOfArray = array.length;
                var lengthOfArray1 = array1.length;
                var baseArray;
                var checkWith;
                if(lengthOfArray >= lengthOfArray1) {
                    baseArray = array;
                    checkWith = array1;
                } else {
                    baseArray = array1;
                    checkWith = array;
                }
                for(var index = 0,len = baseArray.length;index<len;index++) {
                    if(!checkWith.includes(baseArray[index])) {
                        return false;
                    }
                }
                return true;
            }
            let key;
            for(key in obj) {
                if(obj1[key]) {
                    isEqual = compareTheValues(obj[key],obj1[key]);
                    if(!isEqual){
                        newObj.newPairsInObj[key] = obj1[key];
                    }
                } else {
                    newObj.deletedKeys.push(key);
                }
            }
    
            for(key in obj1) {
                if(obj[key]) {
                    isEqual = compareTheValues(obj[key],obj1[key]);
                    if(!isEqual){
                        newObj.newPairsInObj[key] = obj1[key];
                    }
                } else {
                    newObj.newPairsInObj[key] = obj1[key];
                }
            }
            return newObj;
        },	

        checkForLyte : function(options,module) {
            var srcBuild = path.join(options.root,"build","build.js");
            switch(module) {
                case "app" :
                    return utils.fileManipulation.fileExist(srcBuild) ? true : false;
                case "addon":
                case "engine":  
                    return require(srcBuild)[module] ? true : false;      
            }
        },
        validateHelperName : function(name) {
            let check = ['-','+','*','/','%','?','=','!']
            for(let index = 0,len = check.length;index <len;index++) {
                if(name.includes(check[index])) {
                    return false;
                }
            }
            return true;
        },

        validateComponentName : function(name) { /*component and test name should follow the rules that doesn't contain number capital and should be hypenated*/
            var reg = /([a-z][a-z0-9]*(-[a-z0-9]+)+)/;
            var matched = name.match(reg);
            return (matched && matched[0] == name);
        },
        
        validateWidgetName : function(name) { /*component and test name should follow the rules that doesn't contain number capital and should be hypenated*/
            var reg = /([a-z0-9])*(\-([a-z0-9])*)?/;
            var matched = name.match(reg);
            return (matched && matched[0] == name);
        },
        validateWidgetComponentName : function(name,namespace) {
            if(name.startsWith(namespace)) {
                return true;
            }
            return false;
        },
        checkForAlreadyExistence : function(options,module) {
            var fileManipulation = utils.fileManipulation;
            var srcFolderModule = options.folders.src[module]
            if(fileManipulation.fileExist(srcFolderModule)) {
                var fileList = fileManipulation.getFilesListSync(srcFolderModule);
                for(var index = 0 ;index < fileList.length ;index++) {
                    if(options.cliArgs[2] == path.parse(fileList[index]).name) {
                        return true;
                    }
                }
                return false;
            } 
            return false;
        },
        validateModuleName :  function(value,defaultModules) { /*for generate and destroy command */
            // var modules =  ["route","component","helper","model","adapter","mixin","serializer","test","theme","blueprint"];
            if(defaultModules.includes(value)) {
                return true;
            } 
            return false;
        },
        removeEmptyFolder : function(dir,baseRoute,options) {
            var base;
            var fileManipulation = utils.fileManipulation;
            base = baseRoute ? path.relative(process.cwd(),options.folders.src[baseRoute]) :  path.relative(process.cwd(),options.root);
            dir = path.relative(process.cwd(),dir);
            dir = dir.split(path.sep);
            dir.pop();
            if(dir = dir.join(path.sep)) {
                if(dir != base) {
                    if(fileManipulation.fileExist(dir)) {
                        var file;
                        if(file = fs.readdirSync(dir)) {				
                            if(!file.length) {							
                                fileManipulation.removeSync(dir,true);
                                this.removeEmptyFolder(dir,baseRoute,options);
                            }
                            return;
                        }
                    }
                }
            }
        },
        consoletable : function(table,row,column) {
            return table(row,column);
        },
    },
    
    cliSpinner : function(obj) {
        let consoletable = utils.commonCliUtils.consoletable;
        let chalk ={};
        let Multispinner;
        let logPrinting = function(options) {
            if(options.fromCommandLine) {
                printLogs(options.pushTheLog,options.groupWarnings)
            } else {
                !options.inapp && printLogs(options.pushTheLog,options.groupWarnings);
            }
        }

        let allDone = true,
            printLogs = function(logStack) {		
                var color;
                var msg,fn;
                var stack;
                var callback;
                var i,len;
                for(i = 0, len = logStack.length; i<len; i++){
                    msg = logStack[i].msg;
                    fn = logStack[i].row;
                    column = logStack[i].column;
                    color = logStack[i].color || 'blue';
                    callback = logStack[i].callback;
                    console.log(chalk[color](msg || fn && console.table(fn,column)));
                    if(stack = logStack[i].stack) {
                        console.log(stack);
                    }
                    if(callback){
                        callback();
                    }
                }
                userLogs = [];
            };
        if((obj.production)) { 		
            let chalkColor = ["red",'yellow','blue','grey','green','cyan',"white"];
            let length = chalkColor.length;
            for(let i =0;i<length;i++) {
                chalk[chalkColor[i]] = function(msg) {
                    return msg;
                }
            }
            console.table = function(row) {
                console.table(row);
            }
        } else {
            Multispinner = require('multispinner');
            table = require('table').table;
            chalk = require("chalk");
            console.table = function(msg,column) {
                var keysLen = msg[0].length;
                var width = Math.floor(process.stdout.columns/keysLen)-10;
                return consoletable(table,msg,column ? column  : { 
                    columnDefault: {
                        width: width
                    }
                });
            }
        }
        return {
            startSpinner : function(spinnerInfo,options) {
                if(spinnerInfo.module) {
                    if(options.multispinner) {
                        allDone = false;
                        options.multispinner.spinners[spinnerInfo.module] = {
                            state: "incomplete",
                            text: spinnerInfo.msg
                        };
                    } else {
                        var info = {};
                        var module = spinnerInfo.module;
                        var multispinnerModule;
                        info[module] = spinnerInfo.msg;				
                        if(options.production || options.nospinner) {
                            allDone = false;						
                            options.multispinner =  {
                                success : function(mod) {
                                    let incompleteState = false;
                                    let thisSpinnerObj = this.spinners;
                                    let key;
                                    thisSpinnerObj[mod].state="success";									
                                    for(key in thisSpinnerObj) {
                                        if(thisSpinnerObj[key].state == "incomplete") {
                                            incompleteState = true;
                                        }
                                    }
                                    if(!incompleteState) {
                                       
                                        allDone = true;
                                        logPrinting(options);
                                    }	
                                },
                                error : function(mod,err) {
                                    this.spinners[mod].state = "error";						
                                    allDone=true;
                                    printLogs(options.pushTheLog,options.groupWarnings);
                                    options.reject(err || new Error("Lyte build failed"));
                                }	
                            };
                    
                            options.multispinner.spinners = options.multispinner.spinners || {};
                            multispinnerModule = options.multispinner.spinners;
                            multispinnerModule[module]= multispinnerModule[module] || {};
                            multispinnerModule[module].state="incomplete";
                            multispinnerModule[module].text=spinnerInfo.msg;						
                        } else { 
                            options.multispinner = new Multispinner(info,{ indent: 0, frames: ['', '', '', '', '', '', '', '', '', ''], interval: 80 });					
                            allDone = false;
                            options.multispinner.on('done',(spinner) => {
                            });
                            options.multispinner.on('err',(spinner) => {
                                allDone = true;	
                                printLogs(options.pushTheLog,options.groupWarnings);
                                userLogs = [];		
                            });
                            options.multispinner.on('success', () => {
                                allDone = true;
                                logPrinting(options);
                                userLogs = [];
                            });							
                        }	
                    }
                } else {
                    if(allDone) {
                        printLogs([spinnerInfo]);
                    } else {
                        options.pushTheLog.push(spinnerInfo);
                    }
                }
            }
        }
    }
}
module.exports = utils;