var fs = require("fs");
var path = require("path");
var inquirer = require("inquirer");
var semver = require("semver");
var toInstall = [];
var init_cwd = process.env.INIT_CWD;
var fromAddons = false;
var currentWorkingDir = process.cwd();
if (init_cwd == currentWorkingDir) {
  if (fs.existsSync(path.join(currentWorkingDir, "testApp"))) {
    baseDir = path.join(currentWorkingDir, "testApp");
    fromAddons = true;
  } else {
    baseDir = init_cwd;
  }
} else {
  baseDir = path.join(currentWorkingDir, "..", "..", "..");
}
console.log("Directory the post install begins " + baseDir);
var addonEntry = function (appNodePackagePath, name) {
  const content = fs.readFileSync(appNodePackagePath, 'utf-8');
  var baseDirPackageContent = JSON.parse(content);//No I18n
  var resolutionContent = baseDirPackageContent.resolution || {};
  var addonsEntryContent = baseDirPackageContent.addons || [];
  console.log("Package json path for adding the entry " + appNodePackagePath);
  console.log("Already existing entry of the package.json ", addonsEntryContent);
  baseDirPackageContent.resolution = Object.assign(resolutionContent, resolution);
  if (!addonsEntryContent.includes(name)) {
    addonsEntryContent.push(name);
  }
  baseDirPackageContent.addons = addonsEntryContent;
  fs.writeFileSync(appNodePackagePath, JSON.stringify(baseDirPackageContent, null, ' '));
  if (fromAddons) {
    const destPath = path.join(baseDir, "node_modules", name, "node_modules");
    if (fs.existsSync(destPath)) {
      fs.rmdirSync(destPath, { recursive: true });
    }
    fs.mkdirSync(path.parse(destPath).dir, { recursive: true });
    fs.symlinkSync(path.join(init_cwd, "node_modules"), destPath, "dir");//No I18n
  }
};
var appNodePackagePath = path.join(baseDir, "package.json");
var appNodeModulesPath = path.join(baseDir, "node_modules");
var appNodeModules = fs.existsSync(appNodeModulesPath) ? fs.readdirSync(appNodeModulesPath) : [];
var resolution = {};
fs.readFile('package.json', 'utf-8', function (err, data) {
  var jsonObj = JSON.parse(data);
  var flatDependencies = jsonObj.flatDependencies || [];
  var devDependencies = jsonObj.devDependencies || [];
  var len = flatDependencies.length;
  let count = 0, index = 0;
  var installThePackage = function () {
    if (toInstall.length) {
      console.log("Installing the flat dependencies ..............");
      console.log("Package going to install " + toInstall);
      var child = require("child_process").execSync;
      var npmPath = child('npm root -g').toString().trim();
      var path = require("path");
      npmPath = path.join(npmPath, "npm");
      var npm = require(npmPath);
      process.chdir(baseDir);
      npm.load(function (err) {
        const http = "ht" + "tp";//No I18n
        console.log("Npm install done in the directory " + process.cwd());
        npm.config.set("registry", http + "://integ-docker:4873");//No I18n
        npm.config.set("save-exact", true);
        npm.commands.install(toInstall, function (err, data) {
          if (err) {
            console.log(err);
            process.exit(2);
          } else {
            addonEntry(appNodePackagePath, jsonObj.name);
          }
        });
        npm.on('log', function (message) {
          console.log(message);
        });
      });
    } else {
      addonEntry(appNodePackagePath, jsonObj.name);
    }
  };
  function processDevelopmentSetUp(key, callback) {
    console.log("Flat dependency package name " + key);
    if (devDependencies[key]) {
      console.log("Key " + key + "is in the devDependencies");
      if (appNodeModules.includes(key)) {
        console.log("Key is already in the app node_modules path")
        var data = fs.readFileSync(path.join(appNodeModulesPath, key, "package.json"), 'utf-8');
        console.log("DATA", data);
        var packagePathObj = JSON.parse(data);
        var idPackageVersion = packagePathObj.version;
        console.log(appNodeModulesPath, key, idPackageVersion);
        console.log(devDependencies[key]);
        if (!semver.satisfies(idPackageVersion, devDependencies[key])) {
          if (resolution[key]) {
            toInstall.push(key + '@' + resolution[key]);
            callback();
          } else {
            inquirer.prompt([
              {
                type: 'list',
                name: 'versionList',
                message: "Conflict on version of " + key + ",Which version to choose for the " + key + "package",
                choices: [idPackageVersion, devDependencies[key]]
              }
            ]).then(answers => {
              let version = answers.versionList;
              console.log("version " + version);
              resolution[key] = version;
              toInstall.push(key + '@' + version);
              callback();
            }).catch(error => {
              console.log("Error on installing the package " + error.message);
              console.log("Incompatible version existence for  " + key + " in the dependencies " + packageName + "\n Expected version of " + key + ": " + devDependencies[key] + "\nVersion already installed of " + key + " :" + idPackageVersion);
              process.exit(2);
            });
          }
        }
      } else {
        console.log("Key is not in the app node_modules path");
        toInstall.push(key + '@' + devDependencies[key]);
        callback();
      }
    } else {
      console.log("Key " + key + "is not in the devDependencies");
      callback();
    }
  }

  function cb() {
    count++;
    if (count == len) {
      console.log("Count matched with the flat dependencies length");
      installThePackage();
    } else {
      processDevelopmentSetUp(flatDependencies[++index], cb);
    }
  }
  if (!len) {
    installThePackage();

  } else {
    console.log("process started");
    processDevelopmentSetUp(flatDependencies[0], cb);
  }


});