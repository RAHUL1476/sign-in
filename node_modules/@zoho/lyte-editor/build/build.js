//ignorei18n_start
'use strict';
// const {execSync} = require('child_process');
var path,
	includeStyle,
	fs,
	sane,
	buildUtils,
	buildOptions,
	overrideMapping = {},
	consolidationConfig;


const merge = function (defaults, overrider) {
	const merged = defaults;
	for (let key in overrider) {
		if (Array.isArray(overrider[key]) && Array.isArray(merged[key])) {
			merged[key] = Array.from(new Set(merged[key].concat(overrider[key])));
		} else if (typeof overrider[key] === 'object' && typeof merged[key] === 'object') {
			merged[key] = merge(merged[key], overrider[key]);
		} else {
			merged[key] = overrider[key];
		}
	}
	return merged;
}
const getConsolidationPaths = function () {
	const compressionPath = path.join(buildOptions.root, 'lib/builder/compression.json');
	let json = {};
	try {
		json = JSON.parse(fs.readFileSync(compressionPath, 'utf-8'));
	} catch (e) {
		buildOptions.log.user({ msg: 'ERROR : ' + e.message })
	}
	const filesToCompress = [];
	filesToCompress.push.apply(filesToCompress, json.baseJsFiles);
	for (let option in buildOptions.lyteEditor) {
		if (buildOptions.lyteEditor[option]) {
			filesToCompress.push.apply(filesToCompress, json[option] || [])
		}
	}
	return filesToCompress;
}
const getInitialFiles = function () {
	const compressionPath = path.join(buildOptions.root, 'lib/builder/compression.json');
	let compressionJson = {};
	try {
		compressionJson = JSON.parse(fs.readFileSync(compressionPath, 'utf-8'));
	} catch (e) {
		buildOptions.log.user({ msg: 'ERROR : ' + e.message })
	}
	const filesToCompress = [];
	// if (buildOptions.lyteEditor.bundleCommonUtils) {
	// 	const config = buildOptions.lyteEditor;
	// 	let basePath = config.macros[config.environment]['PATH:COMMON_UTILS_BASE_PATH'];
	// 	if (typeof basePath === 'function') {
	// 		basePath = basePath(buildOptions);
	// 	}
	// 	const filesToBundle = [
	// 		'main.js',
	// 		'descriptorCodes.js',
	// 		'deepFreezer.js',
	// 		'deepClone.js',
	// 		'defineProp.js',
	// 		'throwHandler.js',
	// 		'checkType.js',
	// 		'changeCase.js',
	// 		'devLog.js',
	// 		'pubsub.js',
	// 		'path.js',
	// 		'uuid.js',
	// 		'state.js'
	// 	];
	// 	const relPathOfFilesToBundle = filesToBundle.map(function (js) {
	// 		return path.join(basePath, js);
	// 	});
	// 	if (config.watchDependencyChanges) {
	// 		// Promise.all(relPathOfFilesToBundle.map(replaceContent)).then(function () {
	// 		const watcher = sane(basePath);
	// 		buildOptions.log.user({
	// 			msg: 'WATCHER_ADDED_FOR : ' + basePath,
	// 			color: 'green'
	// 		});
	// 		watcher.on('change', async function (filePath, root) {
	// 			const absFilePath = path.join(root, filePath);
	// 			if (relPathOfFilesToBundle.includes(absFilePath)) {
	// 				buildOptions.log.user({
	// 					msg: 'FILE_CHANGED_FOR : ' + absFilePath,
	// 					color: 'green'
	// 				});
	// 				delete buildOptions.fileContent[absFilePath];
	// 				await buildUtils.consolidate({
	// 					file: absFilePath,
	// 					minify: buildOptions.production,
	// 					modification: 'changed'
	// 				});
	// 			}
	// 		});
	// 		// })
	// 	}
	// 	filesToCompress.push.apply(filesToCompress, relPathOfFilesToBundle);
	// }
	filesToCompress.push.apply(filesToCompress, compressionJson.initialFiles.concat(buildOptions.nonlyteapp ? compressionJson.jsForNonLyteApp : []));
	return filesToCompress;
}
const copyDependenciesJson = function () {
	const srcPath = 'lib/builder/dependencies.json';//No I18n
	const distPath = 'lib/builder/dependencies.js';//No I18n
	const dependenciesJson = fs.readFileSync(path.join(buildOptions.root, srcPath), 'utf-8');//No I18n
	const dependenciesJsonContent = '(function(){ \n\_led.dependencies = ' + dependenciesJson + ';\n}());' //No I18n
	fs.writeFileSync(path.join(buildOptions.outputFolder, distPath), dependenciesJsonContent);//No I18n
}
const removeMapLink = function () {
	if (overrideMapping.hasOwnProperty(this.file)) {
		this.data = overrideMapping[this.file];
	}
	return this.data.replace(/\/\/# sourceMappingURL=(.*)\.map$/, '');
}
// const replaceContent = function (filePath) {
// 	return new Promise(function (resolve, reject) {
// 		fs.readFile(filePath, function (err, data) {
// 			if (err) {
// 				buildOptions.log.user({
// 					type: 'error',
// 					msg: err.message
// 				})
// 				reject(err);
// 			}
// 			const context = {
// 				data: data.toString()
// 			};
// 			context.data = removeMapLink.call(context);
// 			fs.writeFile(filePath, context.data, 'utf-8', function ({ filePath, data }, err) {
// 				if (err) {
// 					buildOptions.log.user({
// 						type: 'error',
// 						msg: err.message
// 					})
// 					reject(err);
// 				}
// 				resolve();
// 			}.bind(null, {
// 				filePath: filePath,
// 				data: context.data
// 			}))
// 		})
// 	})
// }
// const checkAndRemoveMapLinksIn = function (object, { fs, buildOptions }) {
// 	for (let key in object) {
// 		const value = object[key];
// 		const filesToReplace = [];
// 		if (typeof value === 'string') {
// 			filesToReplace.push(value);
// 		} else if (Array.isArray(value)) {
// 			filesToReplace.push.apply(filesToReplace, value);
// 		}
// 		const replacerFn = function (srcPath) {
// 			const stats = fs.lstatSync(srcPath);
// 			if (stats.isFile()) {
// 				replaceContent(srcPath);
// 			} else if (stats.isDirectory()) {
// 				const childPaths = fs.readdirSync(srcPath);
// 				childPaths.forEach(function (childPath) {
// 					replacerFn(path.join(srcPath, childPath));
// 				});
// 			}
// 		}
// 		filesToReplace.forEach(replacerFn);
// 	}
// }
const addCustomConsolidations = async function () {
	// const packagesToSendToAPI = {
	// 	fs: fs,
	// 	buildOptions: buildOptions
	// }
	if (buildOptions.nonlyteapp) {
		copyDependenciesJson();
		try {
			consolidationConfig = {
				"javascript/lyte-editor.js": getInitialFiles(),
				"dependencies/lyte-editor/lyte-editor-app.js": getConsolidationPaths(),
				"javascript/lyte-editor-layout.js": [
					"components/javascript/lyte-editor-layout.js"
				]
			};
			// checkAndRemoveMapLinksIn(consolidationConfig, packagesToSendToAPI);
			await buildUtils.consolidate({
				config: consolidationConfig,
				minify: buildOptions.production,
				module: 'consolidations'
			})
		} catch (e) {
			buildOptions.log.user({ msg: "NonLyteAppError :  " + e.message })
		}
	} else {
		try {
			consolidationConfig = {
				"javascript/lyte-editor.js": [].concat(getInitialFiles(), getConsolidationPaths()),
				"javascript/lyte-editor-layout.js": [
					"components/javascript/lyte-editor-layout.js"
				]
			};
			// checkAndRemoveMapLinksIn(consolidationConfig, packagesToSendToAPI);
			await buildUtils.consolidate({
				config: consolidationConfig,
				minify: buildOptions.production,
				module: 'consolidations'
			})
		} catch (e) {
			buildOptions.log.user({ msg: 'ERROR : ' + e.message })
		}
	}
}
const constructOverrideMapping = function ({ path, fs, buildOptions }) {
	const OVERRIDES_ROOT = path.join(buildOptions.root, './lib/overrides');//No I18n
	const mapping = {};
	const getFile = function (filePath) {
		const fileStat = fs.statSync(filePath);
		if (fileStat.isDirectory()) {
			const dir = fs.readdirSync(filePath);
			dir.forEach(function (childPath) {
				getFile(path.join(filePath, childPath));
			})
		} else if (fileStat.isFile()) {
			const relSrcPath = path.relative(OVERRIDES_ROOT, filePath);
			const absFilePath = path.join(buildOptions.root, 'node_modules', relSrcPath);
			mapping[absFilePath] = fs.readFileSync(filePath, 'utf-8');
		}
	}
	getFile(OVERRIDES_ROOT);
	return mapping;
}

const getPathOfPackage = function (buildOptions, pkgToCheck, asAbsolute) {
	const fs = require('fs');
	const pathInsideParent = path.join(buildOptions.root, '../../../node_modules', pkgToCheck);
	const pathInsideAddon = path.join(buildOptions.root, '/node_modules', pkgToCheck);
	let output = '';
	if (fs.existsSync(pathInsideAddon)) {
		output = pathInsideAddon;
	} else if (fs.existsSync(pathInsideParent)) {
		output = pathInsideParent;
	} else {
		console.log({
			msg: 'Package :' + pkgToCheck + ' is not found in ' + pathInsideAddon + ' and ' + pathInsideParent
		});
	}
	if (asAbsolute) {
		return output;
	} else {
		return path.relative(buildOptions.outputFolder, output);
	}
}
/** 
	buildUtils contains all necessary functions for copying and building files.
	---------------------------------------------------------------------------------------
	* Available functions :
	---------------------------------------------------------------------------------------
	* buildUtils.copy.file({options})
		-----options-----
		src : source file
		dist : destination file
		minify : [optional]	If file needs to be minified in production mode. 
			In development mode file will be copied.(default : false)
	---------------------------------------------------------------------------------------
	* buildUtils.copy.folder({options});
		-----options-----
		src : source folder
		dist : destination folder
		minify : [optional] If folder needs to be minified in production mode. 
			In development mode file will be copied.(default : false)
	---------------------------------------------------------------------------------------
	* buildUtils.consolidate({options})
		-----options-----
		configPath : path from which, consolidation mapping json can be retrived.(json file)
					(OR)
		config : consolidation mapping(mapping)
		module : consolidating module name(any string). To store consolidation mapping json
			In order to store mapping and reusing it on build watch and build serve
		file : [optional] When a particular file is changed and needs to be re-consolidated.
	---------------------------------------------------------------------------------------

**/
/** 
	For transpiling from es6 to es5 :
	---------------------------------------------------------------------------------------
	* var transpile = require(path.join(options.cliRoot,'lib','utilities','transpile'));
		transpile({options})
		----options---
		file : single file path or path of the folder, that to convert from es6 to es5 
		(OR)		     
		content : Content of the file to convert
		dist : destination file or folder
		strict : [[optional]] To enable strict mode (default : false)
		
	---------------------------------------------------------------------------------------
**/

/**
	For compiling the themes :
	---------------------------------------------------------------------------------------
	* buildUtils.compileThemes(buildOptions,{
		src : Array of src File
		dist : destination file
		themeOptions : {
			// list of less default options
		}
	})
	
	---------------------------------------------------------------------------------------
**/

module.exports = {
	version: 1,
	addon: "lyte-editor",
	configureFolders: function (options) {
		path = options.path;
		options.outputFolder = "dist"; /* Folder at which the built files are to be needed. */
		options.autoBundle = false;/* autoBundle is to bundle all (routes,components,models,mixins,helpers and router.js file)*/
		options.theming = true;
		options.useStrict = true;
		options.liveReload = false;
		options.lyteEditor = merge({
			//ignorei18n_start
			// ? Enter the default configuration here
			environment: 'default',
			bundleCommonUtils: true,
			watchDependencyChanges: false,
			macros: {
				default: {
				}
			},
			docFormatter: {
				package: 'js-beautify',
				path: 'js/lib/beautify.js'
			}
			//ignorei18n_end
		}, options.lyteEditor || {});
		buildUtils = require(path.join(options.cliRoot, 'lib', 'utilities', 'buildUtils'));
		var folders = { /* Available modules and its folder structures.*/
			build: 'build',
			routes: 'routes',
			routers: 'router.js',
			components: 'components',
			adapters: path.join('data-store', 'adapters'),
			models: path.join('data-store', 'models'),
			serializers: path.join('data-store', 'serializers'),
			mixins: 'mixins',
			javascript: path.join('components', 'javascript'),
			templates: path.join('components', 'templates'),
			helpers: path.join('components', 'helpers'),
			styles: path.join('components', 'styles'),
			images: path.join('components', 'images'),
			themes: path.join('css'),
			tests: 'tests'
		};
		options.folders = {};
		options.folders.src = {};
		options.folders.dist = {};
		for (var key in folders) {
			options.folders.src[key] = path.join(options.root, folders[key]) /* Source folder of modules. */
			options.folders.dist[key] = path.join(options.root, options.outputFolder, folders[key]) /* Destination folder of modules,
			can be changed if needed. */
		}
	},
	/*-----------------------------------------------Build Process Starts-------------------------------------------*/
	build: async function (options, dependencies) {
		path = require('path');
		fs = dependencies.fs; /* fs-extra */
		sane = dependencies.sane; /* watcher */
		buildOptions = options;
		/*configuration for transpile*/
		options.transpile = false;
		if (options.transpile) {
			options.ignoreFoldersFromTranspile = [
				"bower_components",
				"node_modules"
			]
		}
		/* Building of modules starts. Custom modules can be added in build function. */
		await buildUtils.init(options); /* Provides options to buildUtils. */
		await buildUtils.build(['copyAppDir', 'routes', 'components', 'models', 'helpers', 'mixins']);
		addCustomConsolidations();
		Object.assign(overrideMapping, constructOverrideMapping({
			buildOptions: buildOptions,
			fs: fs,
			path: path
		}));
		//ignorei18n_start
		const toBeDeletedPaths = [
			"routes",
			"components",
			"mixins",
			"tests",
			"bower_components",
			"lib",
			"css/styles",
			"bower.json",
			"package.json",
			"router.js",
			// "build", this is not deleted as we need logs to debug in production
			"index.html",
			"package-lock.json",
			"data-store",
			"README.md",
			"CHANGELOG.md",
			"checkForDebuggers.sh"
		]
		// ? Did this parentFolder to match the folder structure for addons building and standalone building
		// ? => in Addons - buildOptions.root will be testApp's root folder
		// ? => in Standalone - buildOptions.root will be lyte-editor inside node_modules
		// const parentFolder = (buildOptions.addonsInApp ? 'node_modules' : '..');

		// const normalize = (buildOptions.inApp ? 'node_modules' : '..');
		// execSync('mkdir -p '+path.join(buildOptions.outputFolder, 'dependencies/monaco-editor/min/'));
		// execSync('rsync -a '+path.join(buildOptions.parentFolder,'node_modules/monaco-editor/min/')+" "+path.join(buildOptions.outputFolder, 'dependencies/monaco-editor/min/'))

		const copyFolders = [
			{
				src: path.join(buildOptions.root, 'lib/dependencies'),
				dist: path.join(buildOptions.outputFolder, 'dependencies/')
			}, {
				src: path.join(buildOptions.root, 'lib/assets'),
				dist: path.join(buildOptions.outputFolder, 'images/'),
			}, {
				src: path.join(getPathOfPackage(buildOptions, 'monaco-editor', true), '/min'),
				dist: path.join(buildOptions.outputFolder, 'dependencies/monaco-editor/min')
				// beforeCompilation: removeMapLink
			}
			// {
			// 	src : path.join(getPathOfPackage(buildOptions, 'monaco-editor', true), '/min-maps'),
			// 	dist : path.join(buildOptions.outputFolder,'dependencies/monaco-editor/min-maps')
			// }
		];
		// if(!buildOptions.production){
		// 	copyFolders.push({
		// 		src: path.join(buildOptions.parentFolder, 'node_modules/monaco-editor/min-maps'),
		// 		dist: path.join(buildOptions.outputFolder, 'dependencies/monaco-editor/min-maps')
		// 	});
		// }
		//ignorei18n_end
		for (let i = 0; i < copyFolders.length; i++) {
			await buildUtils.copy.folder(copyFolders[i]);
		}

		if (options.lyteEditor.docFormatter) {
			const docFormatter = options.lyteEditor.docFormatter;
			const packageName = docFormatter.package;
			const pathInsidePkg = docFormatter.path;
			if (
				//ignorei18n_start
				typeof pathInsidePkg === 'string' &&
				typeof packageName === 'string' &&
				packageName &&
				pathInsidePkg
				//ignorei18n_end
			) {
				const srcPath = path.join(getPathOfPackage(buildOptions, packageName, true), pathInsidePkg);
				const distPath = path.join(buildOptions.outputFolder, 'dependencies/miscellaneous/', path.parse(srcPath).base);//No I18n
				await buildUtils.copy.file({
					src: srcPath,
					dist: distPath,
					minify: buildOptions.production
				});
			}
		}

		if (buildOptions.production) {
			toBeDeletedPaths.forEach(async function (toBeDeletedPath) {
				await buildUtils.delete(path.join(buildOptions.outputFolder, toBeDeletedPath))
			});
		}
	},
	/*-----------------------------------------------Build Process ends---------------------------------------------*/

	builder: {
		/*----------------------------------Copy Task---------------------------------------------------------------*/
		copyAppDir: async function (module) {
			/* Comment folders to skip copying folders from source folder to destination folder. */
			/* By default outputFolder,routes,mixins,data-store,components,build will be ignored from copying */
			/* Given folder should be relative to the root path */
			var ignoreFolders = [
				//ignorei18n_start
				'node_modules',
				'tests',
				'xml.js',
				'testApp/tests',
				'synchronizer/.temp'
				//ignorei18n_end
			];
			await buildUtils._super(module, ignoreFolders);
			await buildUtils._completed(module);
		},

		/*-----------------------------------------------------------------------------------------------------------*/
		routes: async function (module) {
			await buildUtils._super(module);
			/** _super of routes
			----------------------
			* Copies route files from source folder to destination folder.	
			* Minifies route files if build is in production mode.
			**/
			await buildUtils._completed(module) /* Stops the timer and notifies that the module is completed. */
		},

		/*-----------------------------------------------------------------------------------------------------------*/
		components: async function (module) {
			includeStyle = true /* styles will be included to template by default. If not needed, toggle this property. */
			await buildUtils._super(module, { includeStyle: includeStyle });
			/** _super of components
			-------------------------
			* Compiles lyte files to html.
			* Precompiles html files to get dynamic nodes.
			* Appends style to template, if present. And then to component's javascript file.
			* Copies component's files from source folder to destination folder.	
			* Minifies components files if build is in production mode.
			**/
			await buildUtils._completed(module) /* Stops the timer and notifies that the module is completed. */
		},

		/*-----------------------------------------------------------------------------------------------------------*/
		helpers: async function (module) {
			await buildUtils._super(module);
			/** _super of helpers
			----------------------
			* Copies file from source folder to destination folder(minifies if build
					is in production mode).
			**/
			await buildUtils._completed(module) /* Stops the timer and notifies that the module is completed. */
		},

		/*-----------------------------------------------------------------------------------------------------------*/
		models: async function (module) {
			await buildUtils._super(module);
			/** _super of models
			----------------------
			* Concats model, adapter and serializer to a single file(minifies if build
					is in production mode).
			* Copies file from source folder to destination folder.	
			**/
			await buildUtils._completed(module) /* Stops the timer and notifies that the module is completed. */
		},

		/*-----------------------------------------------------------------------------------------------------------*/
		mixins: async function (module) {
			await buildUtils._super(module);
			/** _super of mixins
			----------------------
			* Copies mixins files from source folder to destination folder.	
			* Minifies mixins files if build is in production mode.
			**/
			await buildUtils._completed(module) /* Stops the timer and notifies that the module is completed. */
		}
		/*-----------------------------------------------------------------------------------------------------------*/
	},

	/*------------------------------------------Watch changes and build---------------------------------------------*/
	watcher: {
		afterDistChanges: async function (module, file, modification) {
			const config = consolidationConfig;
			for (let outputFile in config) {
				const srcPaths = config[outputFile];
				for (let i = 0, len = srcPaths.length; i < len; i++) {
					if (file.indexOf(srcPaths[i]) > -1) {
						await buildUtils.consolidate({
							file: file,
							minify: buildOptions.production,
							modification: modification
						});
						break;
					}
				}
			}

			// const compressionPath = path.join(buildOptions.root, 'lib/builder/compression.json');
			// const compressionJson = JSON.parse(fs.readFileSync(compressionPath,'utf-8'));
			// for (let outputFile in compressionJson) {
			// 	const srcPaths = compressionJson[outputFile];
			// 	for (let i = 0, len = srcPaths.length; i < len; i++) {
			// 		if (file.indexOf(srcPaths[i]) > -1) {
			// 			await buildUtils.consolidate({
			// 				file : file,
			// 				minify: buildOptions.production,
			// 				modification : modification
			// 			}); 
			// 			break;
			// 		}
			// 	}
			// }
		},
		copyAppDir: async function (module, file, modification) {
			/* Comment folders to skip copying folders from source folder to destination folder. */
			await buildUtils._super(module, {
				file: file,
				modification: modification
			});
			const watchableFiles = /.*\/lyte-editor\/lib\/dependencies\/lyte-editor\/.*?\.(js|html|css|less)/
			if (watchableFiles.test(file)) {
				await buildUtils.copy.file({
					src: file,
					dist: file.replace(/(.*\/lyte-editor)(\/lib)(\/dependencies\/lyte-editor\/.*?\.(js|html|css|less))/, buildOptions.outputFolder + '$3')
				});
			}
		},
		/*----------------------------------------------------------------------------------------------------------*/
		routes: async function (module, file, modification) {
			await buildUtils._super(module, {
				file: file,
				modification: modification
			});
			/** _super of routes on watcher
			-------------------------------
			* Copies specifed route files from source folder to destination folder.	
			* Minifies route files if build is in production mode.
			**/
		},

		/*----------------------------------------------------------------------------------------------------------*/
		components: async function (module, file, modification) {
			await buildUtils._super(module, {
				file: file,
				modification: modification,
				includeStyle: includeStyle
			});
			/** _super of components on watcher
			-----------------------------------
			* Compiles specified lyte files to html.
			* Precompiles specified html files to get dynamic nodes.
			* Appends style to template, if present. And then to component's javascript file.
			* Copies specified component's files from source folder to destination folder.	
			* Minifies specified component files if build is in production mode.
			**/
		},

		/*----------------------------------------------------------------------------------------------------------*/
		helpers: async function (module, file, modification) {
			await buildUtils._super(module, {
				file: file,
				modification: modification
			});
			/** _super of helpers on watcher
			---------------------------------
			* Copies modified file from source folder to destination folder(minifies if build is in production mode).
			**/
		},

		/*----------------------------------------------------------------------------------------------------------*/
		models: async function (module, file, modification) {
			await buildUtils._super(module, {
				file: file,
				modification: modification
			});
			/** _super of models on watcher
			-------------------------------
			* Concats model, adapter and serializer to a single file(minifies if build
					is in production mode).
			* Copies file from source folder to destination folder.	
			**/
		},

		/*----------------------------------------------------------------------------------------------------------*/
		mixins: async function (module, file, modification) {
			await buildUtils._super(module, {
				file: file,
				modification: modification
			});
			/** _super of mixins on watcher
			---------------------------------
			* Copies modified file from source folder to destination folder(minifies if build is in production mode).
			**/
		}
	}
};
//ignorei18n_end