const cssStringParser = (function (ENUMS, cssString, options) {
  let lineNo = 1;
  let column = 1;
  options = options || {};
  const regexFor = {
    colon: /^:/,
    semiColon: /^[;]*/,
    comment: /(?<before>[\s\n]*)(?<comment>\/\*.+?\*\/)(?<after>[\s\n]*)/,
    whitespace: /^\s+/,
    newLine: /^\n/g,
    identifier: /^([-\w]+)\s*/,
    openBracket: /^{/,
    closeBracket: /^}/,
    keyframe: /^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/,
    comma: /^,\s*/,
    additionalSpace: /^\s+|\s+$/g,
    selectors: /^([^{]+)/,
    propName: /^(?<beforeProperty>\s*)(?<property>([-#\/\*\\\w]+(\[[0-9a-z_-]+\])?))(?<afterProperty>\s*)/,
    propValue: /^(?:(?<beforeValue_1>\s*)(?<value_1>'(?:\\'|.)+?')(?<afterValue_1>\s*(?=;))|(?<beforeValue_2>\s*)(?<value_2>"(?:\\"|.)+?")(?<afterValue_2>\s*(?=;))|(?<beforeValue_3>\s*)(?<value_3>\([^\)]+?\))(?<afterValue_3>\s*(?=;))|(?<beforeValue_4>\s*)(?<value_4>([^};]+?))(?<afterValue_4>\s*(?=;))+)/,
    selector: /(?<before>\s*)(?<selector>(^|[^\s]).*?[^\s])(?<after>\s*)(,|$)/,
    import: /^(?<before>\s*)@import\s*(?<import>[^;]+);(?<after>[\s\n]*)/,
    charset: /^(?<before>\s*)@charset(?<charset>\s*[^;]+);(?<after>[\s\n]*)/,
    namespace: /^(?<before>\s*)@namespace(?<namespace>\s*[^;]+);(?<after>[\s\n]*)/,
    atMedia: /^@media *([^{]+)/,
    atKeyframes: /^@([-\w]+)?keyframes\s*/,
    atCustomMedia: /^@custom-media\s+(--[^\s]+)\s*([^{;]+);/,
    atSupports: /^@supports *([^{]+)/,
    atDocument: /^@([-\w]+)?document *([^{]+)/,
    atFontFace: /^@font-face\s*/,
    atHost: /^@host\s*/,
    atPage: /^@page */,
    atDocument: /^@([-\w]+)?document *([^{]+)/,
  }
  const matcher = function (regex) {
    const matches = regex.exec(cssString);
    if (matches) {
      const matchedValue = matches[0];
      updatePosition(matchedValue);
      cssString = cssString.slice(matches[0].length);
      return matches;
    }
  }
  const match = {};
  const errors = [];
  for (let key in regexFor) {
    match[key] = function (regex) {
      return matcher(regex);
    }.bind(null, regexFor[key]);
  }

  /**
   * General Utils
   */
  const throwError = function (message) {
    const error = new Error("Error at " + lineNo + ":" + column + ": " + message);
    error.line = lineNo;
    error.column = column;
    if (options.suppressErrors) {
      errors.push(error);
    } else {
      throw error;
    }
  }
  const clubGroups = function (object) {
    if (typeof object === 'object') {
      const clubbed = {};
      const regexPattern = /^(?<label>.+)_\d+$/;
      for (let key in object) {
        if (regexPattern.test(key)) {
          const value = object[key];
          const label = regexPattern.exec(key).groups.label;
          if (value !== undefined) {
            clubbed[label] = value;
          }
        } else {
          clubbed[key] = object[key];
        }
      }
      return clubbed;
    }
  }
  const trim = function (string) {
    return string ? string.replace(regexFor.additionalSpace, '') : '';//No I18n
  }
  const compileRule = function (rule, type) {
    return function () {
      const positionWatcher = getPositionWatcher();
      const matches = match[rule]();
      if (!matches) return;
      const groups = clubGroups(matches.groups);
      const value = groups[rule];
      const node = {
        type: type,
        [rule]: trim(value),
        raw: value,
        position: positionWatcher.end()
      }
      if (options.includeWhitespace) {
        node.whitespace = {
          before: groups.before || '',
          after: groups.after || ''
        }
      }
      return node;
    }
  }
  const addParent = function (object, parent) {
    const isNode = object && typeof object.type === 'string';
    const childParent = isNode ? object : parent;

    for (let key in object) {
      const value = object[key];
      if (Array.isArray(value)) {
        value.forEach(function (item) {
          addParent(item, childParent);
        });
      } else if (value && typeof value === 'object') {
        addParent(value, childParent);
      }
    }
    if (isNode) {
      Object.defineProperty(object, 'parent', {
        configurable: true,
        writable: true,
        enumerable: false,
        value: parent || null
      });
    }
    return object;
  }
  const traverseWhitespace = function () {
    const whitespace = match.whitespace();
    if (whitespace) {
      return whitespace[0];
    } else {
      return "";
    }
  }
  /**
   * Position Utils
   */
  const updatePosition = function (value) {
    const lines = value.match(regexFor.newLine) || [];
    lineNo += lines.length;
    const lastIndexOfNewLine = value.lastIndexOf('\n');
    column = lastIndexOfNewLine === -1 ? column + value.length : value.length - lastIndexOfNewLine;
  }
  const getLocation = function () {
    return {
      line: lineNo,
      column: column
    }
  }
  const getPositionWatcher = function () {
    const startLocation = getLocation();
    return {
      end: function () {
        return {
          start: startLocation,
          end: getLocation()
        };
      }
    }
  }
  /**
   * Functions to handle Comments
   */
  const parseComment = function () {
    const positionWatcher = getPositionWatcher();
    if ('/' !== cssString.charAt(0) || '*' !== cssString.charAt(1)) return;
    let index = 2;
    while (
      ("" !== cssString.charAt(index)) &&
      ("*" !== cssString.charAt(index) || "/" !== cssString.charAt(index + 1))
    ) {
      ++index;
    }
    index += 2;
    if ("" === cssString.charAt(index - 1)) {
      return throwError('End of comment missing');
    }
    const matches = match.comment();
    const groups = matches.groups;
    const node = {
      type: ENUMS.COMMENT,
      comment: groups.comment,
      position: positionWatcher.end()
    }
    if (options.includeWhitespace) {
      node.whitespace = {
        before: groups.before || '',
        after: groups.after || ''
      }
    }
    return node;
  }
  const parseComments = function (rules) {
    let comment;
    while (comment = parseComment()) {
      if (comment !== null) {
        rules.push(comment);
      }
    }
    return rules;
  }
  /**
   * Function to handle Declarations
   */
  const parseDeclaration = function () {
    const positionWatcher = getPositionWatcher();
    let propertyMatches = match.propName();
    if (!propertyMatches) { return; }
    propertyMatches = clubGroups(propertyMatches.groups);
    if (!match.colon()) { return throwError('Missing Colon'); }
    let valueMatches = match.propValue();
    if (!valueMatches) { return throwError("Value Error. Found " + valueMatches); }
    valueMatches = clubGroups(valueMatches.groups);
    const property = trim(propertyMatches.property);
    const value = trim(valueMatches.value);
    match.semiColon();
    const node = {
      type: ENUMS.DECLARATION,
      property: property.replace(regexFor.comment, ''),
      value: value ? value.replace(regexFor.comment, '') : '',
      position: positionWatcher.end()
    };
    if (options.includeWhitespace) {
      delete propertyMatches.property;
      delete valueMatches.value;
      node.whitespace = Object.assign({},
        propertyMatches,
        valueMatches
      );
    }
    return node;
  }
  const parseDeclarations = function () {
    const declarations = [];
    const declarationsNode = {
      type: ENUMS.DECLARATIONS,
      list: declarations
    }
    if (!match.openBracket()) {
      return throwError('Missing open bracket "{"')
    }
    parseComments(declarations);
    const before = traverseWhitespace();
    let declaration;
    while (declaration = parseDeclaration()) {
      if (declaration !== null) {
        declarations.push(declaration);
        parseComments(declarations);
      }
    }
    const after = traverseWhitespace();
    if (!match.closeBracket()) {
      return throwError('Missing close bracket "}"')
    }

    if (options.includeWhitespace) {
      declarationsNode.whitespace = {
        before: before,
        after: after
      }
    }
    return declarationsNode;
  }
  /**
   * Functions to handle keyFrames
   */
  const parseKeyFrame = function () {
    let matches;
    const values = [];
    const positionWatcher = getPositionWatcher();
    while (matches = match.keyframe()) {
      values.push(matches[1]);
      match.comma();
    }
    if (!values.length) return;
    return {
      type: ENUMS.KEYFRAME,
      values: values,
      declarations: parseDeclarations(),
      position: positionWatcher.end()
    }
  }
  const parseAtKeyFrames = function () {
    const positionWatcher = getPositionWatcher();
    let keyframeMatches = match.atKeyframes();
    if (!keyframeMatches) return;
    const keyframeType = keyframeMatches[1];
    let frameNameMatches = match.identifier();
    if (!frameNameMatches) {
      return throwError("@keyframes missing identifier");
    }
    const identifier = frameNameMatches[1];
    if (!match.openBracket()) {
      return throwError("@keyframes missing opening {");
    }

    let frame;
    const frames = parseComments();
    while (frame = parseKeyFrame()) {
      frames.push(frame);
      frames.push.apply(frames, parseComments());
    }

    if (!match.closeBracket()) {
      return throwError("@keyframes missing closing }");
    }

    return {
      type: ENUMS.KEYFRAMES,
      name: identifier,
      keyframeType: keyframeType,
      keyframes: frames,
      position: positionWatcher.end()
    }
  }
  /**
   * Miscellaneous Functions parsing `@` variables
   */
  const parseAtMedia = function () {
    const positionWatcher = getPositionWatcher();
    let mediaMatches = match.atMedia();
    if (!mediaMatches) return;
    const media = trim(mediaMatches[1]);
    if (!match.openBracket()) {
      return throwError("@media missing opening {");
    }
    const style = parseComments().concat(parseRules());
    if (!match.closeBracket()) {
      return throwError("@media missing closing }");
    }
    return {
      type: ENUMS.MEDIA,
      media: media,
      rules: style,
      position: positionWatcher.end()
    }
  }
  const parseAtCustomMedia = function () {
    const positionWatcher = getPositionWatcher();
    let customMediaMatches = match.atCustomMedia();
    if (!customMediaMatches) return;
    return {
      type: ENUMS.CUSTOM_MEDIA,
      name: trim(customMediaMatches[1]),
      media: trim(customMediaMatches[2]),
      position: positionWatcher.end()
    }
  }
  const parseAtSupports = function () {
    const positionWatcher = getPositionWatcher();
    let atSupportMatches = match.atSupports();
    if (!atSupportMatches) return;
    const supports = trim(atSupportMatches[1]);
    if (!match.openBracket()) {
      return throwError("@supports missing opening {");
    }
    const style = parseComments().concat(parseRules());
    if (!match.closeBracket()) {
      return throwError("@supports missing closing }");
    }
    return {
      type: ENUMS.SUPPORTS,
      supports: supports,
      rules: style,
      position: positionWatcher.end()
    }
  }
  const parseAtImport = compileRule('import', ENUMS.IMPORT);
  const parseAtCharset = compileRule('charset', ENUMS.CHARSET);
  const parseAtNamespace = compileRule('namespace', ENUMS.NAMESPACE);
  const parseAtDocument = function () {
    const positionWatcher = getPositionWatcher();
    let matches = match.atDocument();
    if (!matches) return;
    const vendor = trim(matches[1]);
    const document = trim(matches[2]);
    if (!match.openBracket()) {
      return throwError("@document missing opening {");
    }
    const style = parseComments().concat(parseRules());
    if (!match.closeBracket()) {
      return throwError("@document missing closing }");
    }
    return {
      type: ENUMS.DOCUMENT,
      document: document,
      vendor: vendor,
      rules: style,
      position: positionWatcher.end()
    }
  }
  const parseAtPage = function () {
    const positionWatcher = getPositionWatcher();
    let matches = match.atPage();
    if (!matches) return;
    const selector = parseSelector() || [];
    if (!match.openBracket()) {
      return throwError("@page missing opening {");
    }
    const declarations = parseComments();
    let declaration;
    while (declaration = parseDeclaration()) {
      declarations.push(declaration);
      declarations.push.apply(declarations, parseComments());
    }
    if (!match.closeBracket()) {
      return throwError("@page missing closing }");
    }
    return {
      type: ENUMS.PAGE,
      selector: selector,
      declarations: declarations,
      position: positionWatcher.end()
    }
  }
  const parseAtFontFace = function () {
    const positionWatcher = getPositionWatcher();
    let matches = match.atFontFace();
    if (!matches) return;
    if (!match.openBracket()) {
      return throwError("@font-face missing opening {");
    }
    const declarations = parseComments();
    let declaration;
    while (declaration = parseDeclaration()) {
      declarations.push(declaration);
      declarations.push.apply(declarations, parseComments());
    }
    if (!match.closeBracket()) {
      return throwError("@font-face missing closing }");
    }
    return {
      type: ENUMS.FONT_FACE,
      declarations: declarations,
      position: positionWatcher.end()
    }
  }
  const parseAtHost = function () {
    const positionWatcher = getPositionWatcher();
    let matches = match.atHost();
    if (!matches) return;
    if (!match.openBracket()) {
      return throwError("@host missing opening {");
    }
    const rules = parseComments().concat(parseRules());
    if (!match.closeBracket()) {
      return throwError("@host missing closing }");
    }
    return {
      type: ENUMS.HOST,
      rules: rules,
      position: positionWatcher.end()
    }
  }
  /**
   * Functions to parse rules
   */
  const parseAtRules = function () {
    if (cssString[0] !== '@') return;
    return parseAtKeyFrames()
      || parseAtMedia()
      || parseAtCustomMedia()
      || parseAtSupports()
      || parseAtImport()
      || parseAtCharset()
      || parseAtNamespace()
      || parseAtDocument()
      || parseAtPage()
      || parseAtHost()
      || parseAtFontFace();
  }
  const parseRule = function () {
    const positionWatcher = getPositionWatcher();
    const before = traverseWhitespace();
    var selector = parseSelector();
    if (!selector) {
      return throwError('selector missing');
    }
    parseComments();
    const node = {
      type: ENUMS.RULE,
      selectors: selector,
      declarations: parseDeclarations(),
      position: positionWatcher.end()
    }
    const after = traverseWhitespace();
    if (options.includeWhitespace) {
      node.whitespace = {
        before: before,
        after: after
      }
    }
    return node;
  }
  const parseRules = function () {
    let node = null;
    const rules = [];
    match.whitespace();
    parseComments(rules);
    while (
      cssString.length &&
      cssString.charAt(0) !== "}" &&
      (node = parseAtRules() || parseRule())
    ) {
      if (node !== null) {
        rules.push(node);
        parseComments(rules);
      }
    }
    return rules;
  }
  const parseSelector = function () {
    var matches = match.selectors();
    if (!matches) return;
    const modifiedSelectors = matches[0]
      .replace(/\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*\/+/g, '')
      .replace(/"(?:\\"|[^"])*"|'(?:\\'|[^'])*'/g, function (match) {
        return match.replace(/,/g, '\u200C');
      });
    return modifiedSelectors
      .match(new RegExp(regexFor.selector, 'g'))
      .map(function (selector) {
        const parsedSelector = regexFor.selector.exec(selector);
        const groups = parsedSelector.groups;
        const selectorNode = {
          type: ENUMS.SELECTOR,
          value: groups.selector.replace(/\u200C/g, ',')
        }
        if (options.includeWhitespace) {
          selectorNode.whitespace = {
            before: groups.before,
            after: groups.after
          };
        }
        return selectorNode;
      });
  }
  const parseStyleSheet = function () {
    const rules = parseRules();
    const node = {
      type: ENUMS.STYLESHEET,
      stylesheet: {
        rules: rules
      }
    }
    if (errors.length) {
      node.stylesheet.errors = errors;
    }
    return node;
  }
  return addParent(parseStyleSheet());
});
export default cssStringParser;