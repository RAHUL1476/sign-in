//ignorei18n_start
const HTMLParser = (function () {
  const regexFor = {
    startTag: /^<([-A-Za-z0-9_]+)((?:\s+[a-zA-Z_:][-a-zA-Z0-9_:.]*(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)>/,
    endTag: /^<\/([-A-Za-z0-9_]+)[^>]*>/,
    attr: /([a-zA-Z_:][-a-zA-Z0-9_:.]*)(?:\s*=\s*(?:(?:"((?:\\.|[^"])*)")|(?:'((?:\\.|[^'])*)')|([^>\s]+)))?/g
  }
  const createMapFor = function (array) {
    return array.reduce(function (acc, item) {
      acc[item] = true;
      return acc;
    }, {});
  }
  const EMPTY_ELEMENTS = createMapFor([
    "area",
    "base",
    "basefont",
    "br",
    "col",
    "frame",
    "hr",
    "img",
    "input",
    "link",
    "meta",
    "param",
    "embed",
    "command",
    "keygen",
    "source",
    "track",
    "wbr"
  ]);
  const SELF_CLOSING = createMapFor([
    "colgroup",
    "dd",
    "dt",
    "li",
    "options",
    "p",
    "td",
    "tfoot",
    "th",
    "thead",
    "tr"
  ]);
  const SPECIAL_ELEMENTS = createMapFor([
    'style',
    'script'
  ]);
  return function (htmlString, callbacks) {
    let index;
    let chars;
    let match;
    let stack = [];
    let last = htmlString;
    stack.getLastItem = function () {
      return this[this.length - 1];
    };

    function parseStartTag(tag, tagName, rest, unary) {
      tagName = tagName.toLowerCase();

      // Removed this to prevent block level elements popping out of inline elements
      // if (BLOCK_ELEMENTS[tagName]) {
      //   while (stack.getLastItem() && INLINE_ELEMENTS[stack.getLastItem()]) {
      //     parseEndTag("", stack.getLastItem());
      //   }
      // }

      if (SELF_CLOSING[tagName] && stack.getLastItem() == tagName) {
        parseEndTag("", tagName);
      }

      unary = EMPTY_ELEMENTS[tagName] || !!unary;

      if (!unary) {
        stack.push(tagName);
      }

      var attrs = [];
      rest.replace(regexFor.attr, function (match, name) {
        const arg2 = arguments[2];
        const arg3 = arguments[3];
        const arg4 = arguments[4];
        const value = arg2 ? arg2 : (arg3 ? arg3 : (arg4 ? arg4 : ''));
        attrs.push({
          name: name,
          value: value,
          escaped: value.replace(/(^|[^\\])"/g, '$1\\\"') //"
        });
      });

      if (callbacks.start) {
        callbacks.start(tagName, attrs, unary);
      }
    }

    function parseEndTag(tag, tagName) {
      var pos;
      if (!tagName) {
        pos = 0;
      } else {
        for (pos = stack.length - 1; pos >= 0; pos--) {
          if (stack[pos] == tagName) {
            break;
          }
        }
      }
      if (pos >= 0) {
        for (var i = stack.length - 1; i >= pos; i--) {
          if (callbacks.end) {
            callbacks.end(stack[i]);
          }
        }
        stack.length = pos;
      }
    }
    const replacerFn = function (all, text) {
      text = text.replace(/<!--([\s\S]*?)-->|<!\[CDATA\[([\s\S]*?)]]>/g, "$1$2");
      if (callbacks.chars) {
        callbacks.chars(text);
      }
      return "";
    }
    while (htmlString) {
      chars = true;
      if (!stack.getLastItem() || !SPECIAL_ELEMENTS[stack.getLastItem()]) {
        // Check for Comments
        if (htmlString.indexOf("<!--") == 0) {
          index = htmlString.indexOf("-->");
          if (index >= 0) {
            if (callbacks.comment) {
              callbacks.comment(htmlString.substring(4, index));
            }
            htmlString = htmlString.substring(index + 3);
            chars = false;
          }
        } else if (htmlString.indexOf("</") == 0) {
          match = htmlString.match(regexFor.endTag);
          if (match) {
            htmlString = htmlString.substring(match[0].length);
            match[0].replace(regexFor.endTag, parseEndTag);
            chars = false;
          }
        } else if (htmlString.indexOf("<") == 0) {
          match = htmlString.match(regexFor.startTag);
          if (match) {
            htmlString = htmlString.substring(match[0].length);
            match[0].replace(regexFor.startTag, parseStartTag);
            chars = false;
          }
        }
        if (chars) {
          index = htmlString.indexOf("<");
          var text = index < 0 ? htmlString : htmlString.substring(0, index);
          htmlString = index < 0 ? "" : htmlString.substring(index);
          if (callbacks.chars) {
            callbacks.chars(text);
          }
        }
      } else {
        htmlString = htmlString.replace(new RegExp("([\\s\\S]*?)<\/" + stack.getLastItem() + "[^>]*>"), replacerFn);
        parseEndTag("", stack.getLastItem());
      }
      if (htmlString == last) {
        throw "Parse Error: " + htmlString;
      }
      last = htmlString;
    }
    parseEndTag();
  }
}());
export default HTMLParser;
//ignorei18n_end