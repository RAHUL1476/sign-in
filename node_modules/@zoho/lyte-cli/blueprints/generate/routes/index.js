"use strict";
require = global.require;
var utils = require("@zoho/lyte-cli-utils"),
	fileManipulation = utils.fileManipulation,
	folders = utils.commonCliUtils,
	path = require('path'),
	CLIEngine = require("eslint").CLIEngine;
module.exports = {
	description :"routes",
	validateEntityName: function(options) {
		var entity = options.cliArgs[2];
	    if(entity.indexOf(path.sep) == -1) {
	    	return true;
	    } else {
	    	options.log.user({color : 'red', msg : "Routes should be separated by dots"});
	    	return false;
	    }
	},

	fileMapTokens :function(options)  {
		return {
			__demo__ : options.cliArgs[2].split(".").pop()
		}
	},

	locals :function(options)  {
		return  {
			id : options.cliArgs[2]
		}
	},	

	beforeInstall : function(options) {
        var folder = options.cliArgs[2].split('.'),
			pathSearch;
		if(folder.length > 1) {
			folder.pop();
			pathSearch = folder.join(path.sep);
		    if(fileManipulation.fileExist(path.join(options.folders.src.routes,pathSearch+'.js'))){	    	
		    	options.d = pathSearch;			    	
		    } else {
		    	this.reject(new Error("Error: Base route "+pathSearch+" doesn't exists"))				
			}
		} 
	},

	afterInstall :function(options)	{	
		var filePath = options.cliArgs[3] ? options.cliArgs[3] :'',			
		    routePath = options.cliArgs[2],
		    routerPath = options.folders.src.routers;
			  
	    if(!fileManipulation.fileExist(routerPath)){
	    	fileManipulation.mkdirSync(path.parse(routePath).dir);
	    	var data = fileManipulation.readSync(path.join(options.cliRoot,"blueprints","new","router.js"));
	    	fileManipulation.writeSync(routerPath,data);
	    } 

		var eslintRule = new CLIEngine({
			useEslintrc: false,
			rulePaths : [path.join(options.cliRoot,'lib','rules',"addEntry")],
			rules: {
				addrule:[2,routePath,filePath]
			},
			allowInlineConfig : false,
			fix : true,
			envs :["es6"]
		});

		var report = eslintRule.executeOnFiles([routerPath]);
		if(report.errorCount) {
			var message = report.results[0].messages[0].message;
			if(message.indexOf('No function block detected')!= -1) {
				this.reject(new Error("Error in updating router.js file: "+message));
			} else {
				var formatter = eslintRule.getFormatter("stylish");
				message = formatter(report.results);
				this.reject(new Error("Error in updating router.js file: "+message));
			}
		} else {
			CLIEngine.outputFixes(report);
			options.log.user({color : 'yellow', msg : "Updating router"});	
		}


	},
	
	beforeUninstall : function(options) {
		var pathFile = path.join(options.folders.src.routes,options.cliArgs[2].split('.').join(path.sep));
		if(fileManipulation.fileExist(pathFile))  { /*directory type route*/
	        if(fileManipulation.lstatSync(pathFile).isDirectory())  {
	            if(!options.force) {
					if(process.env.PRODUCTION) {
						this.reject(new Error('The '+options.cliArgs[1]+' to be deleted contains subfolders.Deleting the routes files '+path.relative(options.root,pathFile)+" not done"))
					} else {
						if(!fileManipulation.prompt('The '+options.cliArgs[1]+' to be deleted contains subfolders, Are you sure you want to delete '+options.cliArgs[2]+' '+options.cliArgs[1]+'?? Y/N')){
							this.reject(new Error("Deleting the routes files "+path.relative(options.root,pathFile)+" not done"));
						}
					}
	            }
	        }
      	} else if(fileManipulation.fileExist(pathFile+'.js')) { /*file type*/
         	
      	} else  {
      		this.reject(new Error(options.cliArgs[1]+" named "+options.cliArgs[2]+" doesn't exist"))
      	}	
	},

	uninstall : function(options) {
		var permitFlag = true,
			file = options.cliArgs[2].split('.').join(path.sep)+'.js',
			filePath = path.join(options.folders.src["routes"],file);
		fileManipulation.removeSync(filePath,permitFlag);
		options.log.user({color : 'green', msg : "Removed File : "+path.relative(options.root,filePath)});	
		if(fileManipulation.fileExist(options.logPath)) {
			options.log.system("Removed File : "+path.relative(options.root,filePath)+'\n');
		}				
		if(fileManipulation.fileExist(path.join(path.parse(filePath).dir,path.parse(filePath).name))) { 
           destroyRecord(options,path.join(path.parse(filePath).dir,path.parse(filePath).name));
		}
		folders.removeEmptyFolder(filePath,"routes",options);
	},
	
	afterUninstall : function(options) {
		var routerPath = options.folders.src.routers; 
		var eslintRule = new CLIEngine({
			useEslintrc: false,
			rulePaths : [path.join(options.cliRoot,'lib','rules','removeEntry')],
			rules: {
				removerule:[2,options.cliArgs[2].split('.').join(path.sep)]
			},
			allowInlineConfig : false,
			fix : true,
			envs :["es6"]
		});

		var report = eslintRule.executeOnFiles([routerPath]);
		if(report.errorCount) {
			var message = report.results[0].messages[0].message;
			if(message.indexOf('No function block detected')!= -1) {
				this.reject(new Error(message));
			} else {
				var formatter = eslintRule.getFormatter("stylish");
				message = formatter(report.results);
				this.reject(new Error(message));
			}
		} else {
			CLIEngine.outputFixes(report);
		}
	}
}

function destroyRecord(options,pathName) {
    var files = [],
	    curPath,
	    permitFlag = true;
    if(fileManipulation.fileExist(pathName) ) {
      	files = fileManipulation.readdirSync(pathName);
      	files.forEach(function(file){
        curPath = path.join(pathName,file);
          	if(fileManipulation.lstatSync(curPath).isDirectory()) {  // recursive calling
              	destroyRecord(options,curPath);
          	} else { // delete file           
				fileManipulation.removeSync(curPath,permitFlag);
				options.log.user({color : 'green', msg : 'Removed file: '+path.relative(options.root,curPath)});
          	}
        });
       	fileManipulation.removeSync(pathName,permitFlag);
    }	
}
