if(!debug) {
    console.warn = console.log = function() {};   
}
window.elifHold=false;
var templateWorker = new Worker("worker.js");
function replaceErrors(key, value) {
    if (value instanceof Error) {
        var error = {};
        Object.getOwnPropertyNames(value).forEach(function (key) {
            error[key] = value[key];
        });
        return error;
    }
    return value;
}

function getArgString(name, array) {
    let retString;
    for(let i=0;i < array.length;i++) {
        console.log("array content"+JSON.stringify(array[i]));
        if(array[i] && typeof array[i] === "object") {
            array[i] = this.getArgString(array[i].value.name, array[i].value.args);
        }
    }
    if(name) {
        retString = name +  "(" + array.toString() + ")";
    } else {
        retString = array.toString();
    }
    return retString;
}

function trimAttr(tempVal, errors, node, attrNode, componentName){
    var trimmedVal;
    trimmedVal = tempVal.replace(/((const)|(continue)|(default)|(delete)|(do)|(else)|(enum)|(export)|(extends)|(finally)|(for)|(function)|(if)|(import)|(in)|(instanceof)|(new)|(return)|(super)|(switch)|(try)|(typeof)|(var)|(void)|(while)|(with))(?!\w)/g,'__LyteHelper$1__')
    try {
        var expOutput = expHandlers.handleExpression(Espree.parse(trimmedVal), true);
        if(expOutput && (expOutput !== trimmedVal)) {
            expOutput = expOutput.replace(/__LyteHelper(\w*?)__/g,'$1' );
            tempVal = "{{" + expOutput + "}}";
        }
    } catch(e) {
        trimmedVal = trimmedVal.replace(/__LyteHelper(\w*?)__/g,'$1' );
        tempVal = trimmedVal;
        if(e.message === "Only helper function calls are allowed") {
            if(attrNode) {
                e.message = "Syntax error in node "+node.nodeName+" for the attribute: "+attrNode.nodeName+" - "+attrNode.nodeValue +" in the component "+componentName + ". Only helper function calls are allowed"
                errors.push(e);
            } else {
                e.message = "Syntax Error in node "+node.nodeName+" for :"+node.nodeValue +" in the component "+componentName + ". Only helper function calls are allowed"
                errors.push(e);
            }
        }
    }
    return tempVal;
}

function getDynamicNodes(fileName) {  
    return new Promise(async function(resolve,reject) {
        var timmer = new Date().getTime();
    var s, comp ,errors = [], warnings = [];
    if(debug) {
        comp = document.querySelector("template[tag-name='"+fileName+"']")
    } else {
        comp = document.querySelector("template[tag-name='"+fileName+"']")
    }
    console.log("components generating dynamicNodes"+fileName);
    if(!comp) {
        errors.push(new Error("Cannot find template "+fileName));           
        popTheTab(fileName,{
            componentName : fileName,
            errors : JSON.stringify(errors,replaceErrors),
            warnings : warnings
        });     
    } else {
        var nextElement = comp.nextElementSibling;
        if(nextElement && nextElement.tagName == "TEMPLATE" && nextElement.hasAttribute("view-port-template")) {
            var viewPortIf = document.createElement("template");
            viewPortIf.setAttribute("is", "if");
            viewPortIf.setAttribute("value", "{{lyteViewPort}}");
            var trueCase = document.createElement("template");
            trueCase.setAttribute("case", "true");
            trueCase.content.appendChild(document.createElement("dummy-port-element"));
            trueCase.content.appendChild(nextElement.content);
            trueCase.content.appendChild(document.createElement("dummy-port-element"));
            viewPortIf.content.appendChild(trueCase);
            var falseCase = document.createElement("template");
            falseCase.setAttribute("case", "false");
            // falseCase.innerHTML = comp.innerHTML;
            falseCase.content.appendChild(comp.content);
            viewPortIf.content.appendChild(falseCase);
            comp.innerHTML = "";
            comp.content.appendChild(viewPortIf);
        }
        s = comp.content;               
    }
    if(s) {
        splitTextNodes(s,warnings);  
        var dynamicNodes = [];
        var attrStrict = comp.getAttribute("use-strict");
        // var isStrict = ( attrStrict != null ) ? true : false;
        // var strict = window.useStrict || isStrict;
        // strict = strict ? attrStrict !== "false" : strict; 
        var strict = (attrStrict == false ||  attrStrict == "false") ? attrStrict : attrStrict == undefined ? window.useStrict: attrStrict;
        if(strict == "false") {
            strict = false;
        } else if(strict == "true") {
            strict = true;
        }

        if(strict) {
            let err;
            if(s.querySelector("script")){
                err = new Error("Security: Script tags should not be included")
                err.strict = true;
                errors.push(err);
            }
            if(s.querySelector("style")){
                err = new Error("Security: Style tags should not be included");
                err.strict = true;
                errors.push(err);
            }                 
        }
        var d = [];
        await newGetDeepNodes(fileName, comp, d, [], undefined, true , errors, warnings);
        await processTemplate(s,dynamicNodes,fileName,strict,errors,warnings);
        if(errors.length){   
            console.log(fileName);           
            popTheTab(fileName,{
                componentName : fileName,
                timeoutError :  localStorage.getItem(fileName),
                errors : JSON.stringify(errors,replaceErrors),
                warnings :warnings
            });
        } else {                
            popTheTab(fileName,{ 
                componentName : fileName,
                timeoutError :  localStorage.getItem(fileName),
                template :JSON.stringify(comp.outerHTML),
                dynamicNodes : dynamicNodes,
                 _templateAttributes : d[0],
                warnings : warnings
            });               
        }
    }

    if(new Date().getTime()-timmer > 10000) {        
        var xhr = new XMLHttpRequest();
        xhr.open("POST", 'http://localhost:'+window.location.port+'/warning', true);
        xhr.setRequestHeader("Content-Type","application/text");
        xhr.send(fileName);   
    }
     
      
    resolve();
    
    });       
}
function popTheTab(fileName,result) {
    if(production) {
        response[fileName] = response[fileName] ? Object.assign(response[fileName],result) : result;
    } else {
        worker.port.postMessage({msg :"tabfree",finalObj : result,componentName : fileName,portNo : portNo,endTime : new Date().getTime(),tabno : tabno});
    }
}
function splitTextNodes(node, warnings,svg) {
    if(node.tagName === "svg") {
        svg = true;
    }
    if(node.hasAttribute) {
        if(node.hasAttribute("lyte-for")) {
            var lyteFor = node.getAttribute("lyte-for");
            var lyteForOptions = {};
            if(node.hasAttribute("lyte-options")) {
                try{
                lyteForOptions = JSON.parse(node.getAttribute("lyte-options"));
                } catch(e) {
                    lyteForOptions = {};
                } 
            }
            var lyteForArr = lyteFor.split(" ");
            var template;
            if(node.tagName === "TEMPLATE") {
                template = node;   
            } else if(svg && node.tagName == "template"){
                template = document.createElement("template");    
                node.removeAttribute("lyte-for");
                node.removeAttribute("lyte-options");
                template.innerHTML = node.innerHTML;
                node.replaceWith(template);
                node = template;
            }
            else {
                template = document.createElement("template");    
                node.removeAttribute("lyte-for");
                node.removeAttribute("lyte-options");
                template.innerHTML = node.outerHTML;
                node.replaceWith(template);
                node = template;
            }
            node.removeAttribute("lyte-for");
            node.removeAttribute("lyte-options");
            template.setAttribute("items" , lyteForArr[0]);
            template.setAttribute("item", lyteForArr[2] || "item");
            template.setAttribute("index", lyteForArr[3] || "index");
            template.setAttribute("is", "for");
            if(lyteForOptions.unbound) {
                template.setAttribute("unbound", lyteForOptions.unbound);
            }

        } else if(node.hasAttribute("lyte-for-in")) {
            var lyteFor = node.getAttribute("lyte-for-in");
            var lyteForOptions = {};
            if(node.hasAttribute("lyte-options")) {
                try{
                    lyteForOptions = JSON.parse(node.getAttribute("lyte-options"));
                } catch(e) {
                    lyteForOptions = {};
                } 
            }
            var lyteForArr = lyteFor.split(" ");
            var template;
            if(node.tagName === "TEMPLATE") {
                template = node;
                node.removeAttribute("lyte-for-in");
                node.removeAttribute("lyte-options");
            } 
            else if(svg && node.tagName=="template"){
                template = document.createElement("template");
                node.removeAttribute("lyte-for-in");
                node.removeAttribute("lyte-options");
                template.innerHTML = node.innerHTML
                node.replaceWith(template);
                node = template;
            }
            else {
                template = document.createElement("template");
                node.removeAttribute("lyte-for-in");
                node.removeAttribute("lyte-options");
                template.innerHTML = node.outerHTML;
                node.replaceWith(template);
                node = template;
            }

            template.setAttribute("object" , lyteForArr[0]);
            template.setAttribute("value", lyteForArr[2] || "value");
            template.setAttribute("key", lyteForArr[3] || "key");
            template.setAttribute("is", "forIn");
            if(lyteForOptions.unbound) {
                template.setAttribute("unbound", lyteForOptions.unbound);
            }
        } else if(node.hasAttribute("lyte-if")) {
            var modifiedIf = handleLyteIf(node,svg);
            node.replaceWith(modifiedIf);
            node = modifiedIf;
        } else if(node.hasAttribute("lyte-switch")) {
            // handleLyteSwitch(node,svg);//af check
            var modifiedSwitch = handleLyteSwitch(node,svg);
            node.replaceWith(modifiedSwitch);
            node = modifiedSwitch;
        } else if(svg && node.tagName == "template" && node.hasAttribute("is") && /(for|forIn|if|switch)$/.test(node.getAttribute("is"))){
            var template = document.createElement("template");
            template.innerHTML = node.innerHTML
            var attrs = node.attributes;
            for(var i=0;i<attrs.length;i++) {
                template.setAttribute(attrs[i].nodeName, attrs[i].nodeValue);
            }
            node.replaceWith(template);
            node = template;
        }
    }

    if(node && node.childNodes && node.childNodes.length) {
        for(var i=node.childNodes.length-1;i>=0;i--) {
            var chlNode = node.childNodes[i];
            if(chlNode.hasAttribute) {
                if(chlNode.hasAttribute("lyte-if-else") || chlNode.hasAttribute("lyte-else")) {
                    if(!(chlNode.previousElementSibling && (chlNode.previousElementSibling.hasAttribute("lyte-if") || chlNode.previousElementSibling.hasAttribute("lyte-else-if") ) ) ) {
                        warnings.push({message: "Element with lyte-else must be preceded by a element having lyte-if or lyte-else :\n \t" + chlNode.cloneNode().outerHTML})
                    }
                } else {
                    if(ide && node.childNodes[i].getAttribute("case") == "false"){
                        window.elifHold = true;
                    }
                    splitTextNodes(node.childNodes[i], warnings,svg);    
                }
            } else {
                splitTextNodes(node.childNodes[i], warnings,svg);    
            }
        }
    }
    if(node.tagName === "TEMPLATE") {
        splitTextNodes((node.content)?node.content:createDocFragment(node), warnings ,svg);
    }
    if(node.nodeType === node.TEXT_NODE) {
        var nodeValue = node.nodeValue;
        if(nodeValue){
    let mustacheValues = nodeValue.match(/{{[^}]*?(?:(?:('|")[^\1]*?\1)[^}]*?)*}}/g); //'
    if(!mustacheValues) {
                return;
            }
            var newNodeArray = [];
            for(var i=0;i<mustacheValues.length;i++) {
                var mustacheStartIndex = nodeValue.indexOf(mustacheValues[i]);
                var mustacheEndIndex = mustacheStartIndex + mustacheValues[i].length;
                if(mustacheStartIndex) {
                        newNodeArray.push(document.createTextNode(nodeValue.substring(0, mustacheStartIndex)));
                }
                newNodeArray.push(document.createTextNode(nodeValue.substring(mustacheStartIndex, mustacheEndIndex)));
                nodeValue = nodeValue.substring(mustacheEndIndex);
            }
            newNodeArray.push(document.createTextNode(nodeValue));
            node.replaceWith.apply(node, newNodeArray);
        }
    }
}

//This method will run through all the nodes of the template and put the dynamicNode positions 
//in deepNodes and helper node positions in helperNodes
//By helper nodes, we mean all the for and if helpers which are present in the component template. 
//The template will contain the dynamicNodes. 
//For template contains - _forTemplate, which will contain the content and _dynamicNodes
//If template contains - _trueCase, _falseCase, which will contain the content and _dynamicNodes.
async function processTemplate(node, deepNodes, componentName,strict,errors,warnings,parentSvg){
    let isBreak = node.querySelector('template[is=break]');
    if(isBreak) {
        this.getTrimmedContent(node, undefined, isBreak);
    }
    let isContinue = node.querySelector('template[is=continue]');
    if(isContinue) {
        this.getTrimmedContent(node,undefined, isContinue);
    }
    this.helperNodes = [];
    if(node.hasChildNodes()) {
        let runningIndex = 0;
        for(let i=0;i<node.childNodes.length;i++) {
            let deepN = [];
            deepN.push(i);
            let index = 0;
            let svg;
            if(node.childNodes[i].tagName) {
                let tagName = node.childNodes[i].tagName;
                svg = parentSvg || tagName == "svg" ? true : false;
                let is = node.childNodes[i].getAttribute("is");
                if(tagName === "TEMPLATE" && is) {
//                        index = helperNodes.push(node.childNodes[i]);
                    //We will be adding an attribute index1 in the helper templates, 
                    //This is done because we will be storing all the helper nodes as such in an array _helperNodes in the component template. 
                    //In order to lookup to the dynamicNodes of the for template or if template, we need to have a reference of which 
                    //helper we are calling. 
                    //By this way, we will be adding an index1 Attribute which will contain index startign from 0. 
                    //This index refreshes for each component registration. 
//                        node.childNodes[i].setAttribute("index1", index-1);
                    await this.newGetDeepNodes(componentName,node.childNodes[i], deepNodes, deepN, is,strict,errors,warnings,svg);
                }
                else {
                    await this.newGetDeepNodes(componentName,node.childNodes[i], deepNodes, deepN,undefined,strict,errors,warnings,svg);
                }
            } else {
                await this.newGetDeepNodes(componentName,node.childNodes[i], deepNodes, deepN,undefined,strict,errors,warnings,parentSvg);
            }
            svg = false;
        }
    }

}
function errorNodeDetails(node){
    var str = node.cloneNode(true);
    str.innerHTML = ".....";
    return str.outerHTML;
}
//This method is the place where the deepNodes and helperNodes gets updated with the 
//Values of the positions of dynamicNodes and helperNodes. 
async function newGetDeepNodes(componentName,node, deepNodes, deepN, is,strict,errors,warnings,parentSvg) {
    node._parent = node.parentNode;
    let toBePushed;
    let errorMsg = "Usage of block helpers (for|forIn|if|switch) inside the tags (TABLE|TR|SELECT) will not work in IE11. \n If your app is supported for IE11, please use lyte ui components lyte-table and lyte-dropdown instead of table and select tags respectively";
    if(node.nodeType == 8){
        deepN.pop();
        return;
    }
    if(node.tagName && node.tagName.indexOf("-") !== -1 && node.tagName !== "LYTE-YIELD") {
        toBePushed = {"type" : "componentDynamic", position: deepN.slice()};
    }
    if(node.tagName === "LYTE-YIELD") {
        toBePushed = {"type" : "insertYield", position : deepN.slice()};
    } else 
    if(is === "registerYield" || is === "yield") {
        let dynamicNodes = [];
        if(node.tagName != "TEMPLATE"){
            errors.push(new Error("Syntax error in node '"+errorNodeDetails(node)+"' in the component "+componentName +". Yield must be given in template tag only"));
        }else{
            await this.processTemplate(node.content, dynamicNodes, componentName,strict,errors,warnings,parentSvg);
            toBePushed = {"type" : "registerYield", position: deepN.slice(), "dynamicNodes" : dynamicNodes};
        }
    } else if(is === "insertYield") {
        deepNodes.push({"type" : "insertYield", position : deepN.slice()});
    } else 
    if(is === "for") {
        let template = node;
        // if(template.parentElement && /^(SELECT|TR|TABLE)$/.test(template.parentElement.tagName)) {
        //     warnings.push({message: errorMsg});
        // }
        node._forTemplate = {};
        
        if(template) {
            node._forTemplate.content = template.content;
            node._forTemplate.content._parent = template;
            let dynamicNodes = [];
            await this.processTemplate(node._forTemplate.content, dynamicNodes, componentName,strict,errors,warnings,parentSvg);
            toBePushed = {"type": "for" ,position: deepN.slice(), "dynamicNodes":dynamicNodes};
            node = replaceParentNode(node, "for", toBePushed,componentName,errors,true,parentSvg);
        }
    } else if(is === "forIn"){
        let template = node;
        // if(template.parentElement && /^(SELECT|TR|TABLE)$/.test(template.parentElement.tagName)) {
        //     warnings.push({message: errorMsg});
        // }
        node._forInTemplate = {};
        
        if(template) {
            node._forInTemplate.content = template.content;
            node._forInTemplate.content._parent = template;
            let dynamicNodes = [];
            await this.processTemplate(node._forInTemplate.content, dynamicNodes ,componentName,strict,errors,warnings,parentSvg);
            toBePushed = {"type": "forIn" ,position: deepN.slice(), "dynamicNodes":dynamicNodes};
        }
        node = replaceParentNode(node, "forIn", toBePushed,componentName,errors,true,parentSvg);
    }
    else if(is === "switch" || is === "if"){
        // if(node.parentElement && /^(SELECT|TR|TABLE)$/.test(node.parentElement.tagName)) {
        //     warnings.push({message: errorMsg});
        // }
        let casesArr = {},defaultArr = {};
        let defaultCase = node.content.querySelector("[default]");
        let cases = node.content.querySelectorAll("[case]");
        var currentCaseTemplate;
        var rtObj = {};
        for(var i=0;i<cases.length;i++){
            let currentCase = cases[i];
            currentCaseTemplate = cases[i];
            let caseName = currentCase.getAttribute("case");
            if(is === "switch" && caseName == ""){
                caseName = "\"\"";
            }
            if(currentCase.tagName === "TEMPLATE" && !currentCase.getAttribute("is")){
                currentCase.setAttribute("case", caseName );
                currentCase = currentCase.content;
            } 
            else {
                let temp = document.createElement('template');
                let clone = currentCase.cloneNode(true);
                temp.content.appendChild(clone);
                temp.setAttribute("case", caseName );
                clone.removeAttribute('case');
                currentCaseTemplate = temp;
                currentCase = temp.content;
                cases[i].replaceWith(temp);
            }
            let dynamicNodes = [];
            currentCase._parent = node;
            await this.processTemplate(currentCase, dynamicNodes, componentName,strict,errors,warnings,parentSvg);
            var rtObj = {};
            if(is === "if") {
                replaceCaseNode(currentCaseTemplate,componentName,errors,node,rtObj,parentSvg);
            }
            
            if(caseName === "") {
                caseName = '""';
            }
            casesArr[caseName] = {dynamicNodes: dynamicNodes};
            if(is==="if") {
                continue;
            }
            let isBreak = currentCase.querySelector("template[is=break]");
            if(!isBreak) {
                if(cases[i+1]) {
                    casesArr[caseName].additional = {"next" : cases[i+1].getAttribute("case")};
                } else if(defaultCase){
                    casesArr[caseName].additional = {"default" : true};
                }
            }
            else {
                isBreak.remove();
            }
            replaceCaseNode(currentCaseTemplate,componentName,errors,node,rtObj,parentSvg);
        }
        if(defaultCase){               
            let dCase;     
            let dCaseTemplate;           
            if(defaultCase.tagName === "TEMPLATE" && !defaultCase.getAttribute("is")){               
                dCase = defaultCase.content;                  
                dCaseTemplate = defaultCase;
                }           
            else {        
                let temp = document.createElement('template');             
                let clone = defaultCase.cloneNode(true);            
                temp.content.appendChild(clone);     
                temp.setAttribute("default", '');     
                clone.removeAttribute('default');             
                dCase = temp.content;               
                dCaseTemplate = temp;
                defaultCase.replaceWith(temp);      
            }      
            let isBreak = dCaseTemplate.content.querySelector("template[is=break]");
            if(isBreak){
                isBreak.remove();
            }
            let dynamicNodes = [];          
            dCase._parent = node; 
            await this.processTemplate(dCase, dynamicNodes, componentName,strict,errors,warnings,parentSvg);     
            defaultArr = {dynamicNodes: dynamicNodes};    
            replaceCaseNode(dCaseTemplate,componentName,errors,node,rtObj,parentSvg); 
        }
        toBePushed = {"type": is, position: deepN.slice(),"cases":casesArr,"default":defaultArr};
        if(rtObj.svg){
            toBePushed.svg = true;
        }
        node = replaceParentNode(node, is, toBePushed,componentName,errors,undefined,parentSvg);
    }
    else if(is==="component") {
        
        node._componentTemplate = {};
        node._componentTemplate.content = node.content;
        let dynamicNodes = [];
        await this.processTemplate(node._componentTemplate.content, dynamicNodes, componentName,strict,errors,warnings,parentSvg);
        toBePushed = {"type" : "component", position: deepN.slice(), "dynamicNodes" : dynamicNodes};
    }
    else if(node.nodeType == 3) {
        if(node.nodeValue.indexOf("{{") !== -1) {
            let val = node.nodeValue;
                    tempVal = val.match(/{{[^}]*?(?:(?:[^\1]*?\1)[^}]*?)*}}/g);
                    if(tempVal){
                    for(let j=0;j < tempVal.length;j++){ 
                        x = trimAttr(tempVal[j], errors, node, undefined, componentName);
                        val = val.replace(tempVal[j],function(){return x});
                    }
                    node.nodeValue = val;
                }
            let mustache = await this.getMustache(node.nodeValue),dynamicValue,helperFunc;
            if(mustache && typeof mustache === 'object'){
                if(mustache.bool === false){
                    errors.push(new Error("Syntax error in node "+mustache.err+" in "+node.nodeName+" for the attribute: "+node.nodeName+" - "+node.nodeValue +" in the component "+componentName));
                }
            }
            if(mustache){
                    helperFunc = await this.getHelper(mustache,componentName);
                    if(helperFunc === false){
                        errors.push(new Error("Syntax Error in node "+node.nodeName+"for :"+node.nodeValue +" in the component "+componentName));
                        return;
                    }
            } else {
                
                errors.push(new Error("Syntax Error in node "+node.nodeName+"for :"+node.nodeValue +" in the component "+componentName));
            }    
            let dynamic = mustache;
            if(helperFunc){
                deepNodes.push({type: "text", position:deepN.slice()/*, helperInfo: helperFunc*/}); 
            }
            else if(dynamic){
                deepNodes.push({type: "text", position:deepN.slice()/*, dynamicValue: dynamic*/});
//                  LN to do
//                  deepNodes.push({type: "text", position:deepN.slice(), dynamicValue: getDynamicValue(dynamic)});                    
            }
        }
        deepN.pop();
        return;
    }
    if(node.hasAttributes && node.hasAttributes()) { //template has no attributes
        let add = false, toBeRemoved = [],attr = {},toBeAdded = [],tempObj = {};
        for(let i=0;i<node.attributes.length;i++) {
            if(node.attributes[i].nodeValue.indexOf("{{") !== -1) {
                 let val = node.attributes[i].nodeValue;
                    tempVal = val.match(/{{[^}]*?(?:(?:[^\1]*?\1)[^}]*?)*}}/g);
                    if(tempVal){
                    for(let j=0;j < tempVal.length;j++){ 
                        x = trimAttr(tempVal[j], errors, node, node.attributes[i], componentName);
                        val = val.replace(tempVal[j],function(){return x});
                    }
                    node.attributes[i].nodeValue = val;
                }
                let actValue = await this.getMustache(val,componentName), actObj ;
                console.log("actValue response "+actValue+"val given to mustache"+val)
                if(actValue && typeof actValue === 'object'){
                    if(actValue.bool === false){
                    errors.push(new Error("Syntax error in node "+actValue.err+" in "+node.nodeName+" for the attribute: "+node.attributes[i].nodeName+" - "+node.attributes[i].nodeValue +" in the component "+componentName));
                    continue;
                    }
                }
                if(actValue){
                    actObj = await this.getHelper(actValue,componentName);  
                    console.log("actValue",actValue,"actObj",actObj);
                    if(actObj === false){
                        errors.push(new Error("Syntax error in node "+node.nodeName+" for the attribute:"+node.attributes[i].nodeName+"- "+node.attributes[i].nodeValue +" in the component "+componentName));
                        continue;
                    }
                }
                else if(/{{.*}}/.test(val) && !(/\\{{.*}}/.test(val))){
                    actObj = await this.splitMixedText(val,componentName);
                //     console.log("splitmixed over actObj.name",actObj.name,actObj);
                //     var args = actObj.args;
                //       var len =actObj.args.length;
                //       for(let i=0;i<len;i++){
                //           var argLen = args[i].length;
                //           if( argLen && args[i].substr(1,argLen-2)){
                //               x1=args[i][0];
                //               x2=args[i][argLen-1];
                //               args[i] = args[i].substring(1,args[i].length-1).replace(/'/g, "\\'");
                //               args[i] = x1+args[i]+x2;
                //       }
                //   }
                }
                if( actObj && (actObj.name === "action" || actObj.name === "method") && /^(onfocus|onfocusin|onfocusout|onresize|onscroll|onclick|ondblclick|onmousedown|onmouseup|onmousemove|onmouseover|onmouseout|onmouseenter|onmouseleave|onchange|onselect|onsubmit|onkeydown|onkeypress|onkeyup|oncontextmenu)$/.test(node.attributes[i].name)){
                        add = true;
                        attr[node.attributes[i].name.substr(2)] = {name:node.attributes[i].name.substr(2),helperInfo: actObj, globalEvent: true};
                        let actArgs = deepCopyObject(actObj.args);
                        let actName = actArgs.splice(0,1)[0];
                        if (typeof actName != 'string' || !actName.startsWith("'")){
                            warnings.push({message:" action or method must start with string on "+node.nodeName+" for the attribute:"+node.attributes[i].nodeName+"- "+node.attributes[i].nodeValue});
                        }
                        else{
                        actName = actName.startsWith("'")? actName.replace(/'/g,''):  actName;
                        }
                        console.log("In action "+actName+' ,'+actArgs)
                        let actString = this.getArgString(actName, actArgs);
                        //node.setAttribute(node.attributes[i].name.substr(2),componentName+" => "+ actString);
                        toBeRemoved.push(node.attributes[i].name);                            
                }
                else{
                    // if(actObj && actObj.name == 'concat'){
                    //     let final;
                    //     let actArgs = deepCopyObject(actObj.args);
                    //     final = this.getArgString(actObj.name,actArgs)
                    //     node.attributes[i].nodeValue ="{{" + final + "}}";
                    //     }
                    if (actObj && (actObj.name === "action" || actObj.name === "method")){
                        if(actObj.args && (typeof actObj.args[0] === 'object' || !actObj.args[0].startsWith("'"))){
                            warnings.push({message:" action or method must start with string on "+node.nodeName+" for the attribute:"+node.attributes[i].nodeName+"- "+node.attributes[i].nodeValue});
                        }
                    } 
                    if(actObj || actValue) {
                        add = true;
                        let attrToPush = {};
                        if(node.attributes[i].name.startsWith("lbind:")) {
                            toBeRemoved.push(node.attributes[i].name);
                            toBeAdded.push({"name" : node.attributes[i].name.substring(6), "value": node.attributes[i].nodeValue});
                            attrToPush.isLbind = true;
                            attrToPush.name = node.attributes[i].name.substring(6);
                        }
                        else {
                            attrToPush.name = node.attributes[i].name;
                        }
                        if(actObj) {
                            if(actObj.name === "lbind") {
                                attrToPush.dynamicValue = actObj.args[0];
                                attrToPush.isLbind = true;
                            }
                            else {
                                attrToPush.helperInfo = actObj; 
                            }
                        } 
                        else {
                            attrToPush.dynamicValue = actValue;
//                              LN to do
//                              attrToPush.dynamicValue = getDynamicValue(actValue);
                        }
                        add = true;
                        attr[attrToPush.name] = attrToPush;
                    }                  
                }
                if(/^(onfocus|onfocusin|onfocusout|onresize|onscroll|onclick|ondblclick|onmousedown|onmouseup|onmousemove|onmouseover|onmouseout|onmouseenter|onmouseleave|onchange|onselect|onsubmit|onkeydown|onkeypress|onkeyup|oncontextmenu|ondragstart|ondrag|ondragenter|ondragleave|ondragover|ondrop|ondragend|onload|onunload|onabort|onerror|onscroll|onreset|onblur|onafterprint|onbeforeprint|ononbeforeunload|onerror|onhashchange|onload|onmessage|onoffline|ononline|onpagehide|onpageshow|onpopstate|onstorage|onunload|oninput|oninvalid|onsearch|ononmousewheel|onwheel|ondrag|ondragend|ondragenter|ondragleave|ondragover|ondragstart|ondrop|onscroll|ondrag|ondragend|ondragenter|ondragleave|ondragover|ondragstart|ondrop|onscroll|ondrag|ondragend|ondragenter|ondragleave|ondragover|ondragstart|ondrop|onscroll|onabort|oncanplay|oncanplaythrough|oncuechange|ondurationchange|onemptied|onended|onloadeddata|onloadedmetadata|onloadstart|onpause|onplay|onplaying|onprogress|onratechange|onseeked|onseeking|onstalled|onsuspend|ontimeupdate|onvolumechange|onwaiting|onpaste)$/.test(node.attributes[i].nodeName) && strict){
                    if(!actObj || actObj.name != "action"){
                        err = new Error("Strict-Mode: Please specify action in "+node.nodeName+" for attribute-"+node.attributes[i].nodeName);
                        err.strict= true;
                        errors.push(err);
                    }
                }
            }
            else {
                if(/^(onfocus|onfocusin|onfocusout|onresize|onscroll|onclick|ondblclick|onmousedown|onmouseup|onmousemove|onmouseover|onmouseout|onmouseenter|onmouseleave|onchange|onselect|onsubmit|onkeydown|onkeypress|onkeyup|oncontextmenu|ondragstart|ondrag|ondragenter|ondragleave|ondragover|ondrop|ondragend|onload|onunload|onabort|onerror|onscroll|onreset|onblur|onafterprint|onbeforeprint|ononbeforeunload|onerror|onhashchange|onload|onmessage|onoffline|ononline|onpagehide|onpageshow|onpopstate|onstorage|onunload|oninput|oninvalid|onsearch|ononmousewheel|onwheel|ondrag|ondragend|ondragenter|ondragleave|ondragover|ondragstart|ondrop|onscroll|ondrag|ondragend|ondragenter|ondragleave|ondragover|ondragstart|ondrop|onscroll|ondrag|ondragend|ondragenter|ondragleave|ondragover|ondragstart|ondrop|onscroll|onabort|oncanplay|oncanplaythrough|oncuechange|ondurationchange|onemptied|onended|onloadeddata|onloadedmetadata|onloadstart|onpause|onplay|onplaying|onprogress|onratechange|onseeked|onseeking|onstalled|onsuspend|ontimeupdate|onvolumechange|onwaiting|onpaste)$/.test(node.attributes[i].nodeName) && strict){
                             err = new Error("Strict-Mode: Please specify action in "+node.nodeName+" for attribute-"+node.attributes[i].nodeName);
                    err.strict= true;
                    errors.push(err);
                }  
                // else if((/{.*}/.test(node.attributes[i].nodeValue))){
                //     try {
                //         JSON.parse(node.attributes[i].nodeValue);
                //     } catch(e) {
                //         warnings.push({message:"Syntax error in node "+node.nodeName+" for the attribute:"+node.attributes[i].nodeName+"- "+node.attributes[i].nodeValue +" in the component "+componentName});
                        
                //     }
                 
                // }  
                // else if((/{.*:/.test(node.attributes[i].nodeValue)) || (/{/.test(node.attributes[i].nodeValue))) {
                //     try {
                //         JSON.parse(node.attributes[i].nodeValue);
                //     } catch(e) {                            
                //         errors.push(new Error("Syntax error in node "+node.nodeName+" for the attribute:"+node.attributes[i].nodeName+"- "+node.attributes[i].nodeValue +" in the component "+componentName));
                //         continue;
                //     }
                // }   
            }
        }
        
        if(attr && add){
            let dummyAttr = {}; 
            let keys = Object.keys(attr);
            if(keys.indexOf("style") !== -1) {
                dummyAttr.style = attr.style;
            }
            if(keys.indexOf("type") !== -1 && (node.tagName === "BUTTON" || node.tagName === "INPUT")) {
                dummyAttr.type = attr.type;
            }
            if(node.tagName === "INPUT" && node.getAttribute("type") === "number") {
                dummyAttr.value = attr.value;   
            }
            if(keys.indexOf("placeholder") !== -1 && node.tagName === "TEXTAREA") {
                node.removeAttribute("placeholder");
                dummyAttr.placeholder = attr.placeholder;
            }

            if(Object.keys(dummyAttr).length) {
                deepNodes.push({"type": "attr", position: deepN.slice(), "attr" : dummyAttr});    
            } else {
                deepNodes.push({"type": "attr", position: deepN.slice()});        
            }   
        }
    }

    if(node.hasChildNodes()){
        for(let i=0;i<node.childNodes.length;i++) {
            deepN.push(i);
            let svg;
            if(node.childNodes[i].tagName) {
                let tagName = node.childNodes[i].tagName;
                svg = parentSvg || tagName == "svg" ? true : false;
                let is = node.childNodes[i].getAttribute("is");
                if(tagName && is) {
                    await this.newGetDeepNodes(componentName, node.childNodes[i], deepNodes, deepN, is ,strict,errors,warnings,svg);
                }
                else {
                    await this.newGetDeepNodes(componentName, node.childNodes[i], deepNodes, deepN,undefined,strict,errors,warnings,svg);
                }
            } 
            else {
                await this.newGetDeepNodes(componentName, node.childNodes[i], deepNodes, deepN,undefined,strict,errors,warnings,parentSvg);
            }
            svg = false;
        }
    } 
    
    if(toBePushed) {
        deepNodes.push(toBePushed);
    }
    deepN.pop();
}

function getArrayIndex(array,value) {
    for(let i=0;i<array.length;i++) {
        if(array[i] === value) {
            return i
        };
    }
}

function getTrimmedContent(content, position, node) {
    let dummyContent = content;
    if(node) {
        position = [];
        let parentNode = node.parentNode;
        while(true) {
            position.unshift(this.getArrayIndex(parentNode.childNodes,node));
            parentNode = parentNode.parentNode;
            node = node.parentNode;
            if(!parentNode) {
                break;
            }
        }
    }
    for(let i=0;i<position.length;i++) {
        for(let j=content.childNodes.length-1;j>position[i];j--) {
            content.childNodes[j].remove();
        }
        content = content.childNodes[position[i]];
    }
    return dummyContent;
}

function createDocFragment(template){
    var childNodes = template.cloneNode(true).childNodes;
    var frag = document.createDocumentFragment();
    var len = childNodes.length;
    for(var i=0; i<len; i++){
        frag.appendChild(childNodes[0]);
    }
    return frag;
}

async function splitMixedText(str,componentName){
    console.log("str",str);
    var stack=[], start=0, helper = { name:"concat", args: []};
    for(var i=0;i<str.length;i++){
      var j = i;
      if(str[i-1] !== "\\" && str[i] === "{" && str[++i] === "{"){
        stack.push('{{');
        helper.args.push("'"+str.substr(start,j-start)+"'");
        start = i + 1;
      }
      else if(str[i] === "}" && str[++i] === "}" && stack.length){
        stack.pop(start);
        var toPush = str.substr(start,j-start);
        var actObj = await this.getHelper(toPush,componentName);  
        if(actObj){
            toPush = actObj;
        helper.args.push({type:"helper",value:toPush});
        }
        else{
            helper.args.push(toPush);
        }
        start = i + 1;
     }

    }
    if(start<str.length){
        helper.args.push("'"+str.substr(start,str.length-start)+"'");
    }
    console.log("str is helper",helper);

    return helper;
}

function syntaxCheck(value){
    var stack = [],lastAdded;
    for(var i=0;i<value.length;i++){
        if(value[i] === "'"){
            if(lastAdded === "'" && value[i-1] !== "\\"){
                stack.pop();
                lastAdded = undefined;
            }
            else if(!stack.length){
                lastAdded = value[i];
                stack.push(lastAdded);
            }
        }
        else if(value[i] === "\""){
            if(lastAdded === "\"" && value[i-1] !== "\\"){
                stack.pop();
                lastAdded = undefined;
            }
            else if(!stack.length){
                lastAdded = value[i];
                stack.push(lastAdded);
            }
        }
    }
    if(stack.length){
        return false;
    }
    return true;
}

/* function getMustache(value){
    value=(value && typeof value === "string") ? value.trim() : value;
    if(/^{{(?=[\s]*[\w-_]+)/.test(value)){
        let arr = value.match(/{{[a-zA-Z0-9_.\[\]\(\)]*(?![\\])}}/g);
        if(arr && arr.length > 1){
            console.log("length>1",value)
            return undefined;
        }
        console.log(value);
        if(!this.syntaxCheck(value)){
            return false;
        }
        if(!(/{{[^}]*?(?:(?:('|")[^\1]*?\1)[^}]*?)*}}$/.test(value))){
            return undefined;
        }
        let dynamic = value.match(/[\w!@#\$%\^\&*\)\(+=.,_-]+[\s]*[(]{0,1}(?:"([^"]|\\")*?"|'([^']|\\')*?'|[\w\s!@#\$%\^\&*\)\(\[\]+=.,_-]*?)*?[)]{0,1}[\s]*(?=}})/g);
        if(dynamic && dynamic.length > 1){
            return undefined;
        }
        else{
            dynamic = (dynamic) ? dynamic[0].trim(): dynamic;                
        }
//            let dynamic = /[\w!@#\$%\^\&*\)\(+=.,_-]+(?:"([^"]|\\")*?"|'([^']|\\')*?'|[\w\s!@#\$%\^\&*\)\(\[\]+=.,_-]*?)*?(?=}}$)/.exec(value);
        return dynamic;
    }
    return undefined;
} 

function getHelperArgs(str){
    let stack = [], args = [] , from=0;
    let lastPushed; 
    for(let i=0; i<str.length; i++){
        if(!stack.length && str.charAt(i) === ","){
            let toPush = str.substr(from,i-from);
            toPush = toPush.trim();
            if(toPush && toPush.startsWith("\"") && toPush.endsWith("\"")){
                toPush = toPush.slice(1,-1);
                toPush = "'" + toPush + "'";
            }
            toPush = getHelperArgValue(toPush);
            args.push(toPush);
            from = i + 1;
        }
        else if(str.charAt(i) === "("){
            if(lastPushed != "'" || lastPushed != "\""){
                stack.push(str.charAt(i));
                lastPushed = str.charAt(i);
            }
        }
        else if(str.charAt(i) === ")"){
            if(stack[stack.length-1] === "("){
                stack.pop();
            }
        }
        else if(str.charAt(i) === "'" && str.charAt(i-1) !== "\\"){
            if(stack[stack.length-1] === "'"){
                stack.pop();
            }
            else if(stack[stack.length-1] !== "\""){
                stack.push(str.charAt(i));
                lastPushed = str.charAt(i);
            }
        }
        else if(str.charAt(i) === "\"" && str.charAt(i-1) !== "\\"){
            if(stack[stack.length-1] === "\""){
                stack.pop();
//                  str.replaceAt(i, "'");
            }
            else if(stack[stack.length-1] !== "'"){
                stack.push(str.charAt(i));
                lastPushed = str.charAt(i);
//                  str.replaceAt(i, "'");
            }
        }
    }
    if(stack.length){
        return false;
    }
    let toPush = str.substr(from,str.length-from);
    toPush = toPush.trim();
    if(toPush && toPush.startsWith("\"") && toPush.endsWith("\"")){
        toPush = toPush.slice(1,-1);
        toPush = "'" + toPush + "'";
    }
    try{
        toPush = getHelperArgValue(toPush);
    }
    catch(err){
        console.log("errr",err);
        return false;
    }
    args.push(toPush);
    return args;
}



function getHelperInfo(dynamicValue, helperValue){
    let helperFunc = {};
    helperFunc.name = dynamicValue.substr(0,helperValue.index).replace(/\s/g,'');
    helperValue = (helperValue) ? helperValue[0].trim() : helperValue;
    let args = getHelperArgs(helperValue.substr(1,helperValue.length-2));
    if(args === false){
        return false;
    }
    helperFunc.args = args;
    return helperFunc;
}

function getHelper(dynamicValue){
    console.log(dynamicValue);
    let helperValue = /\((?:[^\)]*|(?:(?:"(?:[^"\\]|\\.)*?")|(?:'([^'\\]|\\.)*?')|[\w\s!@#$%^&*)([\]+=.,_-]*?)*?)\)$/.exec(dynamicValue);
    if(helperValue){
        return getHelperInfo(dynamicValue,helperValue);
    }
    return undefined;
} */

async function getMustache(value,componentName){
    
    var newPromise = new Promise(function(resolve,reject) {
        var timeoutId = setTimeout(function() {
            str += '\n getMustache error : '+value;
            localStorage.setItem(componentName,str);
            console.log("getMustache error", value);
            templateWorker.terminate();
            resolve(false);
            templateWorker = new Worker("worker.js");
        },4000);
        templateWorker.postMessage({"func" : "getMustache", "params" : [value], debug : debug});
        templateWorker.onmessage = function(value) {
            resolve(value.data);
            clearTimeout(timeoutId);
        }
    });
    return newPromise;
}

async function getHelper(dynamicValue,componentName) {
    var newPromise = new Promise(function(resolve,reject) {
        var timeoutId = setTimeout(function() {
            str += '\n getHelper error : '+dynamicValue
            localStorage.setItem(componentName,str);
            console.log("getHelper error" , dynamicValue);
            templateWorker.terminate();
            resolve(false);
            templateWorker = new Worker("worker.js");
        },4000);
        templateWorker.postMessage({"func" : "getHelper", "params" : [dynamicValue], debug : debug});
        templateWorker.onmessage = function(value) {
            resolve(value.data);
            clearTimeout(timeoutId);
        }
    });

    return newPromise;
}

function getDynamicValue(value){    
    var result = [],ref = result,arr = [],data = "",strStack = [],arrayStack = [],refStack = [],strLast,str;
    console.log("dynamic start",value);
    for(var i=0;i<value.length;i++){
        if(value[i] === "."){
            if(data.length){
                ref.push(data);
            }
            data = "";
            continue;
        }
        else if(value[i] === "["){
            arrayStack.push(i)
            if(data.length){
                ref.push(data);
            }
            while(value[i+1] === "\s"){
                i++;
            }
            if(value[i+1] === "\"" || value[i+1] === "'"){
                strStack.push(value[i+1]);
                strLast = value[i+1];
                i++;
            }
            else if(arr.length){
                ref.push([]);
                refStack.push(ref);
                ref = ref[ref.length-1];
            }else{
                arr.push([]);
                refStack.push(ref);
                ref = arr[arr.length-1];
            }
            data = "";
            continue;
        }
        else if((value[i] === "\"" || value[i] === "'" ) && value[i++] === strLast){
            while(value[i] === "\s" && value[i] != "]"){
                i++;
            }
            strStack.pop();
            str = true;
        }
        if(value[i] === "]"){
            arrayStack.pop();
            if(data.length){
                if(str === true){
                    ref.push(data);    
                }
                else if(!isNaN(parseInt(data))){
                    if(refStack.length){
                        ref = refStack.pop();
                        if(arr.length && Array.isArray(ref[ref.length-1]) && !ref[ref.length-1].length){
                            ref.pop();
                        }
                        ref.push(data);
                        if(!arrayStack.length && arr.length){
                            arr.shift();
                        }
                    }
                }
                else{
                    ref.push(data);
                }
            }
            if(!arrayStack.length && arr.length){
                result.push(arr.shift());
                ref = result;
            }
            else if(refStack.length && !arr.length){ 
                ref = refStack.pop();
            }
            data = "";
            str = "";
            continue;
        }
        data = data.concat(value[i]);
    }
    if(data.length){
        result.push(data);
    }
    if(strStack.length || arrayStack.length){
        console.log("check the syntax",strStack,arrayStack);
    }
    console.log(result,"dynamic end");
    return result;
}
function deepCopyObject( obj )  {
    var current, copies = [{source : obj, target : Object.create(Object.getPrototypeOf(obj))}], keys, propertyIndex, descriptor, nextSource, indexOf, sourceReferences = [obj];
    var cloneObject = copies[0].target, targetReferences = [cloneObject];
    while(current = copies.shift()){
        keys = Object.getOwnPropertyNames(current.source);
        for(propertyIndex = 0; propertyIndex < keys.length; propertyIndex++){
            descriptor = Object.getOwnPropertyDescriptor(current.source, keys[propertyIndex]);
            if(!descriptor.value || typeof descriptor.value != "object"){
                Object.defineProperty(current.target, keys[propertyIndex], descriptor);
                continue;
            }
              nextSource = descriptor.value;
              descriptor.value = Array.isArray(nextSource) ? [] : Object.create(Object.getPrototypeOf(nextSource));
              indexOf = sourceReferences.indexOf(nextSource);
              if(indexOf != -1){
                  descriptor.value = targetReferences[indexOf];
                  Object.defineProperty(current.target, keys[propertyIndex], descriptor);
                  continue;
              }
              sourceReferences.push(nextSource);
              targetReferences.push(descriptor.value);
              Object.defineProperty(current.target, keys[propertyIndex], descriptor);
              copies.push({source : nextSource, target : descriptor.value});
          }
      }
    return cloneObject;
}

function replaceCaseNode(node,componentName,errors,templateNode,rtObj,svg) {
    var tagName;
    var template;
    var svgParentNode = svg;//getSvgParent(templateNode);
    if(svgParentNode){
        rtObj.svg = true;
        var template = node.cloneNode();
        template.innerHTML = "<svg>" + node.innerHTML + "</svg>";
        template.setAttribute("depth", 1);
        node.replaceWith(template);
        return;
    }
    for(var i=0;i<node.content.children.length;i++) {
        if(node.content.children[i].tagName !== "TEMPLATE") {
            if(/^(TR|TD|TH|TBODY|THEAD|TFOOT)$/.test(node.content.children[i].tagName)) {
                tagName = node.content.children[i].tagName;
            }
            break;
        }
    }
    if(tagName) {
        if(tagName === "TR") {
            template = node.cloneNode();
            template.innerHTML = "<table><tbody>" + node.innerHTML + "</tbody></table>";
            template.setAttribute("depth", 2);

        }
        else if(/^(TBODY|THEAD|TFOOT)$/.test(tagName)){
            template = node.cloneNode()
            template.innerHTML = "<table>" + node.innerHTML + "</table>";
            template.setAttribute("depth", 1);
        } 
        else {
            template = node.cloneNode();
            template.innerHTML = "<table><tbody><tr>" + node.innerHTML + "</tr></tbody></table>";
            template.setAttribute("depth", 3);
        }
        if(template.content.childNodes.length > 1){
            template.content.childNodes.forEach(function(item){
                if(item.nodeName != "TABLE"){
                    if(item.nodeType == 1){
                        errors.push(new Error("Syntax Error : Unexpected node - "+item.nodeName+ "tag"+ "inside "+ tagName +" tag in the component "+componentName))
                    }else{
                        errors.push(new Error("Syntax Error : Unexpected text node - "+item.nodeValue+ "present inside "+ tagName +" tag in the component "+componentName))
                    }
                }
            })
        }
        node.replaceWith(template);
    }
}
function getParent(node){
    var newNode = node;
    while(newNode){
        if(newNode._parent){
            if(newNode._parent.tagName && newNode._parent.tagName!="TEMPLATE"){
                return newNode._parent;
            }
        }
        newNode = newNode._parent;
    }
}
// function getSvgParent(node){
//     var newNode = node;
//     while(newNode){
//         if(newNode._parent){
//             if(newNode._parent.tagName && newNode._parent.tagName=="svg"){
//                 return newNode._parent;
//             }
//         }
//         newNode = newNode._parent;
//     }
// }
function svgFix(node,svgParentNode,type, toBePushed,parentElementName,componentName,errors){
    var templateNode = node.cloneNode();
    var newElementName;
    if(!node.content || !node.content.children || !node.content.children[0] || !node.content.children[0].tagName){
        errors.push(new Error("Syntax Error in the node : Unexpected node - "+ this.errorNodeDetails(node) +" in the component "+componentName));
        return node;
    }else{
        newElementName = node.content.children[0].tagName;
    }
    templateNode.innerHTML = "<svg>" + node.innerHTML + "</svg>"
    templateNode.setAttribute("depth", 1);
    return inner(node,templateNode,type,newElementName,parentElementName,toBePushed);
}
function replaceParentNode(node, type, toBePushed,componentName,errors,forHold,svg) {
    var parentNode = getParent(node);
    var svgParentNode = svg; //getSvgParent(node);
    if(svgParentNode && parentNode){
        var parentElementName = parentNode.tagName;
        toBePushed.svg = true;
        return svgFix(node,svgParentNode,type, toBePushed,parentElementName,componentName,errors);
    }
    if(!parentNode) {
        return node;
    }
    var parentElementName = parentNode.tagName;
    var newElementName;
    var templateNode = node.cloneNode();
    var childTagName;
    if(forHold){
        for(var i=0;i<node.content.children.length;i++) {
            if(node.content.children[i].tagName !== "TEMPLATE") {
                if(/^(TR|TD|TH|TBODY|THEAD|TFOOT)$/.test(node.content.children[i].tagName)) {
                    childTagName = node.content.children[i].tagName;
                }
                break;
            }
        }
    }
    if(parentNode && /^(SELECT|TR|TABLE|TBODY|THEAD|TFOOT)$/.test(parentElementName)) {
        switch(parentElementName) {
            case "SELECT" : 
                newElementName = "option";
            break;
            case "TR" : 
                if(!forHold){ 
                    templateNode.innerHTML = "<table><tbody><tr>" + node.innerHTML + "</tr></tbody></table>"
                    templateNode.setAttribute("depth", 3);
                    newElementName = "td";
                }else{
                    if(childTagName && childTagName == "TR"){
                        errors.push(new Error("Syntax Error : Unexpected node - "+childTagName+ "tag inside "+ parentElementName +" tag in the component "+componentName))
                    }else{
                        templateNode.innerHTML = "<table><tbody><tr>" + node.innerHTML + "</tr></tbody></table>"
                        templateNode.setAttribute("depth", 3);
                        newElementName = "td";
                    }
                }
            break;
            case "TABLE" :
                if(!forHold){
                    templateNode.innerHTML = "<table>" + node.innerHTML + "</table>";
                    templateNode.setAttribute("depth", 1);
                    newElementName = "tbody";
                }else{
                    if(childTagName && (childTagName == "TBODY" || childTagName =="THEAD" || childTagName =="TFOOT")){
                        templateNode.innerHTML = "<table>" + node.innerHTML + "</table>";
                        templateNode.setAttribute("depth", 1);
                    }
                    else if(childTagName && childTagName == "TR"){
                        templateNode.innerHTML = "<table><tbody>" + node.innerHTML + "</tbody></table>";
                        templateNode.setAttribute("depth", 2);
                    }
                    else{
                        templateNode.innerHTML = "<table><tbody><tr>" + node.innerHTML + "</tr></tbody></table>"
                        templateNode.setAttribute("depth", 3);
                    }
                    newElementName = "tbody";
                }
            break;
            case "TBODY" : 
            case "THEAD" : 
            case "TFOOT" : 
                if(!forHold){
                    templateNode.innerHTML = "<table><tbody>" + node.innerHTML + "</tbody></table>";
                    templateNode.setAttribute("depth",2);
                    newElementName = "tr";
                }else{
                    if(childTagName && (childTagName == "TR")){
                        templateNode.innerHTML = "<table><tbody>" + node.innerHTML + "</tbody></table>";
                        templateNode.setAttribute("depth",2);
                    }else{
                        templateNode.innerHTML = "<table><tbody><tr>" + node.innerHTML + "</tr></tbody></table>"
                        templateNode.setAttribute("depth", 3);
                    }
                    newElementName = "tr";
                }
            break;
        }
        if(templateNode.content.childNodes.length > 1){
            templateNode.content.childNodes.forEach(function(item){
                if(item.nodeName != "TABLE"){
                    if(item.nodeType == 1){
                        errors.push(new Error("Syntax Error : Unexpected node - "+item.nodeName+ "tag inside "+ parentElementName +" tag in the component "+componentName))
                    }else{
                        errors.push(new Error("Syntax Error : Unexpected text node - "+item.nodeValue+ "present inside "+ parentElementName +" tag in the component "+componentName))
                    }
                }
            })
        }
        return inner(node,templateNode,type,newElementName,parentElementName,toBePushed);
    }
    return node;
}
function inner(node,templateNode,type,newElementName,parentElementName,toBePushed){
    var newElement = document.createElement(newElementName);
    var parentElement = document.createElement(parentElementName);
    switch(type) {
        case "for" : 
            newElement.setAttribute("is", "for");
            newElement.setAttribute("lyte-for", "true");
            if(node.hasAttribute("unbound")) {
                newElement.setAttribute("unbound", node.getAttribute("unbound"));
            }
            // newElement.setAttribute("items", node.getAttribute("items"));
            // newElement.setAttribute("item", node.getAttribute("item"));
            // newElement.setAttribute("index", node.getAttribute("index"));
        break;
        case "if" :
        case "switch" :  
            newElement.setAttribute("is", type);
            newElement.setAttribute("lyte-"+type, "true");
            //newElement.setAttribute("value", node.getAttribute("value"));
        break;
        case "forIn" : 
            newElement.setAttribute("is", "forIn");
            newElement.setAttribute("lyte-forin", "true");
            if(node.hasAttribute("unbound")) {
                newElement.setAttribute("unbound", node.getAttribute("unbound"));
            }
            // newElement.setAttribute("object", node.getAttribute("object"));
            // newElement.setAttribute("key", node.getAttribute("key"));
            // newElement.setAttribute("value", node.getAttribute("value"));
        break;
    }
    var attrs = node.attributes;
    for(var i=0;i<attrs.length;i++) {
        newElement.setAttribute(attrs[i].nodeName, attrs[i].nodeValue);
    }
     if(parentElementName !== "SELECT" && (type === "for" || type === "forIn")) {
        toBePushed.actualTemplate = templateNode.outerHTML;  
        toBePushed.tagName = parentElementName;  
        if(templateNode.hasAttribute("depth")) {
            newElement.setAttribute("depth" , templateNode.getAttribute("depth"));
        }
    } else {
        toBePushed.actualTemplate = node.outerHTML;
    }
    node.replaceWith(newElement);
    return newElement;
}
function siblingNullCheck(nextSibling){
    if(nextSibling.previousSibling.nodeValue === null || nextSibling.nextSibling.nodeValue === null){
        return null;
    }
    else{
        return 1;
    }
}
function handleLyteIf(element,svg) {
    var ifStmt;
    if(element.hasAttribute("lyte-if")) {
        ifStmt = element.getAttribute("lyte-if");
        element.removeAttribute("lyte-if");
    } else if(element.hasAttribute("lyte-else-if")) {
        ifStmt = element.getAttribute("lyte-else-if");
        element.removeAttribute("lyte-else-if");
    }
    var temp = document.createElement("template");
    temp.setAttribute("is", "if");
    temp.setAttribute("value", ifStmt);
    if(ide && window.elifHold){
        temp.setAttribute("el", true);
        window.elifHold =false;
    }
    //True case done
    var trueTemp;
    if(svg && element.tagName=="template"){
        trueTemp = document.createElement("template");
        trueTemp.innerHTML = element.innerHTML
    }else if(element.tagName === "TEMPLATE") {
        trueTemp = element.cloneNode();
        trueTemp.innerHTML = element.innerHTML;
    } else {
        trueTemp = document.createElement("template");
        trueTemp.innerHTML = element.outerHTML;
    }
    temp.content.appendChild(trueTemp);
    trueTemp.setAttribute("case", "true");

    //Else case handling
    if(element.nextElementSibling) {
        var nextSibling = element.nextElementSibling;
        var falseTemp;
        var type;
        if(nextSibling.hasAttribute("lyte-else")) {
            type = "lyte-else";
        } else if(nextSibling.hasAttribute("lyte-else-if")) {
            type = "lyte-else-if";
        }
        if(type) {
            //falseTemp = document.createElement("template"); 
            //falseTemp.setAttribute("case", "false");
            if(type === "lyte-else") {
                nextSibling.removeAttribute("lyte-else");
                if(svg && nextSibling.tagName=="template"){
                    falseTemp = document.createElement("template");
                    falseTemp.setAttribute("case", "false");
                    falseTemp.innerHTML = nextSibling.innerHTML
                } else if(nextSibling.tagName === "TEMPLATE") {
                    falseTemp = nextSibling.cloneNode();
                    falseTemp.innerHTML = nextSibling.innerHTML;
                } else {
                    falseTemp = document.createElement("template");
                    falseTemp.setAttribute("case", "false");
                    falseTemp.innerHTML = nextSibling.outerHTML;
                }
                falseTemp.setAttribute("case", "false");
                if(nextSibling.nextSibling && nextSibling.previousSibling &&siblingNullCheck(nextSibling) && (nextSibling.nextSibling.nodeValue.trim() === "") && ("" === nextSibling.previousSibling.nodeValue.trim())) {
                    nextSibling.nextSibling.remove();
                }
                nextSibling.remove();
            } else {
                falseTemp = document.createElement("template");
                falseTemp.setAttribute("case", "false");
                falseTemp.innerHTML = handleLyteIf(nextSibling,svg).outerHTML;
                if(nextSibling.nextSibling  && nextSibling.previousSibling && siblingNullCheck(nextSibling)  && (nextSibling.nextSibling.nodeValue.trim() === "") && ("" === nextSibling.previousSibling.nodeValue.trim())) {
                    nextSibling.nextSibling.remove();
                }
                nextSibling.remove();

            }
            temp.content.appendChild(falseTemp);
        }
    }
    return temp;
}

function handleLyteSwitch(node,svg) {
    var template;
    var switchValue = node.getAttribute("lyte-switch");
    var childElements;
    var type;
    if(node.tagName === "TEMPLATE") {
        template = node;
        template.removeAttribute("lyte-switch");
        childElements = Array.from(template.content.children);
        type = "template";
    } 
    else if(svg && node.tagName=="template"){
        template = document.createElement("template");
        var attrs = node.attributes;
        for(var j=0;j<attrs.length;j++) {
            template.setAttribute(attrs[j].nodeName, attrs[j].nodeValue);
        }
        // falseTemp.setAttribute("case", "false");
        template.removeAttribute("lyte-switch");
        // template.innerHTML = node.innerHTML
        type = "template";
        childElements = Array.from(node.children);
    } 
    else {
        node.removeAttribute("lyte-switch");
        template = document.createElement("template");
        if(ide){
            template.setAttribute("nt",true);
        }
        childElements = Array.from(node.children);
    }
    var cases = {};
    
    for(var i=0;i<childElements.length;i++) {
        var child = childElements[i];
        if(child.hasAttribute("lyte-case")) {
            var isChildTemplate = child.tagName === "TEMPLATE";
            if(svg && child.tagName === "template"){
                var temp = document.createElement("template");
                temp.innerHTML = child.innerHTML;
                var attrs = child.attributes;
                for(var j=0;j<attrs.length;j++) {
                    temp.setAttribute(attrs[j].nodeName, attrs[j].nodeValue);
                }
                child = temp;
                isChildTemplate = true;
            }
            //var childTemplate = isChildTemplate ? child : document.createElement("template");
            var childTemplate = child;
            var hasBreak = child.hasAttribute("lyte-break");
            var caseValue = child.getAttribute("lyte-case");

            child.removeAttribute("lyte-case");
            child.removeAttribute("lyte-break");
            if(child.hasAttribute("lyte-if")) {
                isChildTemplate = false;
                var oldChild = child;
                child = handleLyteIf(child,svg);
                oldChild.remove();
            } else if(child.hasAttribute("lyte-switch")) {
                isChildTemplate = false;
                handleLyteSwitch(child,svg);
            }
            if(isChildTemplate) {
                template.content.appendChild(child);
                child.setAttribute("case", caseValue);
                child.removeAttribute("lyte-case");
            } else {
                childTemplate = document.createElement("template");
                childTemplate.setAttribute("case", caseValue);
                child.removeAttribute("lyte-case");
                childTemplate.content.appendChild(child);
                template.content.appendChild(childTemplate);
                
            }
            if(hasBreak) {
                var breakTemp = document.createElement("template");
                breakTemp.setAttribute("is", "break");
                childTemplate.content.appendChild(breakTemp);
                child.removeAttribute("lyte-break");
            }
        } 
    }
    var defaultCase;// = type ? node.content.querySelector("[lyte-default]") : node.querySelector("[lyte-default]");
    if(svg && node.tagName == "template"){
        defaultCase = type ? node.querySelector("[lyte-default]") : node.querySelector("[lyte-default]");
    }else{
        defaultCase = type ? node.content.querySelector("[lyte-default]") : node.querySelector("[lyte-default]");
    }
    if(defaultCase) {
        var isDefCaseTemp;
        if(defaultCase.tagName === "TEMPLATE"){
            isDefCaseTemp = true;
        }
        else if(svg && defaultCase.tagName === "template"){
            var temp = document.createElement("template");
            temp.innerHTML = defaultCase.innerHTML;
            var attrs = defaultCase.attributes;
            for(var j=0;j<attrs.length;j++) {
                temp.setAttribute(attrs[j].nodeName, attrs[j].nodeValue);
            }
            defaultCase = temp;
            isDefCaseTemp = true;
        }
        defaultCase.removeAttribute("lyte-default");
        if(defaultCase.hasAttribute("lyte-if")) {
            isDefCaseTemp = false;
            var oldDefault = defaultCase;
            defaultCase = handleLyteIf(defaultCase,svg);
            oldDefault.remove();
        } else if(defaultCase.hasAttribute("lyte-switch")) {
            isDefCaseTemp = false;
            handleLyteSwitch(defaultCase,svg);
        }
        if(isDefCaseTemp) {
            template.content.appendChild(defaultCase);
            defaultCase.setAttribute("default" , "");
        } else {
            var defTemp = document.createElement("template");
            defTemp.setAttribute("default" , "");
            defTemp.content.appendChild(defaultCase);
            template.content.appendChild(defTemp);
        }
    }
    template.setAttribute("value", switchValue);
    template.setAttribute("is", "switch");
    if(!type) {
        node.innerHTML = template.outerHTML;
    } else {
        node = template;
    }
    return node;
}