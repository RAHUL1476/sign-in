let validateComponentDataName = function(value) {	
    var reg = /^(([a-z_])([a-z0-9_])*((\d)|([A-Z][a-z0-9_]+))*([A-Z])?)$/g;
    var matched = value.match(reg);
    if(matched && matched[0] == value) {
        return true;
    } else {
        return false;
    }	
};
let returnObservedAttributes = function(expBody) {
    let notProcessed = true;
    let observedAttributes = [];
    var nodeBody = expBody.body.body;
    var len = nodeBody.length;
    let warnings = [];
    for(i = 0;notProcessed && i < len ;i++) {
        if(nodeBody[i].type == "ReturnStatement") {
            var returnArg = nodeBody[i].argument;
            if(returnArg && returnArg.type == "ObjectExpression") {
                var properties = returnArg.properties;
                for(var m = 0;m < properties.length;m++) {
                    var property = properties[m].key;
                    var key = property.value || property.name;
                    var loc = property.loc.start;
                    if(key == "errors") {
                        throw ({type : "error",message: "errors is the reserved key word.In Lyte, it is used to set the errors of the component's data.", lineNumber: loc.line + 1, column: loc.column })
                    } else {
                        if(!(result = validateComponentDataName(key))) {
                            warnings.push(key);
                        }
                        observedAttributes.push(key);
                    }
                }
                notProcessed = false;
            }
        }
    }
    return 	{
        observedAttributes : observedAttributes,
        warnings : warnings
    }
};
let catchFn = function (str, t) {
    try {
        response[t] = response[t] || {};
        let node = Espree.parse(str,{ecmaVersion : 9 ,sourceType : 'module',loc: true});
        let body = node.body[0].expression.callee.body.body;
        let length = body.length;
        let expression;
        let expComponent;
        let args;
        let flag = true;
        let result,observedAttributes =[],errorInCompDataNames;
        for(let m = 0; flag && m < length;m++) {
            if((expression = body[m].expression) && expression.callee && (expComponent = expression.callee.object) &&(expComponent.name == "LyteComponent" || expComponent.object && "Lyte" == expComponent.object.name && "Component" == expComponent.property.name)){
                args = expression.arguments;
                let l = args.length;
                for(n = 0;flag && n < l;n++) {
                    if(args[n].type == "ObjectExpression") {
                        for(properties = args[n].properties, o = 0; flag && o < properties.length  ; o++) {
                            var property = properties[o];
                            var key = property.key.name;
                            if(key  == "data") {
                                flag = false;
                                let valueType = property.value.type;	
                                if(valueType == "FunctionExpression") {	
                                    result = returnObservedAttributes(property.value);	
                                    observedAttributes = result.observedAttributes;	
                                    response[t]._observedAttributes = observedAttributes || [];	
                                    errorInCompDataNames = result.warnings;	
                                    if(errorInCompDataNames.length) {	
                                        response[t].jsWarnings = errorInCompDataNames.toString();	
                                    }	
                                }
                            }
                        }
                    }
                }
            }
        }
    } catch (e) {
        response[t].jsError = { message: e.message, stack: e.stack, line: e.lineNumber - 2, column: e.column };
    }
},
emptyFn = function () {};
(Function.prototype.on = emptyFn),
(Function.prototype.observes = function () {
    return { type: "observer", value: this, properties: arguments, on: Function.prototype.on };
}),
(Function.prototype.computed = emptyFn);

let Lyte = {
    registeredComponents: {},
    types: ["string", "object", "number", "boolean", "array"],
    componentCopyRule: function (node) {   
        try {     
            let expBody = node.body[0].expression;
            if(expBody.type =="FunctionExpression") {
                return returnObservedAttributes(expBody);
            }
            return {};
        } catch(e) {
            throw e;
        }
    },
    attr: function (e, t) {},
    Component: {
        register: function () {
            var e = [],
                t,
                r = arguments[0],
                warnings = [];
            response[r] = response[r] || {};
            try {
                var result;
                t = arguments[1].data;
                var arr;
                if(t && (arr = t())) {
                    var key;
                    for(key in arr) {
                        if(key == "errors") {
                            throw "errors";
                        } else {
                            e.push(key);
                            if(!(result = validateComponentDataName(key))){
                                warnings.push(key); 	
                            }
                        }
                    }
                }
                if(warnings.length) {
                    response[r].jsWarnings = warnings.toString();
                }
                response[r]._observedAttributes = e;
            } catch (t) {
                var o = "(" + arguments[1].data.toString() + ")";
                try {
                    e = Lyte.componentCopyRule(Espree.parse(o,{ecmaVersion : 9,loc : true}));
                    response[r]._observedAttributes = e.observedAttributes;
                    warnings = e.warnings;
                    if(warnings.length) {
                        response[r].jsWarnings = warnings.toString();
                    }
                } catch(e) {
                    response[r].jsError = { message: e.message, stack: e.stack, line: e.lineNumber, column: e.column }						
                }
            }
        },
    },
};