require = global.require;
const CLIEngine = require("eslint").CLIEngine,
    semver = require("semver"),
    utils = require("@zoho/lyte-cli-utils"),
    fileManipulation = utils.fileManipulation,
    less = require('less'),
    errorClass = utils.errorClass,
    commonCliUtils = utils.commonCliUtils,
    templateProcessor = require("../../lib/utilities/templateProcessor"),
    path = require("path"),
    glob = require("glob");
let multispinnerObj,
    startSpinnerObj,
    failureSpinnerObj,
    successSpinnerObj,
    buildFileWatchFn,
    defaultModules = ["routes","components","models","helpers","mixins","copyAppDir","services"],
    writeSync,
    remove,
    removeSync,
    transpileOpt,
    readSync,
    getFilesList,
    read,
    lstat,
    access,
    fileExist,
    options = {},
    prevChangedFile={},
    userLog,
    systemLog,
    production,
    srcFolders,
    relativeSrcFolders = {},
    relativeDistFolders = {},
    fingerPrintOpt,
    extraFolderForFingerPrint,
    distFolders,
    consolidateFilesObj = {},
    os = process.platform,
    lyteFileList = [
        "lyte-c.js",
        "lyte-c.min.js",
        "lyte-c-es5.js",
        "lyte-d.js",
        "lyte-d.min.js",
        "lyte.js", 
        "lyte.min.js", 
        "lyte-es5.js", 
        "lyte-es5.min.js",
        "lyte-r.js","lyte-r.min.js","lyte-r-es5.js","lyte-r-es5.min.js",
        "lyte-rc.js","lyte-rc.min.js","lyte-rc-es5.js","lyte-rc-es5.min.js",
        "lyte-cs.js","lyte-cs.min.js","lyte-cs-es5.js","lyte-cs-es5.min.js",
    ],       
    returnErrorObject = function(err) {
        err.userLog = userLog;
        err.systemLog = systemLog;                     
        err._zl_timestamp  = new Date().getTime(); 
        return err;
    },
    lytePackageBeforeCompilation = function() {
        var file = this.file;
        var content = this.data;
        var fileName = path.parse(file).name+'.js';
                                        
        if(lyteFileList.includes(fileName)) {
            content = content + " \n Lyte.developmentVariables =  { production :"+options.production+"}";
        }
        return content;
        
    },
    checkForAlreadyExistAndPushValueInObj = function(obj,key,newPairs) {                                                
        if(!obj.keys.includes(key)) {
            obj.keys.push(key);
            for(let map in newPairs){
                obj[map].push(newPairs[map]);
            }
        }
    },
    lsCmd = function(file,callback) {  
        glob(file,function(err,files){
            if(err){
                callback(err);
            } else {
                if(files.length) {
                    if(os == "win32") {
                        files = files.map(function(val){
                            return path.join(val);
                        });
                    } 
                    callback(null,files);
                } else {
                    callback(new Error("Warning : File not found "+file+"\n")); 
                } 
            }
        });                                                      
    },
    removeTheFiles = function(file){
        removeSync(file,true);
        delete options.fileContent[file];
        systemLog({msg :"[Removed] => "+path.relative(srcFolders.copyAppDir,file),type:"INFO",_zl_timestamp: new Date().getTime()});
        if(fileExist(file+'.map')) {
            removeSync(file+'.map',true);
            delete options.fileContent[file+'.map'];
        } 
    },
    _cliCopyFile = function(options,obj,callback) {            
        let  distFile = obj.dist,
            srcFile = obj.src;
        let args = {
            src : srcFile,
            dist : distFile,
            minify : obj.minify,
            beforeCompilation : obj.beforeCompilation,
            afterCompilation : obj.afterCompilation
        };
        let  fnToCall = obj.transpile ? "transpileFn" : "copy";
        fileManipulation[fnToCall](options,args,callback);                                                                    
    },
    
    _cliCopyFolder = function(options,obj,callback) {                        
        let copiedFileCount = 0,
            allFilesIterated  = false,
            totalFiles,
            srcFolder = obj.src,
            distFolder = obj.dist,
            args = {
                minify : obj.minify,
                transpile : obj.transpile,
                beforeCompilation : obj.beforeCompilation
            },
            cb = function(err) {
                if(err) {
                    callback(err);
                } else {
                    copiedFileCount++;
                    if(allFilesIterated && copiedFileCount == totalFiles) {
                        callback();
                    }
                }
            };
        if(fingerPrintOpt) {
            if(extraFolderForFingerPrint.includes(distFolder)) {
                args.afterCompilation = function() {
                    var data = this.data;
                    var file = this.file;
                    file = fileManipulation.generateFingerPrint(options,file,data);
                    return {
                        file : file,
                        data : data
                    }
                }
            }
        }
        access(srcFolder,function(err) {
            if(err) {
                callback(err);
            } else {
                getFilesList(srcFolder,null,function(err,items){                  
                    if(err) {
                        callback(err);
                    } else {
                        totalFiles = items.length;
                        allFilesIterated  = true;
                        if(copiedFileCount == totalFiles){                      
                            callback();
                        }
                    }
                },function(item,isSymbolicLink) {                    
                    args.src = item;
                    args.dist = item.replace(srcFolder,distFolder); 
                    if(isSymbolicLink) {
                        fileManipulation.copyWithSymbolicLink(args,cb);
                    } else {
                        _cliCopyFile(options,args,cb);
                    }
                });
            }
        });      
    }, 
    _cliCompileThemes = function(options,obj,callback) {
        options.themeFlag = true;
        let dist = obj.dist; 
        let src = obj.src;          
        let lessPath = obj.lessPath || options.lessPath; 
        let sourceMap = obj.sourceMap || options.sourceMap;
        let themeOptions = obj.themeOptions || options.themeOptions || {};
        let cssImports = [];   
        let len = src.length;
        let contentRead = 0;                    
        let finalLessContent = '';
        if(!options.themesToBeCompiled) {
            dist = path.isAbsolute(dist) ?  dist : path.join(distFolders.themes,dist);
        }  
        let distFileObj = path.parse(dist);
        let createLessCompilationContent = function(file) {
            let content;
            let  relativePath = path.relative(process.cwd(),file);
            if(fileManipulation.getTheFileExt(file) == '.less') {
                content = '@import "'+relativePath+'";\n';
            }  else {
                cssImports.push(relativePath);
                content = '@import (inline) "'+relativePath+'";\n';
            }       
            return content;
        };
        if(sourceMap) {
            themeOptions.sourceMap = {
                outputFilename : path.relative(options._appOutputFolder,dist),
                sourceMapBasepath : options._appOutputFolder,
                outputSourceFiles: true,
                sourceMapURL : distFileObj.name+distFileObj.ext+".map"
            };
        }
        if(!options.themesToBeCompiled || options.themesToBeCompiled.includes(dist)){ 
            let cbToCallForLessUtil = function() {
                contentRead++;
                if(contentRead == len) {
                    if(finalLessContent.length) { 
                        fileManipulation.mkdir(distFileObj.dir,function(err) {
                            if(err) {
                                callback(err);
                                return;
                            }
                            lessCompilationUtil(options,finalLessContent,dist,themeOptions,function(err,imports) {                         
                                if(err) {
                                    systemLog({msg :"\nCompilation of themes has some issues and failed to create output file in the path"+dist,type:"INFO",_zl_timestamp: new Date().getTime()});                                                                                
                                    // userLog({msg : "Build stopped due to the error in less files",color : "red"});
                               
                                    callback(err);                   
                                } else { 
                                    systemLog({msg :"\n[Compiled][themes]create an css files in the outputPath "+dist,type:"INFO",_zl_timestamp:new Date().getTime()});
                                    if(!production) {
                                        if(cssImports.length) {
                                            fileManipulation.merge_array(imports,cssImports);
                                        }
                                        imports.forEach(function(value){
                                            value = path.join(srcFolders.copyAppDir,value).toLowerCase();                                              
                                            buildUtils.RCSLDMap[value] =  buildUtils.RCSLDMap[value] || { keys : [],json : [],themeOptions : []};
                                            checkForAlreadyExistAndPushValueInObj(buildUtils.RCSLDMap[value],dist,{ json : lessPath,themeOptions : themeOptions});      
                                        });          
                                    }  
                                    callback();
                                }
                            });
                        });
                    } else {
                        callback();
                    }
                }
            }; 
            if(!production) {
                buildUtils.CSLDMap[lessPath] =  buildUtils.CSLDMap[lessPath] || {};
                buildUtils.CSLDMap[lessPath][dist] =  buildUtils.CSLDMap[lessPath][dist] || [];
            }      
            src.forEach(function(file) { /*generating the single .less files for compilation*/                            
                file = path.isAbsolute(file) ? file : path.join(srcFolders.themes,file);
                access(file,function(err){        
                    if(!production) {
                        buildUtils.CSLDMap[lessPath][dist].push(file);
                        let  lowerCaseOfvalue = file.toLowerCase();
                        buildUtils.RCSLDMap[lowerCaseOfvalue] = buildUtils.RCSLDMap[lowerCaseOfvalue] ||  { 
                            keys : [],
                            json : [],
                            themeOptions : []
                        };
                        checkForAlreadyExistAndPushValueInObj(buildUtils.RCSLDMap[lowerCaseOfvalue],dist,{
                            json : lessPath,
                            themeOptions: themeOptions
                        }); 
                    }
                    if(err) {
                        errorClass.handleWarnings(options,{
                            message : "Warning : File not found "+file,   
                            level : 2,                         
                            userLog : userLog,
                            systemLog : systemLog,
                            _zl_timestamp : new Date().getTime()
                        },options.disableLogs);
                        cbToCallForLessUtil();  
                    } else {
                        lstat(file,function(err,stats){
                            if(stats.isDirectory()){
                                let dirContent ='';
                                getFilesList(file,null,function(err,items){
                                    if(err) {  
                                        returnErrorObject(err);                            
                                        errorClass.handleErrors(options,err,cbToCallForLessUtil,cbToCallForLessUtil);
                                    } else {
                                        itemslen = items.length;
                                        finalLessContent += dirContent;     
                                        cbToCallForLessUtil();
                                    }
                                },function(item){                                    
                                    itemContent = createLessCompilationContent(item);
                                    dirContent += itemContent;
                                });
                            } else {
                                finalLessContent += createLessCompilationContent(file);
                                cbToCallForLessUtil();
                            }
                        });
                    }
                });
            });    
        }
    },
    checkForAnotherLyteAppInNodeModules = function(options) {
        let  packageJSONPath = path.join(srcFolders.copyAppDir,"package.json");    
        try {
            let  content = readSync(packageJSONPath,'utf-8');
            let  packageConfig = JSON.parse(content);
            options.addonsList = [];
            options.enginesList = [];
            if(packageConfig.addons) {
                options.addonsList = packageConfig.addons;
                options.addonsInApp = true;
            } 
            if(packageConfig.engines) {
                options.enginesList = packageConfig.engines;
                options.enginesInApp = true;
            }
            let  testAppPath;
            let  packageConfigContent;
            let setFlag;
            var existOfTestApp = options.buildAddonsTestApp || (setFlag = options.buildEnginesTestApp)
            if(existOfTestApp) {
                testAppPath =  path.join(options.root,"..");
                packageConfigContent  = readSync(path.join(testAppPath,"package.json"),'utf-8');

                let  obj = JSON.parse(packageConfigContent);
                if(setFlag) {
                    if(obj.engines) {
                        fileManipulation.merge_array(options.enginesList,obj.engines);
                    }
                    fileManipulation.merge_array(options.enginesList,[obj.name]);
                    options.enginesInApp = true; 
                } else {
                    if(obj.addons) {
                        fileManipulation.merge_array(options.addonsList,obj.addons);
                    }
                    fileManipulation.merge_array(options.addonsList,[obj.name]);
                    options.addonsInApp = true; 
                }
            }
        } catch(e) {
            systemLog({msg : e.message,stack : e.stack,_zl_timestamp: new Date().getTime(),type :"SEVERE"});
        }
    },
    webSocketServer = function(options,port) {
        let  WebSocket = require("ws"),
            webClientSrcFile  = path.join(options.cliRoot,"lib","webSocket","webSocketClient.js"),
            socketClientData = readSync(webClientSrcFile,'utf-8');
            
        socketClientData = socketClientData.replace("[[port]]",port);
        writeSync(path.join(distFolders.build,"webSocketClient.js"),socketClientData);
        let  socketServer = new WebSocket.Server({
            port : port
        });   
        socketServer.on('connection',function connection(ws) {
            options.clientSocket = ws;

            // options.log.user({msg :"client socket connection"+new Date().getTime()});
            ws.on('message',function incoming() { 
                // userLog({msg : 'Inside on message'});
                if(options.countDistChanges>0) {
                    options.countDistChanges--;
                }
                let errorObj = {};
                errorObj= Object.assign(errorObj,options.errorObj);
                if(options._cliAddonsOrEnginesBuildOptions){
                    errorObj = Object.assign(errorObj,options._cliAddonsOrEnginesBuildOptions.errorObj);
                }  		 
                if(commonCliUtils.checkAnyKeyInObj(errorObj)) {  
                    ws.send(JSON.stringify({
                        errorObj : commonCliUtils.createAnHTMLObject(options,errorObj),
                        errorFlag : true
                    }));
                }
            });
            ws.on("error",function(e) {
                
            });
        }.bind(options));
    },

    runTheEslintRules = function(options,module) {
        return new Promise(function(resolve,reject) {  
            let localEslint  = options.localEslint;
            let args = options.eslintArgs;
            args.ignorePattern =  [];
            let  throwError = false;
            if(fileManipulation.getTheFileExt(module) == ".js") {  /* watch time to enable building */                
                if(!module.includes("bower_components")  && !module.includes("node_modules")){                
                    lintPath = module;
                    throwError = true;     
                } else {
                    resolve();
                    return;
                }                   
            } else {   
                if(fileExist(srcFolders[module])) {       
                    switch(module) {
                        case "copyAppDir" :
                            let  ignorePattern = [relativeSrcFolders.components,relativeSrcFolders.routes,relativeSrcFolders.models,relativeSrcFolders.adapters,relativeSrcFolders.serializers,relativeSrcFolders.mixins,relativeSrcFolders.helpers,path.relative(srcFolders.copyAppDir,distFolders.copyAppDir),relativeSrcFolders.build,"rules/"];
                            if(options.addons || options.engines) {
                                ignorePattern.push("testApp/");               
                            }
                            args.ignorePattern = ignorePattern;
                            lintPath = srcFolders.copyAppDir;
                            break;
                        case "components":
                            module = "javascript";
                        default : 
                            lintPath = relativeSrcFolders[module];
                            break;   
                    }
                } else {
                    resolve();
                    return;
                } 
            }  
            
            let  cli = new localEslint(args);
            let  formatter = cli.getFormatter("stylish");
            let  reports = cli.executeOnFiles([lintPath]);
            let  error = false;
            if((reports.errorCount && (error = true)) || reports.warningCount) {
                let  logs = formatter(reports.results);
                logs = logs.replace(/\d\s+\w+\s*,\s*\d\s*\w+\s*potentially fixable with the `--fix` option./g,'');
                let  consoleMsg = logs;
                if(!throwError) { 
                    options.eslintLogContent += consoleMsg.replace(/[[0-9]+m/g,'');
                    consoleMsg = (error ? "Error" : "Warnings")+" in "+module+" while linting through eslint.Check the error log in build/lint.log file";
                }
                if(error) {
                    if(throwError) {
                        reject(new Error(consoleMsg));
                    } else {
                        errorClass.handleErrors(options,{message : consoleMsg,stack : new Error(' ').stack,userLog : userLog,systemLog : systemLog,_zl_timestamp : new Date().getTime()},reject,resolve);  
                    }
                } else { 
                    errorClass.handleWarnings(options,{message : consoleMsg,level : 2,userLog : userLog,systemLog : systemLog,_zl_timestamp : new Date().getTime()},true);    
                    resolve();
                }
            }  else {
                resolve();
            }
        });
    },
    addonsEnginesBuilding = function(options,module,moduleList) {
        return new Promise(function(resolve,reject) {                      
            let  length = moduleList.length;
            let  finishedCount = 0;
            let moduleBuilding;
            
            let resolveCallback = function(count) {
                if(count == length) {    
                    timerEnd(module);
                    multispinnerObj[module].text = "building "+module+" completed";
                    successSpinnerObj(module);
                    resolve();
                } else {
                    moduleBuilding(finishedCount);
                }
            }
            let  successCallBack = function() {   
                finishedCount++;     
                resolveCallback(finishedCount);        
            };      
            let errorCallback = function(e) {
                finishedCount++;
                errorClass.handleErrors(options,{message : e.message,stack : e.stack,userLog : userLog,systemLog : systemLog,_zl_timestamp : new Date().getTime()},reject,function() {
                    resolveCallback(finishedCount);
                },true);
            }
            
            if(length) {
                let  srcModulePath = path.join(srcFolders.copyAppDir,"node_modules");
                let  distModulePath = path.join(distFolders.copyAppDir,module);
                let  filePath;                        
                let  buildFilePath;
                moduleBuilding = function(index) {
                    let setWatchFn = false;
                    let packageName;
                    let moduleName = moduleList[index];
                    if(moduleName.includes(options.addonsOrEnginesToBeWatched)){
                        moduleName = path.join("..","..")
                        filePath = path.join(srcModulePath,moduleName);
                        setWatchFn = true;
                        packageName = options.addonsOrEnginesToBeWatched;
                    } else {
                        filePath = path.join(srcModulePath,moduleName);
                        packageName = moduleName;
                    }
                    if(fileExist(filePath)) {
                        
                        let outputPath = path.relative(filePath,path.join(distModulePath,packageName));      
                        let camelCaseOfModuleName = commonCliUtils.convertStringToCamelCase(packageName);
                        let moduleConfig;
                        let cliRoot;
                        options[module+"Config"] && (moduleConfig =  options[module+"Config"][camelCaseOfModuleName]);
                        buildFilePath = path.join(filePath,"build","build.js");
                        systemLog({msg :module+" building initated for"+buildFilePath,_zl_timestamp: new Date().getTime(),type:"INFO"});                         
                        if(fileExist(buildFilePath)) {  
                            systemLog({msg:"build file exists on "+module+" building",_zl_timestamp: new Date().getTime(),type:"INFO"});                               
                            var packageJSONContent = JSON.parse(readSync(path.join(filePath,"package.json"),'utf-8'))
                            var buildFn = function() {
                                var defaultPath = path.join(cliRoot,"lib");
                                delete global.required[path.join(defaultPath,"cli","cli.js")];
                                delete global.defaultReq.cache[path.join(defaultPath,"cli","cli.js")];
                                delete global.required[path.join(defaultPath,"utilities","buildUtils.js")];
                                delete global.defaultReq.cache[path.join(defaultPath,"utilities","buildUtils.js")];
                                let cli = global.defaultReq(path.join(cliRoot,"lib","cli","cli"));
                                process.chdir(filePath);
                                cli({ 
                                    browserWSEndpoint : options.browserWSEndpoint,
                                    cliArgs : ["build"],
                                    watch : options.watch,
                                    parentFolder : options.root,
                                    parentOutputFolder : options._appOutputFolder,
                                    sourceMap : options.sourceMap,
                                    cliRoot : cliRoot,
                                    debug : options.debug,
                                    fromCommand : false,
                                    production : options.production,
                                    root : filePath,
                                    addToPath : outputPath,
                                    disableLogs : true,
                                    nospinner : true,
                                    globalCli  : options.globalCli,
                                    inapp : true,
                                    [camelCaseOfModuleName] : moduleConfig
                                }).then(function(result) {
                                    if(!options.chromiumBrowser) {
                                        options.chromiumBrowser = result.chromiumBrowser;
                                        options.browserWSEndpoint = result.browserWSEndpoint;
                                    }
                                    options.pushTheLog.push.apply(options.pushTheLog,result.pushTheLog);
                                    if(setWatchFn) {
                                        options._cliAddonsOrEnginesBuildOptions = result;
                                    }
                                    process.chdir(options.root);
                                    successCallBack();
                                }).catch(function(e){
                                    process.chdir(options.root);
                                    errorCallback(e);
                                });
                            }  
                            packageJSONContent.resolution = packageJSONContent.resolution || {};
                            if(packageJSONContent.iframeAddon) {
                                var cliVersion =  packageJSONContent.resolution["lyte-cli"];
                                if(options.cliVersion == cliVersion) {
                                    cliRoot = options.cliRoot;
                                    buildFn()
                                } else {
                                    if(options.production) {
                                        var nodemodulePath = path.join(options.root,"node_modules","dockerode");
                                        if(fileManipulation.fileExist(nodemodulePath)) {
                                            Docker = require(nodemodulePath);
                                        } else {
                                            Docker = require("dockerode");
                                        }
                                        var docker = new Docker({
                                            socketPath: '/var/run/docker.sock'
                                        });
                                        let cmd = ['/usr/local/bin/lyte','build','--production','--inapp','--'+camelCaseOfModuleName+"="+moduleConfig,'--addToPath='+outputPath,'--parentFolder='+options.root,"--fromDockerCall","--disableLogs"];
                                        let image = 'zregistry.csez.zohocorpin.com:5000/lyte/lyte:v'+cliVersion
                                        var imageAuth = JSON.parse(fileManipulation.readSync(path.join(options.cliRoot,"lib","utilities","authToken.json"),"utf-8"))
                                        docker.pull(image,{
                                            authconfig : {
                                                username : imageAuth.userName,
                                                password : imageAuth.password
                                            }
                                        },function(err,stream) {
                                            if(err) {
                                                errorCallback(err);
                                            } else {
                                                docker.modem.followProgress(stream,onFinished,onProgress);
                                                function onFinished(err,output) {
                                                    if(err) {
                                                        errorCallback(err);
                                                    } else {
                                                        docker.run(image,cmd,process.stdout,{
                                                            Tty : true,
                                                            WorkingDir : filePath,
                                                            HostConfig: {
                                                                AutoRemove: true,
                                                                Binds: [
                                                                    `${options._appOutputFolder}:${options._appOutputFolder}`,
                                                                    `${filePath}:${filePath}`
                                                                ]
                                                            },
                                                        },function(err,data,container) {
                                                            if(err) {
                                                                errorCallback(err);
                                                                console.log(err);
                                                            } else {
                                                                if(data.StatusCode != 0) {
                                                                    errorCallback(new Error("Addons build failed"));
                                                                } else {
                                                                    successCallBack();
                                                                }
                                                            }
                                                        });
                                                    }
                                                }
                                                function onProgress(event) {
                                                    systemLog({msg :  "image : "+JSON.stringify(event),_zl_timestamp : new Date().getTime(),type : "INFO"});
                                                }
                                            }
                                        });
                                        
                                    } else {
                                        let projectLocalCli;
                                        if(fileManipulation.fileExist(projectLocalCli = path.join(filePath,"node_modules","lyte-cli"))) {
                                            cliRoot = projectLocalCli;
                                        } else {
                                            // var cliVersion = packageJSONContent.resolution["lyte-cli"];
                                            // if(cliVersion) {
                                            //     cliRoot = path.join(options.localCliLocation,"lyte-cli@"+cliVersion,"node_modules","lyte-cli");
                                            // } else {
                                                errorClass.handleWarnings(options,{
                                                    message : "Lyte build running in the cli version "+options.cliVersion+' instead of '+cliVersion,
                                                    userLog : userLog,
                                                    systemLog : systemLog
                                                },true);
                                                cliRoot = options.cliRoot;
                                            //}
                                        }
                                        buildFn();
                                    }
                                }
                            } else {
                                cliRoot = options.cliRoot;
                                buildFn();
                            }
 
                        } else {
                            successCallBack();
                        }
                    } else {
                        successCallBack();
                    } 
                }
                moduleBuilding(0);
            }  else {
                resolveCallback(0);
            }

        }); 
    },
    

    initialCalltoBuildTheModule = function(options,module) {       
        let  promiseArray = [];
        options.time(module);
        startSpinnerObj({'module' : module, msg : 'Building '+module+' files...', color : 'green'},options);                     
        switch(module) {
            case "copyTheNodeModules": 
            case "themes":
            case "widget":
                promiseArray.push(buildUtils[module](options));
                break;
            case "addons" :
                promiseArray.push(buildUtils.addons(options,options.addonsList));
                break;
            case "engines":
                promiseArray.push(buildUtils.engines(options,options.enginesList));
                break;
            default :                  
                promiseArray.push(buildUtils.buildFile.builder[module](module)); 
                if(options.development && !options.inapp && (options.eslint === true || options.eslint === "true")) {
                    promiseArray.push(runTheEslintRules(options,module));                                
                }
            }
        return Promise.all(promiseArray);
    },
    returnTheFilesForJsAutobundle = function(options,callback) {
        let  autoBundleJsArray = [];
        let  distCopyAppDir = distFolders.copyAppDir;
        let  bundleJsFileFullPath = path.join(srcFolders.copyAppDir,options.bundleJsFileName);
        let  array = [bundleJsFileFullPath,"routers","mixins","routes","helpers","javascript","models"];
        let  count = 0;
        let loopTheArray = function(key) {
            let keyPath = srcFolders[key] || key;
            let relativePath = relativeDistFolders[key] || path.relative(distCopyAppDir,bundleJsFileFullPath);
            access(keyPath,function(err){           
                if(!err) {
                    autoBundleJsArray.push(relativePath);
                }
                if(++count == 7) {
                    if(options.filesToAddInBundlingJsFiles) {
                        fileManipulation.merge_array(autoBundleJsArray,options.filesToAddInBundlingJsFiles);
                    }
                    callback(autoBundleJsArray);
                } else {
                    loopTheArray(array[count]);
                }
            });
        };
        loopTheArray(array[0]);
    },
    returnTheFilesForCssAutobundle = function(options,callback) {
        let  autoBundleCssArray = [];
        if(!options.includeStyle) {
            autoBundleCssArray.push(relativeDistFolders.styles);
        }
        if(options.filesToAddInBundlingCssFiles) {
            fileManipulation.merge_array(autoBundleCssArray,options.filesToAddInBundlingCssFiles);
        }
        callback(autoBundleCssArray);
    }, 
    removeTheDistFile = function(distJsFile) {                    
        if(fileExist(distJsFile)) {
            if(transpileOpt) {
                let  distTranspileFile = distJsFile.replace(options._appOutputFolder,options.es6Path);
                if(fileExist(distTranspileFile)) {
                    removeSync(distTranspileFile,true);
                }
            }
            removeSync(distJsFile,true);
        }       
    },

    lessCompilationUtil = function(options,content,dist,themeOptions,callback) {
        less.render(content,themeOptions).then(function(result){  
            let imports = result.imports;     
            let resultedCss = result.css; 
            options.fileContent[dist] = resultedCss;                                                   
            write(dist,resultedCss,function(){
                if(themeOptions.sourceMap) {
                    let map = result.map;
                    if(map) {
                        write(dist+'.map',map,function(){       
                            callback(null,imports);                                                                  
                        });
                    } else {
                        callback(null,imports);
                    }
                } else {
                    callback(null,imports);    
                }
            });                                                                                                
        },function(err) {
            err.message  = err.message+" in the fileName "+err.filename+" at line number "+err.line;
            callback(err);
        });
    },
    timerEnd = function(module) {
        let  timer = options.time(module);
        if(!options.inapp) {       
            userLog({color : 'blue', msg : 'Building time of '+module+' : '+timer}); 
        } 
        systemLog({msg :'Building time of '+module+' : '+timer,_zl_timestamp: new Date().getTime(),type:"INFO"});
    },
    debounce = function(filePath,curModule,curTime,delay) {
        let  time;
        if(prevChangedFile.file == filePath && prevChangedFile.module == curModule){
            time = curTime - prevChangedFile.time;
            if(time >= delay) {
                return true;
            }
            return false;
        }                 
        return true;                   
    },
    watch = function(obj,sane,options) {
        try {
            if(fileExist(obj.path)) { 
                let  changedSrcDistFolders = function(root) {
                    if(options.buildAddonsTestApp || options.buildEnginesTestApp) {
                        if(root.indexOf(options.root) == -1 || root.indexOf(options._cliAddonsOrEnginesBuildOptions._appOutputFolder) != -1) {
                            srcFolders = options._cliAddonsOrEnginesBuildOptions.folders.src;
                            distFolders = options._cliAddonsOrEnginesBuildOptions.folders.dist;
                            buildFileWatchFn = options._cliAddonsOrEnginesBuildOptions._clibuildFileWatchFn;
                            options.fileContent = Object.assign(options.fileContent,options._cliAddonsOrEnginesBuildOptions.fileContent);
                            return;
                        }
                    }
                    srcFolders = options.folders.src;
                    distFolders = options.folders.dist; 
                    buildFileWatchFn = options._clibuildFileWatchFn;
                };
                let  watcher = sane(obj.path,{glob: obj.glob , ignored : obj.ignored});
                watcher.on('change',function(filePath,root) { 
                    let  file = path.join(root,filePath);
                    changedSrcDistFolders(root);
                    if(debounce(file,obj.module,new Date().getTime(),1000))  {                                         
                        userLog({color : 'yellow', msg : '['+new Date().toLocaleTimeString()+'] '+path.relative(process.cwd(),file)+' file changed.'});                                                
                        triggerModuleWatchFn(obj.module,file,"changed");
                        if(!file.includes(distFolders.copyAppDir)) {                
                            prevChangedFile.file = file;
                            prevChangedFile.module=obj.module;
                            prevChangedFile.time = new Date().getTime();
                        }
                    }                  
                });

                watcher.on('add',function(filePath,root) {                   
                    let  file = path.join(root,filePath);
                    changedSrcDistFolders(root);
                    userLog({color : 'yellow', msg : '['+new Date().toLocaleTimeString()+'] '+path.relative(process.cwd(),file)+' file added.'}); 
                    if(obj.module == "components") {
                        let  name = path.parse(file).name;                   
                        if(debounce(name,"components",new Date().getTime(),1000)){
                            prevChangedFile.file = name;
                            prevChangedFile.module = "components";
                            prevChangedFile.time = new Date().getTime();
                            triggerModuleWatchFn(obj.module,file,"added");
                        }
                    }  else {
                        triggerModuleWatchFn(obj.module,file,"added");   
                    }            
                }); 

                watcher.on('delete',function(filePath,root){
                    let  file = path.join(root,filePath);
                    userLog({color :'yellow',msg : '['+new Date().toLocaleTimeString()+'] '+path.relative(process.cwd(),file)+' file deleted.'});     
                    changedSrcDistFolders(root);
                    delete options.fileContent[file];           
                    triggerModuleWatchFn(obj.module,file,"deleted");
                    
                });
            }
        } catch(e) {
            options.reject(e);
        }
    },  
    
    triggerModuleWatchFn = function(module,file,modification) {
        if(["dist","jsonFileModified","watchThemes"].indexOf(module) != -1) {
            let  watch = {
                dist : function(modifiedFile,modification) { 
                    buildUtils.consolidate({file : modifiedFile,modification : modification}).then(function() {
                        if(buildFileWatchFn && buildFileWatchFn.afterDistChanges) {
                            buildFileWatchFn.afterDistChanges(module,file,modification);
                        } 
                    });
                    if(options.clientSocket){
                        var key = file.toLowerCase();
                        if(options.liveReload){
                            if(!buildUtils.RCSLDMap[key] || buildUtils.RCSLDMap[key].keys.length == 0){
                                var myVar = setTimeout(function() {
                                    if(options.countDistChanges == 0) {
                                        clearInterval(myVar);
                                        options.countDistChanges++;
                                        // userLog({msg : "Reload calling "+new Date().getTime()});
                                        options.clientSocket.send("reload");
                                    }
                                },500);
                            }
                        }
                    }
                },
                jsonFileModified : function(jsonModifiedFile,modification) {
                    let  name =  path.parse(jsonModifiedFile).name;
                    if(name == "less-min-conf" && (modification == "added" || modification == "deleted")) {                      
                        let err = new Error("Build stopped due to manually "+(modification == "added" ? "adding" : "deleting")+" less configuration file in watch time.\nRestart the lyte build")
                        returnErrorObject(err);
                        errorClass.handleErrors(options,err,options.reject,options.reject);
                    } else {
                        try {
                            buildUtils.consolidate({    
                                config : modification == "deleted" ? {} : JSON.parse(readSync(jsonModifiedFile,'utf-8')),
                                module : jsonModifiedFile,
                                modification : modification
                            }).then(function() {
                                // if(name == "less-min-conf"){
                                //     if(fileExist(jsonModifiedFile)) {
                                //         options.lessContent= JSON.parse(readSync(jsonModifiedFile,'utf-8'));
                                //     }
                                // }
                                // updateCache(options);
                            });
                        } catch(err){
                            returnErrorObject(err);
                            if(err.message.indexOf('JSON')!= -1){
                                err.message = 'Syntax error in json file '+ jsonModifiedFile; 
                            }
                            errorClass.handleErrors(options,err);
                        }
                    }
                },

                watchThemes : function(file,modification) {
                    buildUtils.consolidate({
                        file : file, 
                        modification : modification
                    }); 
                    // updateCache(options);
                }
            };
            watch[module](file,modification);
        } else {
            // let  buildCacheObjPath = path.join(distFolders.build,"buildConf.json");
            // let  buildCacheObj = options.buildCacheObj;
            let  fileObj = path.parse(file);
            let  ext = fileObj.ext;
            let  callModule = function(){
                buildFileWatchFn[module](module,file,modification).then(function() {
                    if(module != "models") {
                        buildUtils.consolidate({
                            file : file,
                            modification : modification
                        });
                    }
                    if(options.liveReload){
                        if(options.errorObj && options.clientSocket){
                            options.clientSocket.send('reload');
                        }
                    }
                    // updateCache(options);
                });
            };         
            if(ext == ".js" && options.eslint) {
                if(modification == "deleted") {
                    callModule();
                } else {
                    runTheEslintRules(options,file).then(function(){
                        callModule();
                    }).catch(function(err){                  
                        let distFileLocation;
                        if(module == "models") {
                            distFileLocation = file.replace(srcFolders.models,distFolders.models).replace(srcFolders.serializers,distFolders.models).replace(srcFolders.adapters,distFolders.models);
                        } else if(module == "components") {
                            distFileLocation = file.replace(srcFolders.javascript,distFolders.javascript).replace(srcFolders.templates,distFolders.javascript).replace(srcFolders.styles,distFolders.javascript);
                        } else {
                            distFileLocation = file.replace(srcFolders[module],distFolders[module]);
                        }
                        if(fileExist(distFileLocation)){
                            removeSync(distFileLocation,true);
                        }
                         
                        errorClass.handleErrors(options,returnErrorObject(err));
                    });
                }
            } else {
                callModule();
            }
            
        }
    },
   
  
    handleSignals = function() {
        let Zflag = false;
        let logsWritten = false;
        let consoleLog = function() {
            if(!options.inapp) {
                console.log("Cleaning the code....");
            }
        }
        let cleanCode = function(options,closeTheBrowser) {           
            if(options) { 
                if(options.serverInstance){
                    options.serverInstance.close();
                }
                if(closeTheBrowser) {
                    options.chromiumBrowser &&  options.chromiumBrowser.close(); 
                }                   
                if(!logsWritten) {
                    logsWritten = true;
                    if(options.logPath) {
                        if(options.systemLogs.length) {
                            let  dir = path.parse(options.logPath).dir;
                            if(!fileExist(dir)) {
                                fileManipulation.mkdirSync(dir);
                            }
                            fileManipulation.appendSync(options.logPath,options.systemLogs); 
                        }
                    }  
                    if(options.eslint) {
                        var eslintLogs = options.eslintLogContent;
                        if(eslintLogs.length > 500) {
                            fileManipulation.writeSync(options.eslintLogFile,eslintLogs)
                        } else {
                            console.log(eslintLogs);   
                        }
                        options.eslintLogContent ='';
                    }
                }   
                options.build && buildUtils.clear();
            } 
        };
        process.on('unhandledRejection',function(reason,p) { 
            console.log('error',reason,p);   
            consoleLog();
            process.exit();
        });
        process.on('SIGINT',function(){   
            consoleLog();
            process.exit();
        });
        process.on('exit',function(code) { 
            if(code === 143 && Zflag == false) {       
                userLog({color:"red",msg:"You have started a new build for the same folder....."});
                userLog({color:"red",msg:"Process exiting for this build...."});
            }        
            cleanCode(options,true);
        });
        process.on('SIGTSTP',function(){    
            consoleLog();
            Zflag=true;          
            process.exit();
        }); 
        process.on('SIGTERM',function() {  
            consoleLog();       
            process.exit();
        }); 
    },

    buildUtils = {
        RCSLDMap : {},
        CSLDMap : {},
        directoryFile : {},
        lsDirectoryFile : {},
        init : function(buildOptions) { 
            options = buildOptions;
            options.build = true;
            options.time('init');
            if(options.liveReload == undefined){
                options.liveReload = true;
            }
            let widgetOpt = options.widget;
            if(widgetOpt) {
                commonCliUtils.tryCatch(function() {
                    let parentPath = options.root;
                    let node_modulesPath = path.join(parentPath,"node_modules");
                    let oldAsyncPackagePath = path.join(node_modulesPath,"convert-to-asyncawait");
                    let newAsyncPackagePath = path.join(node_modulesPath,"@zoho","convert-to-asyncawait");
                    let nodemodulePath;
                    if(fileManipulation.fileExist(newAsyncPackagePath)) {
                        nodemodulePath = newAsyncPackagePath;
                    } else {
                        nodemodulePath = oldAsyncPackagePath
                    }
                    let widgetFilePath = nodemodulePath;
                    if(options.inapp) {
                        if(!fileExist(widgetFilePath)) {
                            parentPath = options.parentFolder;
                            node_modulesPath = path.join(parentPath,"node_modules");
                            oldAsyncPackagePath = path.join(node_modulesPath,"convert-to-asyncawait");
                            newAsyncPackagePath = path.join(node_modulesPath,"@zoho","convert-to-asyncawait");
                            if(fileManipulation.fileExist(newAsyncPackagePath)) {
                                nodemodulePath = newAsyncPackagePath;
                            } else {
                                nodemodulePath = oldAsyncPackagePath
                            }
                            widgetFilePath = nodemodulePath;
                        }
                    }
                    fileManipulation.convertToAsyncAndAwait = require(widgetFilePath);
                    options.widgetConversionFilePath = global.defaultReq.resolve(widgetFilePath);
                },'widget','@zoho/convert-to-asyncawait');
            }
            
            
            transpileOpt = options.transpile;
            production = options.production;     
            production && (process.env.PRODUCTION = true);
            userLog = options.log.user;
            systemLog = options.log.system;   
       
            if(production && (fingerPrintOpt = options.fingerPrint)) {
                commonCliUtils.tryCatch(function() {
                    let packagePath = path.join(options.root,"node_modules","lyte-cli-fingerprint");
                    if(options.inapp) {
                        if(!fileExist(packagePath)) {
                            packagePath = path.join(options.parentFolder,"node_modules","lyte-cli-fingerprint")
                        }
                    }
                    fileManipulation.fingerPrintFn = require(packagePath);
                    options.fingerPrintMapping = {};
                    extraFolderForFingerPrint = fingerPrintOpt.includeList;
                    options.fingerPrintKeyRelativeTo = fingerPrintOpt.relativeTo || options.root;

                },'fingerprint','lyte-cli-fingerprint');
            } else {
               options.fingerPrint =  false;
            }
           
            let  multispinner =  options.multispinner;
            /*global let variable defining related to multispinner */
            multispinnerObj = multispinner.spinners;       
            startSpinnerObj = options.ui.startSpinner; 

            successSpinnerObj = multispinner.success.bind(multispinner);
            failureSpinnerObj = multispinner.error.bind(multispinner);

            /*defining the srcFolders and distFolders */      
            srcFolders = options.folders.src;
            distFolders = options.folders.dist;       
            srcFolders.bower_components = path.join(srcFolders.copyAppDir,'bower_components');
            distFolders.bower_components = path.join(distFolders.copyAppDir,"bower_components");
            srcFolders.node_modules = path.join(srcFolders.copyAppDir,'node_modules');
            distFolders.node_modules = path.join(distFolders.copyAppDir,"node_modules");
            consolidateFilesObj = {  
                map : {
                    "routes" :"routes-min-conf.json",
                    "components" :"components-min-conf.json",
                    "models" :"models-min-conf.json",
                    "helpers" :"helpers-min-conf.json",
                    "copyAppDir": { 
                        "bower_components" : "bower-min-conf.json",
                    },
                    "mixins" : "mixins-min-conf.json",
                    "services" : "services-min-conf.json"
                },
                array : ["routes-min-conf.json","components-min-conf.json","models-min-conf.json","helpers-min-conf.json","bower-min-conf.json","mixins-min-conf.json","less-min-conf.json"], 
                defaultJsonFilesFolderArray  : {
                    "models-min-conf.json" : distFolders.models,
                    "routes-min-conf.json" : distFolders.routes,
                    "components-min-conf.json" : distFolders.javascript,
                    "helpers-min-conf.json" : distFolders.helpers,
                    "mixins-min-conf.json" : distFolders.mixins,
                    "less-min-conf.json" : srcFolders.themes,
                    "bower-min-conf.json" : path.join(distFolders.copyAppDir,"bower_components")
                }
            }; 
            
            /*fileManipulation global variables definition*/
            
            writeSync =  fileManipulation.writeSync;
            write = fileManipulation.write;
            fileExist = fileManipulation.fileExist;
            read = fileManipulation.read;
            readSync =  fileManipulation.readSync;
            remove = fileManipulation.remove.bind(fileManipulation);
            removeSync =  fileManipulation.removeSync.bind(fileManipulation)
            getFilesList =fileManipulation.getFilesList.bind(fileManipulation);
            lstat  = fileManipulation.lstat.bind(fileManipulation);
            access = fileManipulation.access;
            buildUtils.buildFile = require(path.join(srcFolders.build,'build.js'));
            options._clibuildFileWatchFn =  buildUtils.buildFile.watcher;
            options.addWatchFn = this.addWatch;
            if(options.autoBundle) {
                let  appName;
                let  jsAutoBundlePath;
                let  cssAutoBundlePath; 
                appName = options.appName || "app";
                jsAutoBundlePath = options.jsAutoBundlePath;
                cssAutoBundlePath = options.cssAutoBundlePath;
                options.bundleJsFileName = jsAutoBundlePath ? path.join(jsAutoBundlePath,appName+".js") : appName+".js";
                options.bundleCssFileName = cssAutoBundlePath ? path.join(cssAutoBundlePath,appName+".css"): appName+".css";
            }
            
            options.disableThemeCache = options.disableThemeCache || false; 
            options.lessPath = path.join(srcFolders.build,"less-min-conf.json");            
            
            if(transpileOpt) {  
                commonCliUtils.tryCatch(function() {
                    options.es6Path = path.join(distFolders.copyAppDir,options.es6Path || "ES6");  
                    var transpilePath = global.defaultReq.resolve("@zoho/lyte-cli-transpile",{ paths : [options.root]});
                    var transpileModule =  require(transpilePath);
                    transpileModule.init(options);
                    fileManipulation.init(options);
                    fileManipulation.transpileUtil = transpileModule.transpilation;
                    options.ignoreFoldersFromTranspile = options.ignoreFoldersFromTranspile || [];
                    fileManipulation.merge_array(options.ignoreFoldersFromTranspile,["bower_components","node_modules"]);    
                    let babelrcFile = path.join(options.root,options.babelConfigurationFile || '.babelrc');
                    let packageJson = path.join(options.root,"package.json");
                    let jsonContent;
                    fileExist(packageJson) && (jsonContent = JSON.parse(readSync(packageJson,'utf-8')).babel);
                    fileExist(babelrcFile) && (jsonContent = JSON.parse(readSync(babelrcFile)));
                    if(jsonContent) {
                        options.transpileOpt = jsonContent;
                    }  
                },'transpile','@zoho/lyte-cli-transpile');
            } else {
                fileManipulation.init(options);
            }
            for(let  key in distFolders) {
                if(!path.isAbsolute(distFolders[key])) {
                    distFolders[key] = path.join(srcFolders.copyAppDir,distFolders[key]);
                }
                relativeSrcFolders[key] = path.relative(srcFolders.copyAppDir,srcFolders[key]);
                relativeDistFolders[key] = path.relative(distFolders.copyAppDir,distFolders[key]);
            }
            
            let  deleteCache = function() {
                try {              
                    if(fileExist(distFolders.copyAppDir)) {                  
                        removeSync(distFolders.copyAppDir,true);
                    }       
                } catch(e) {
                    throw e;
                }
            };   

            if(production) {
                options.eslint = false; /*production mode eslint will be false */
                options.disableCache = true;
                deleteCache();
            } else {
                options.groupLogMessage = {
                    "Invalid component data names in the component" : { msg :  [],headers : ["COMPONENTNAME","COMPONENTDATANAMES"],filePath : srcFolders.javascript}
                };                          
                //options.buildCacheObj = {};
                options.eslint = options.eslint != undefined ? options.eslint : false;
                options.buildConfPath = path.join(distFolders.build,"buildConf.json");
                // options.disableCache = true;
                options.errorObj = {};
                if(options.eslint) {
                    var appPackageJSON =path.join(options.root,"package.json");
                    if(fileManipulation.fileExist(appPackageJSON)) {
                        var jsonContent = JSON.parse(fileManipulation.readSync(appPackageJSON,'utf-8')).dependencies;
                        if(jsonContent["eslint"]) {
                            let localEslint = require(path.join(options.root,"node_modules","eslint"));
                            options.localEslint = localEslint.CLIEngine;
                        } else {
                            options.localEslint = CLIEngine;
                        }
                    } else {
                        options.localEslint = CLIEngine;
                    }
                    let  eslintrcPath = path.join(srcFolders.copyAppDir,'.eslintrc');        
                    if(!fileExist(eslintrcPath)) {
                        let  content = readSync(path.join(options.cliRoot,"blueprints","new",".eslintrc"));
                        writeSync(eslintrcPath,content);
                    }
                    options._cliEslintCachePath = path.join(distFolders.build,'lint.cache');
                    options.eslintLogFile = path.join(distFolders.build,"lint.log");
                    options.eslintLogContent = '';
                    options.eslintArgs = {
                        useEslintrc: true,
                        envs :["es6"],
                        cache : true,
                        cacheLocation : options._cliEslintCachePath
                    }
                    var ruleFolder =  srcFolders.rules;
                    ruleFolder = fileManipulation.fileExist(ruleFolder) ? [ruleFolder]  : []; 
                    ruleFolder = options.eslintRulePath || ruleFolder
                    options.eslintArgs.rulePaths =  ruleFolder;
                }
                // read(options.buildConfPath,'utf-8',function(err,data) {
                //     if(!err) {
                //         let  buildCacheObj = JSON.parse(data);
                //         buildCacheObj.templates = [];
                //         buildCacheObj.styles = [];
                //         buildCacheObj.serializers = [];
                //         buildCacheObj.adapters = [];
                //         options.buildCacheObj = buildCacheObj;
                //         // callback();
                //     }           
                // });    

                if(options.disableCache) {
                    deleteCache();   
                } else { 
                    // let  addToJSONobj = function() {
                    //     let  array = ["templates","styles","adapters","serializers"];
                    //     array.forEach(function(value){
                    //         getFilesList(srcFolders[value],null,function(items) {
                    //             options.buildCacheObj[value] = items;
                    //         });
                    //     });      
                    // };
                    if(fileExist(distFolders.copyAppDir)) {           
                        let  listContain = fileManipulation.readdirSync(distFolders.copyAppDir);  /*if the build occurs after production */                                                    
                        if(listContain.length == 1 && listContain.includes("build")) {                       
                            // addToJSONobj();                       
                            options.disableCache = true;
                        } else {                                         
                            // let  fileTimeCalculation = require("../lib/utilities/fileTimeCalculation");
                            // fileTimeCalculation(options);  
                            // if(options.themesToBeCompiled){
                            //     buildUtils.lessImportMapping = Object.assign({},buildCacheObj.lessImportMapping);
                            //     buildUtils.lessReverseImportMapping = Object.assign({},buildCacheObj.lessReverseImportMapping);
                            //     //buildUtils.CSLDMap[lessPath]=Object.assign({},buildCacheObj["CSLD"][lessPath]);
                            // }                                                        
                        }  
                    } else {                   
                        //addToJSONobj();                   
                        options.disableCache = true;
                    }  
                }
            }
            process.umask(0);
            fileManipulation.mkdirSync(distFolders.build);
            systemLog({msg : "Timing to complete init function"+options.time('init'),_zl_timestamp : new Date().getTime(),type:"INFO"});
            
        }, 

        delete : function(file) {
           removeSync(file,true);
        },


        build : function(modules) {         
            return new Promise(async function(resolve,reject) {  
                systemLog({msg : "CliLocation :"+options.cliRoot+"\n CliVersion "+options.cliVersion,type : "INFO",_zl_timestamp : new Date().getTime()});
                let command = options.command;
                options.time("build");
                    let  completedModuleCount = 0;
                    if(options.module) {
                        modules = options.module;
                    } else {
                        modules.unshift("copyTheNodeModules");
                        if(options.theming) {
                            modules.push("themes");
                        }
                        if(options.widget) {
                            modules.push("widget");
                        }
                        checkForAnotherLyteAppInNodeModules(options);
                        if(options.addonsInApp) { /*compiling the addons  which s inside the app*/
                            modules.unshift("addons");
                        }
                        if(options.enginesInApp) { /*compiling the engines  which s inside the app*/
                            modules.push("engines");
                        }
                        if(options.addons) {
                            modules.splice(modules.indexOf("routes"),1);
                        }
                    }

                    let  index = 0,modulesLen = modules.length; 
                    let  module; 
                    let writeToConfigFile = function(configFile,callback) {
                        var configContent = options.buildCacheObj;
                        read(configFile,'utf-8',function(err,data) {
                            if(!err) {
                                Object.assign(configContent,JSON.parse(data));
                            }
                            write(configFile,JSON.stringify(configContent,null,' '),callback);
                        });
                    }; 
                    try { 
                        for(index = 0;index < modulesLen;index++) {       
                            module = modules[index];                                
                            await initialCalltoBuildTheModule(options,module).then(function() {
                                completedModuleCount = completedModuleCount + 1;
                                if(completedModuleCount == modulesLen) { 
                                   
                                    options.time("consolidate");
                                    multispinnerObj[command].text = "Consolidation of files";
                                    let  promiseArray = [];
                                    let  success = function() {     
                                        if(options.eslint) {
                                            var eslintLogContent = options.eslintLogContent;
                                            if(eslintLogContent.length) {
                                                writeSync(options.eslintLogFile,eslintLogContent);
                                            }
                                        }                          
                                        if(!options.inapp) {                         
                                            if(options.errorCount) {                                     
                                                userLog({color :"red", msg : "No of errors :"+options.errorCount});
                                            }      
                                            if(options.warningsCount) {
                                                userLog({color :"yellow", msg : "No of warnings :"+options.warningsCount});
                                            }  
                                            systemLog({msg : "Minified Count : "+options.minifyCount,type : "INFO",_zl_timestamp : new Date().getTime()});
                                            let buildTime = options.time("build");
                                            userLog({color : 'blue', msg : 'Total Building Time : '+buildTime}); 
                                            userLog({color : 'green', msg : 'Built project successfully. Stored in '+distFolders.copyAppDir});
                                            systemLog({msg :'Total Building Time : '+buildTime,_zl_timestamp: new Date().getTime(),type:"INFO"});
                                        } else {
                                            systemLog({msg :'Total Building Time : '+options.time("build"),_zl_timestamp: new Date().getTime(),type:"INFO"});
                                        }
                                        systemLog({msg :"Building completed",_zl_timestamp: new Date().getTime(),type:"INFO"});
                                        buildUtils.clear();
                                        resolve();
                                    };
                                    
                                    let  consolidateCustomJSONfiles = function() {
                                        fileManipulation.readdir(srcFolders.build,function(err,lists) {
                                            let  file,len = lists.length,list;
                                            for(let  index =0;index < len;index++) {
                                                list = lists[index];
                                                file = path.join(srcFolders.build,list);                    
                                                if(fileManipulation.validateFile(file) && fileManipulation.getTheFileExt(file) == ".json" && !consolidateFilesObj.array.includes(list)) {                          
                                                    promiseArray.push(buildUtils.consolidate({configPath : file}));
                                                }                   
                                            }
                                            Promise.all(promiseArray).then(function() {                                                                                                      
                                                timerEnd("consolidate");
                                                if(production) { 
                                                    if(options.fingerPrint) {
                                                        write(path.join(options._appOutputFolder,"fingerprintMap.js"),'Lyte.fingerPrintMap='+JSON.stringify(options.fingerPrintMapping,null,' '),function(){
                                                            success();
                                                        });
                                                    }  else {
                                                        success(); 
                                                    }                                                                 
                                                } else { 
                                                    for(var key in options.groupLogMessage) {
                                                        let gMsg = options.groupLogMessage[key];
                                                        let content = gMsg.msg;
                                                       
                                                        if(content.length) {
                                                            if(gMsg.headers) {
                                                                content.unshift(gMsg.headers)
                                                            }
                                                            options.warningCount++;
                                                            userLog({msg : key + ' in the file path  '+gMsg.filePath+': \n',color : "magenta"});
                                                            userLog({row : content,color:"yellow"});
                                                        }
                                                    }
                                                    if(options.inapp) {
                                                        if(options.watch) {
                                                            options.buildCacheObj[options.root] = {};
                                                            var buildCacheObjAddons = options.buildCacheObj[options.root];
                                                            buildCacheObjAddons.RCSLDMap = buildUtils.RCSLDMap;
                                                            buildCacheObjAddons.CSLDMap = buildUtils.CSLDMap;
                                                            buildCacheObjAddons.lsDirectoryFile = buildUtils.lsDirectoryFile;
                                                            buildCacheObjAddons.directoryFile = buildUtils.directoryFile;
                                                            buildCacheObjAddons.theming = options.theming;
                                                            buildCacheObjAddons.includeStyle = options.includeStyle;
                                                            buildCacheObjAddons.ignoreFoldersFromCopy = options.ignoreFoldersFromCopy;
                                                        }
                                                    }
                                                    if(options.addons) {
                                                        writeToConfigFile(options.buildConfPath,success);
                                                        
                                                    } else if(options.watch) {
                                                        if(!options.inapp){
                                                            var liveReloadPort = options.liveReloadPort;
                                                            var getPort = require("get-port");
                                                            getPort({port:liveReloadPort}).then(function(port) {
                                                                systemLog({msg :"LiveServer running in "+port,_zl_timestamp: new Date().getTime(),type:"INFO"});                        
                                                                webSocketServer(options,port); 
                                                                writeToConfigFile(options.buildConfPath,success);                                                                    
                                                            }); 
                                                        }else{
                                                            writeToConfigFile(options.buildConfPath,success); 
                                                        }
                                                    } else {
                                                        writeToConfigFile(options.buildConfPath,success);
                                                    }                      
                                                }
                                        }).catch(function(e) {  
                                                if(production) {
                                                    reject(e);
                                                } else {                 
                                                    writeToConfigFile(options.buildConfPath,function(){
                                                        reject(e);
                                                    });                                                    
                                                } 
                                        
                                            }); 
                                        });
                                    };
                                    
                                    if(options.autoBundle) {                               
                                        multispinnerObj[command].text ="Autobundling the text";
                                        returnTheFilesForJsAutobundle(options,function(jsArray){
                                            let  json = {
                                                [options.bundleJsFileName] : jsArray                     
                                            };      
                                            buildUtils.consolidate({config : json,module : srcFolders.copyAppDir,strictExt : ".js"}).then(function() {
                                                returnTheFilesForCssAutobundle(options,function(cssArray) {
                                                    json = {
                                                        [options.bundleCssFileName] : cssArray
                                                    };                               
                                                    buildUtils.consolidate({config : json,module : "autoBundlingCss",strictExt : ".css"}).then(function() {
                                                        consolidateCustomJSONfiles();
                                                    }).catch(function(err){
                                                        errorClass.handleErrors(options,returnErrorObject(err),reject,consolidateCustomJSONfiles);
                                                    });                                 
                                                })
                                            }).catch(function(err){
                                                errorClass.handleErrors(options,returnErrorObject(err),reject,consolidateCustomJSONfiles);
                                            });                                  
                                        });
                                    } else {
                                        consolidateCustomJSONfiles();
                                    }                                                   
                                } 
                            }).catch(function(err) {
                                buildUtils.clear();
                                failureSpinnerObj(module,err);                    
                                throw(err); 
                            });
                        }
                    } catch(e) {
                        buildUtils.clear();
                        if(production) {
                            reject(e);
                        } else {                 
                            writeToConfigFile(options.buildConfPath,function(){
                                reject(e);
                            });                                                    
                        }                
                    }  
            });       
        },

        copyTheNodeModules : function(options) {
            return new Promise(function(resolve,reject) {
                let node_modules = path.join(options.root,"node_modules");
                let defaultLytePackages = ["lyte","@zoho/lyte","lyte-dom","@zoho/lyte-dom"];
                let count =0;
                let len = defaultLytePackages.length;
                let compareVersion = function(actual,expected) {
                    if(!semver.satisfies(actual,expected)) {
                        return false;
                    } 
                    return true;
                };
                let cb = function() {
                    if(count == len) {
                        resolve();
                    }
                };
                let copyNodeModules = function(err,src,dist,beforeCompilation) {
                    if(err) {
                        let errMsg = new Error("Incompatible version for "+err.versionComparePackage+".\nPackage name "+err.packageName+" expect "+err.expectedVersion+" version of "+err.versionComparePackage);
                       
                        errorClass.handleErrors(options,returnErrorObject(errMsg),reject,null,true);
                    } else {
                        _cliCopyFolder(options,{
                            src : src,
                            dist : dist,
                            beforeCompilation : beforeCompilation
                        },function(err) {
                            count++;
                            if(err) {
                                errorClass.handleErrors(options,{
                                    message : err.message,
                                    stack : err.stack,
                                    systemLog : systemLog,
                                    _zl_timestamp : new Date().getTime(),
                                    userLog : userLog
                                },reject,cb);
                            } else {
                                cb();
                            }
                        });
                    }
                };
                defaultLytePackages.forEach(function(package) {
                    let src = path.join(node_modules,package);
                    let packageProcessedCounter = 0;
                    access(src,function(err) {
                        if(err) {
                            count++;
                            cb();
                            return;
                        }
                        read(path.join(src,"package.json"),'utf-8',function(err,jsonObj) {
                            if(!err) {
                                jsonObj = JSON.parse(jsonObj);
                                let lyteVersionCompatibility = jsonObj.versionToCompare;
                                if(lyteVersionCompatibility) {
                                    for(let versionComparePackage in lyteVersionCompatibility) {
                                        packageProcessedCounter++;
                                        let versionInVersionComparePackage = lyteVersionCompatibility[versionComparePackage];
                                        if(versionComparePackage == "lyte-cli" || versionComparePackage == "@zoho/lyte-cli") {
                                            if(!compareVersion(options.cliVersion,versionInVersionComparePackage)) {
                                                copyNodeModules({
                                                    packageName :  package,
                                                    actualVersion  :options.cliVersion,
                                                    expectedVersion : versionInVersionComparePackage,
                                                    versionComparePackage : versionComparePackage
                                                });
                                            } else {
                                                --packageProcessedCounter;
                                            }  
                                        } else {
                                            let versionComparePackagePath = path.join(node_modules,versionComparePackage);
                                            access(versionComparePackagePath,function(err){
                                                if(err) {
                                                    let errMsg = new Error("Missing package "+versionComparePackage+".Installed the package using npm");
                                                    errorClass.handleErrors(options,returnErrorObject(errMsg),reject,null,true);
                                                } else {
                                                    read(path.join(versionComparePackagePath,"package.json"),function(err,data) {
                                                        data = JSON.parse(data);
                                                        if(!compareVersionAndCopyThePackage(data.version,versionInVersionComparePackage)) {
                                                            copyNodeModules({
                                                                packageName :  package,
                                                                actualVersion  :versionInVersionComparePackage,
                                                                expectedVersion :  data.version,
                                                                versionComparePackage : versionComparePackage
                                                            });
                                                        } else {
                                                            --packageProcessedCounter;
                                                        }
                                                    });
                                                }
                                            });
                                        }   
                                    }
                                } 
                            } 
                            if(packageProcessedCounter == 0) {
                                let beforeCompilation;
                                if(package == "lyte") {
                                    beforeCompilation = lytePackageBeforeCompilation;
                                }
                                copyNodeModules(null,src,path.join(options._appOutputFolder,"node_modules",package),beforeCompilation);
                            }     
                        });
                    });           
                });
            }).then(function() {
                multispinnerObj.copyTheNodeModules.text = "copying lyte dependencies completed";
                successSpinnerObj("copyTheNodeModules");
            })
        },

        copy : {
            file : function(obj,opt) {
                return new Promise(function(resolve,reject) {
                    opt && (options = opt);
                    _cliCopyFile(options,obj,function(err){
                        if(err) {
                            !userLog && (userLog = options.log.user); 
                            !systemLog && (systemLog = options.log.system);
                            errorClass.handleErrors(options,{message : err.message,stack : err.stack,systemLog : systemLog,userLog : userLog,_zl_timestamp : new Date().getTime()},reject,resolve) 
                        } else { 
                            resolve();
                        }
                    });
                });
            },
            folder : function(obj,opt) {
                return new Promise(function(resolve,reject) {
                    opt && (options = opt);
                    _cliCopyFolder(options,obj,function(err){
                        if(err) {
                            !userLog && (userLog = options.log.user); 
                            !systemLog && (systemLog = options.log.system);
                            errorClass.handleErrors(options,{message : err.message,stack : err.stack,systemLog : systemLog,userLog : userLog,_zl_timestamp : new Date().getTime()},reject,resolve) 
                        } else { 
                            resolve();
                        }
                    });
                });
            },
        },

        consolidate : function(obj) {     
            return new Promise(function(resolve,reject) {
                let convertToAsyncAndAwaitFlag = false;
                let  modification = obj.modification,
                    configPath = obj.configPath,
                    file = obj.file,
                    configModule = obj.module,
                    minify = obj.minify,
                    configObj = obj.config;    
                let  currentWorkingDir = srcFolders.copyAppDir;
                let  currentOutputFolder = distFolders.copyAppDir;
                let  validateTheJSONObj = function(values,filePath) {
                    if(Array.isArray(values)) {
                        return { 
                            length : values.length,
                            jsonObjValues : values
                        };
                    } else {
                        if(typeof values == "string") {
                            return { 
                                length : 1,
                                jsonObjValues : [values]
                            };
                        } else {
                            var e = {};
                            e.message = "Not an valid consolidation object found in "+filePath+"\nConsolidation object values should be an array or an string";
                        
                            errorClass.handleErrors(options,returnErrorObject(e),reject);
                            return {
                                length : 0
                            };
                        }
                    }
                };
                if(options.widget && configPath != '$store' && configModule !="$store") {
                    convertToAsyncAndAwaitFlag = true;
                }
                let consolidateBasedOnJson = function(jsonObj,keysLength,filePath) { 
                    let relativeFilePath = path.relative(srcFolders.build,filePath);               
                    if(!production) {
                        buildUtils.CSLDMap[filePath] =  buildUtils.CSLDMap[filePath] || {};
                    }                
                    let processedKeyCount = 0;
                    let consolidateCompletedCallback = function(resultArray,key) {
                        if(resultArray.length) {
                            callConcatFn(resultArray,key,function(err) {
                                if(err) {
                                    errorClass.handleErrors(options,returnErrorObject(err),reject,function(){
                                        resolveFn();
                                    });
                                } else {
                                    resolveFn();
                                }
                            });  
                        } else { 
                            access(key,function(err){
                                if(!err) {
                                    remove(key,function(err){
                                        resolveFn();
                                    });
                                } else {
                                    resolveFn();
                                }
                            });
                        }
                        function resolveFn() {
                            if((++processedKeyCount) == keysLength) {                                 
                                resolve();
                            }
                        }
                    };
                    let createFinalConsolidationArray = function(value,key,filePath,callback,fromLsCall) { 
                        let constructCSLDANDRCSLDMap = function(value,isDirectory) {                                                                                     
                            buildUtils.CSLDMap[filePath][key].push(value);
                            let  lowerCaseOfvalue = value.toLowerCase();
                            buildUtils.RCSLDMap[lowerCaseOfvalue] = buildUtils.RCSLDMap[lowerCaseOfvalue] ||  { keys : [],
                                json : [],
                                mapFromDirectory : []
                            };
                            checkForAlreadyExistAndPushValueInObj(buildUtils.RCSLDMap[lowerCaseOfvalue],key,{ json : filePath,mapFromDirectory : isDirectory || fromLsCall});                                                                                 
                        };
                        lstat(value,function(err,stat){
                            if(err) {
                                if(!production) {
                                    if(fileManipulation.getTheFileExt(value)) {
                                        constructCSLDANDRCSLDMap(value,false);
                                    } else {
                                        buildUtils.directoryFile[value]  = buildUtils.directoryFile[value] || {keys : [],json : []};
                                        checkForAlreadyExistAndPushValueInObj(buildUtils.directoryFile[value],key,{json : filePath});                                                                                                 
                                    }
                                }
                                
                                callback(err,value);
                            } else { 
                                if(stat.isFile()){                                              
                                    if(!production) {
                                        constructCSLDANDRCSLDMap(value,false);
                                    }
                                    callback(null,value);
                                } else {  
                                    if(!production) {    
                                        buildUtils.directoryFile[value]  = buildUtils.directoryFile[value] || {keys : [],json : []};
                                        checkForAlreadyExistAndPushValueInObj(buildUtils.directoryFile[value],key,{json : filePath});                                                                                                 
                                    }                          
                                    getFilesList(value,function(item) {
                                        return !(item.includes('.map') || item.includes('_lyte.js'));
                                    },function(err,items){                                                
                                        callback(err,items);
                                    },function(item) { 
                                        if(!production) {
                                            constructCSLDANDRCSLDMap(item,true);
                                        }
                                    });
                                }
                            }
                        });
                    };
                    let processEachConsolidateValue = function(key,value,fullPathOfValue,filePath,callback) {                              
                        let  defaultFolderForValue = consolidateFilesObj.defaultJsonFilesFolderArray[relativeFilePath];            
                        if(defaultFolderForValue && fullPathOfValue.indexOf(defaultFolderForValue) == -1) {
                 
                            let errorMsg = new Error("Error: "+value+" file is present in "+relativeFilePath+" file . Use "+relativeFilePath+" file for consolidating only "+relativeFilePath.split("-")[0]+" files")
                      
                            errorClass.handleErrors(options,returnErrorObject(errorMsg),reject,callback);                       
                        } else {                            
                            if(value.includes("*")) {
                                if(!production) {
                                    buildUtils.lsDirectoryFile[fullPathOfValue]  = buildUtils.lsDirectoryFile[fullPathOfValue] || { keys : [],json:[]};   
                                    checkForAlreadyExistAndPushValueInObj(buildUtils.lsDirectoryFile[fullPathOfValue],key,{
                                        json : filePath
                                    });    
                                }
                                lsCmd(fullPathOfValue,function(err,result) {                           
                                    if(err) {
                                        callback(err,fullPathOfValue);
                                    } else {
                                        let finalConsolidationArray = [];
                                        let resultLength = result.length;
                                        let incremental = 0;
                                        let iterateEndCallback = function(err,items) {
                                            incremental++;
                                            finalConsolidationArray = finalConsolidationArray.concat(items);
                                            if(incremental == resultLength) {
                                                callback(err,finalConsolidationArray);
                                            }
                                        };                      
                                        result.forEach(function(file) {   
                                            if(file.includes('.map') || file.includes('.map')) {
                                                iterateEndCallback(null,[]);
                                            } else {                            
                                                createFinalConsolidationArray(file,key,filePath,function(err,items) {                                               
                                                    iterateEndCallback(err,items);
                                                },true);
                                            }
                                        });  
                                    }
                                }); 
                            } else {
                                createFinalConsolidationArray(fullPathOfValue,key,filePath,callback);
                            }
                        }
                    };
                    let fnToProcessConsolidation = function(loopIndex,getValues,key,filePath,cb) {
                        let value = getValues[loopIndex];
                        let fullPath = path.isAbsolute(value) ? value : path.join(currentOutputFolder,value);
                        processEachConsolidateValue(key,value,fullPath,filePath,cb);
                    };
                    
                    for(let key in jsonObj) {                                               
                        let getValues = jsonObj[key];  
                        key = path.join(currentOutputFolder,key);
                        if(!production) {
                            buildUtils.CSLDMap[filePath][key] = [];
                        } 
                        let finalArrayForConsolidation = [];
                        let returnValidateJSON = validateTheJSONObj(getValues,filePath);
                        let valuesLen = returnValidateJSON.length;
                        getValues = returnValidateJSON.jsonObjValues;
                        
                        if(valuesLen) {
                            let loopIndex = 0;
                            let cb = function(err,items) {
                                ++loopIndex;
                                if(err) {
                                    returnErrorObject(err);
                                    if(err.message.indexOf("No such file")!= -1) {
                                        errorClass.handleWarnings(options,err,options.disableLogs);
                                    }
                                } else {     
                                    if(Array.isArray(items)) {
                                        finalArrayForConsolidation = finalArrayForConsolidation.concat(items);
                                    } else {
                                        finalArrayForConsolidation.push(items);
                                    }
                                }
                                if(loopIndex == valuesLen) {                                      
                                    consolidateCompletedCallback(finalArrayForConsolidation,key);  
                                    return;
                                } else {
                                    fnToProcessConsolidation(loopIndex,getValues,key,filePath,cb);
                                }
                            };
                            fnToProcessConsolidation(loopIndex,getValues,key,filePath,cb);
                        } else {
                            consolidateCompletedCallback(finalArrayForConsolidation,key);
                        }
                    }
                }      
                if(configPath) { /*consolidating file*/                                                    
                    read(configPath,'utf-8',function(err,configPathContent) {
                        if(err){
                            resolve();
                            return;
                        }
                        if(configPathContent.length) { 
                            try {
                                let  jsonObj = JSON.parse(configPathContent);
                                let  keys = Object.keys(jsonObj);
                                let  len = keys.length;
                                let  nextKeyMatchingIndex;
                                let  nextKey;
                                if(len) { 
                                    keys.forEach(function(key,index) {
                                        if(configPathContent.indexOf(key,configPathContent.indexOf(key)+1) != -1) {
                                            for(let  loop =index+1;loop< len;loop++) {
                                                nextKey = keys[loop];
                                                if((nextKeyMatchingIndex = jsonObj[nextKey].indexOf(key)) != -1) {                        
                                                    jsonObj[nextKey].splice.apply(jsonObj[nextKey],[nextKeyMatchingIndex,1].concat(jsonObj[key])); 
                                                }
                                            }
                                        }
                                    });
                                    consolidateBasedOnJson(jsonObj,len,configPath);
                                } else {
                                    /*no keys in json object */
                                    resolve();
                                }                              
                            } catch(e) {
                                e.message = "Syntax error in json file "+path.relative(currentWorkingDir,configPath);
                                errorClass.handleErrors(options,returnErrorObject(e),reject,resolve);
                            }
                        } else {
                            /*empty file */
                            resolve();
                        }
                    });                              
                } else if(file) {   
                    let  fileObj = path.parse(file);

                           
                    let  lowerCaseOffile = file.toLowerCase();
                    let  configFiles; 
                    let  csldContent;   
                    if(buildUtils.RCSLDMap[lowerCaseOffile]){
                        configFiles = buildUtils.RCSLDMap[lowerCaseOffile];
                        csldContent = buildUtils.CSLDMap;
                    }  else if(options.addons) {
                        let  content = JSON.parse(readSync(path.join(currentOutputFolder,"build","buildConf.json"),'utf-8'));
                        let  parsedContent = content.RCSLD; 
                        if(parsedContent) {
                            configFiles = parsedContent[lowerCaseOffile];
                            csldContent = content.CSLD;
                        }
                    }
                    let  checkTheNewAddedFilesIndirectoryAndLsList = function() {
                        if(modification == "added")   {  
                            /*file newly created has an directory already exist*/                             
                            confi = [];
                            if(fileManipulation.lstatSync(file).isDirectory()){
                                resolve();                               
                            } else {
                                let incCount = 0;
                                let directoryList = buildUtils.directoryFile;
                                let lsList = buildUtils.lsDirectoryFile;                               
                                let totalLen = 0;
                                let resolveAddCallback = function(){
                                    if(totalLen == incCount) {                                              
                                        resolve();
                                    }
                                };         
                                let listIterate = function(lists,file) {
                                    let consolidateKeys = lists.keys;
                                    let consolidateKeysLen =  consolidateKeys.length;
                                    let json  = lists.json;
                                    let incDirectory = 0;    
                                    let cb = function() {
                                        if(incDirectory == consolidateKeysLen) {
                                            incCount++;
                                            resolveAddCallback();
                                        }
                                    }                             
                                    consolidateKeys.forEach(function(list,index) {
                                        if(list != file) {
                                            _path = json[index];
                                            buildUtils.CSLDMap[_path][list] = buildUtils.CSLDMap[_path][list] || [];
                                            buildUtils.CSLDMap[_path][list].push(file);
                                            lowerCaseOffile = file.toLowerCase();
                                            buildUtils.RCSLDMap[lowerCaseOffile] = buildUtils.RCSLDMap[lowerCaseOffile] || {
                                                keys : [],
                                                json : [],
                                                mapFromDirectory : []
                                            };
                                            checkForAlreadyExistAndPushValueInObj(buildUtils.RCSLDMap[lowerCaseOffile],list,{
                                                json : _path,
                                                mapFromDirectory : true
                                            });
                                            
                                            callConcatFn(buildUtils.CSLDMap[_path][list],list,function(err){
                                                incDirectory++;
                                                if(err) {
                                                    errorClass.handleErrors(options,returnErrorObject(err),function(){},cb);
                                                } else {
                                                    cb();
                                                }
                                            });
                                        } else {
                                            incDirectory++;
                                            cb();
                                        }
                                    });
                                };     
                                fileObj.dir = fileObj.dir+path.sep;                          
                                for(let key in directoryList) {
                                    totalLen++;
                                    if(fileObj.dir.includes(key)){                                          
                                        listIterate(directoryList[key],file);
                                    } else {
                                        incCount++;                                          
                                    }
                                }
                                for(let key in lsList) {
                                    totalLen++;
                                    lsCmd(key,function(err,files){
                                        if(err) {
                                            incCount++;
                                        } else {
                                            if(files.includes(file)) {
                                                listIterate(lsList[key],file);                                            
                                            } else {
                                                incCount++;
                                            }
                                        }
                                    });
                                }
                                resolveAddCallback();
                            }   
                        } else {
                            resolve();
                        }
                    }; 
                    
                    if(configFiles) { 
                        let  duplicateRCSLDMap = JSON.parse(JSON.stringify(configFiles));
                        let configKeys = duplicateRCSLDMap.keys;
                        let inc = 0;
                        let keysLen =  configKeys.length; 
                        let cb = function(err){
                            if(err) {
                                errorClass.handleErrors(options,returnErrorObject(err));
                            }                           
                            if(inc == keysLen) { 
                                checkTheNewAddedFilesIndirectoryAndLsList();
                            }
                        };  
                        if(keysLen) {
                            for(let index = 0;index< keysLen;index++) {
                                let _path = duplicateRCSLDMap.json[index];
                                let _file = configKeys[index];
                                switch(modification){
                                    
                                    case "deleted" :       
                                        let duplicateRCSLDMapMapDir = duplicateRCSLDMap.mapFromDirectory  
                                        if(duplicateRCSLDMapMapDir) {
                                            let _isDirectory = duplicateRCSLDMapMapDir[index];
                                            if(_isDirectory) {
                                                let  t = csldContent[_path][_file];
                                                let  s =  buildUtils.RCSLDMap[lowerCaseOffile].keys;
                                                let  indexOf = s.indexOf(_file);
                                                t.splice(t.indexOf(file),1);                                      
                                                buildUtils.RCSLDMap[lowerCaseOffile].keys.splice(indexOf,1);
                                                buildUtils.RCSLDMap[lowerCaseOffile].json.splice(indexOf,1);
                                                buildUtils.RCSLDMap[lowerCaseOffile].mapFromDirectory.splice(indexOf,1);
                                            };  
                                        }                                     
                                    case "changed":
                                    case "added":
                                        if(_path.includes("less-min-conf.json")) {                           
                                            let  themeOptions = configFiles.themeOptions[index];
                                            buildUtils.compileThemes({
                                                src : csldContent[_path][_file],
                                                dist : _file,
                                                themeOptions : themeOptions
                                            }).then(function(){
                                                inc++;
                                                cb();
                                            }).catch(function(err){
                                                inc++;
                                                cb(err);
                                            }); 
                                        } else {
                                            let  mapContent = [];
                                            mapContent = csldContent[_path][_file];

                                            if(mapContent.length) {
                                                callConcatFn(csldContent[_path][_file],_file,function(err) {
                                                    inc++;
                                                    cb(err);                                      
                                                });
                                            } else {
                                                access(_file,function(err){
                                                    if(!err){
                                                        removeSync(_file,true);
                                                    } 
                                                    inc++;
                                                    cb();
                                                });
                                            }
                                        } 
                                    break;
                                }                          
                    
                            }
                        } else {
                            cb();
                        }
                    } else {
                        checkTheNewAddedFilesIndirectoryAndLsList();
                    }
                                
                } else if(configObj) { /*object*/ 
                    let csldMap;
                    let key;
                    let removeTheKeyFromCSLDMapAndRCSLMap = function(key) {
                        let  values = csldMap[key];
                        values.forEach(function(value){
                            value = value.toLowerCase();
                            if((matchedIndex = buildUtils.RCSLDMap[value].keys.indexOf(key)) != -1) {
                                buildUtils.RCSLDMap[value].keys.splice(matchedIndex,1);
                            }
                        });
                        removeTheDistFile(key);
                        delete csldMap[key];
                    };
                    switch(modification) {
                        case "deleted":
                            csldMap = buildUtils.CSLDMap[configModule];                  
                            for(key in csldMap) {
                                removeTheKeyFromCSLDMapAndRCSLMap(key);
                            }
                            resolve();
                            break;
                        case "changed":
                            csldMap = buildUtils.CSLDMap[configModule];  
                            if(csldMap) {
                                let  evaluatedConfigObj = {};
                                let  mapObjOfOldKeysAndNewKeys = {};  
                                for(key in configObj){
                                    fullPathKey = path.join(options._appOutputFolder,key);
                                    evaluatedConfigObj[fullPathKey] = [];
                                    let returnValidateJSON = validateTheJSONObj(configObj[key],configModule);
                                    let valuesLen = returnValidateJSON.length;
                                    configObj[key] = returnValidateJSON.jsonObjValues;
                                    if(valuesLen) {
                                        configObj[key].forEach(function(val){
                                            val = path.isAbsolute(val) ? val : path.join(options._appOutputFolder,val);
                                            evaluatedConfigObj[fullPathKey].push(val);
                                        });
                                    }
                                    mapObjOfOldKeysAndNewKeys[fullPathKey] = key;
                                }  
                                let  diffPairsInObj = commonCliUtils.returnDiffPairsInObj(csldMap,evaluatedConfigObj);
                                diffPairsInObj.deletedKeys.forEach(function(key) {
                                    removeTheKeyFromCSLDMapAndRCSLMap(key);
                                }); 
                                let  finalConsolidateObj = {};
                                for(key in diffPairsInObj.newPairsInObj) {
                                    originalKeys = mapObjOfOldKeysAndNewKeys[key];
                                    finalConsolidateObj[originalKeys] = configObj[originalKeys];
                                }
                                configObj = finalConsolidateObj;
                            }
                        case "added":                           
                        default :
                            if(configModule.includes("less-min-conf")) {
                                buildUtils.themes(options).then(function(){
                                    resolve();
                                }).catch(function(err){
                                    reject(err);
                                });                 
                            } else {
                                let keysLen = Object.keys(configObj).length;
                                if(keysLen) {
                                    consolidateBasedOnJson(configObj,keysLen,configModule);
                                } else {
                                    resolve();
                                }                   
                            } 
                    }
                }
                   
                function callConcatFn(from,to,resolveCallback) {                        
        
                    fileManipulation.concat(options,{
                        src : from,
                        dist : to,
                        callback : function(err) {                  
                            resolveCallback(err);        
                        },
                        minify : minify != undefined ? minify : options.production
                        // beforeConsolidation  : beforeConsolidation,
                        // afterConsolidation : afterConsolidation
                    },convertToAsyncAndAwaitFlag);                                   
                }
            });
        },

        addWatch : function(options,sane) {
            options.countDistChanges = 0;
            if(!userLog){
                userLog = options.log.user;
            }        
            let  addWatchForTheModule = function(srcFolders,distFolders,obj){
                options.theming = obj.theming;
                let  folderArray = [srcFolders.copyAppDir,srcFolders.routes,srcFolders.javascript,srcFolders.templates,srcFolders.styles,srcFolders.images,srcFolders.adapters,srcFolders.models,srcFolders.serializers,srcFolders.helpers,srcFolders.mixins,distFolders.copyAppDir,srcFolders.build];
                let modules = ['copyAppDir',"routes","components","components","components","components","models","models","models","helpers","mixins","dist","jsonFileModified"];    
                let  glob = {
                    jsonFileModified : ['**/*.json']
                };
                if(obj.ignoreFoldersFromCopy){
                    if(!obj.ignoreFoldersFromCopy.includes(srcFolders.node_modules)) {
                        obj.ignoreFoldersFromCopy.push(srcFolders.node_modules);
                    }
                    if(!obj.ignoreFoldersFromCopy.includes(srcFolders.bower_components)) {
                        obj.ignoreFoldersFromCopy.push(srcFolders.bower_components);
                    }
                } else {
                    obj.ignoreFoldersFromCopy = [distFolders.copyAppDir,srcFolders.node_modules,srcFolders.bower_components,srcFolders.routes,srcFolders.components,srcFolders.mixins,srcFolders.models,srcFolders.adapters,srcFolders.serializers,srcFolders.build,path.parse(srcFolders.models).dir,srcFolders.rules];               
                }
                let ignored = {
                    copyAppDir : obj.ignoreFoldersFromCopy,
                    dist : ['**/*.map','**/*.txt','**/*_lyte.js','build/',distFolders.build,'**/*.less',path.join(distFolders.copyAppDir,"addons")],   
                };
                if(obj.theming && options.cliTheming) {
                    modules.push('watchThemes');
                    folderArray.push(srcFolders.themes);
                } else {
                    ignored.jsonFileModified = ['less-min-conf.json'];
                } 
               
                modules.forEach(function(module,index) {
                    watch({path : folderArray[index], module :module,ignored : ignored[module],glob : glob[module]},sane,options);
                });
            };
            addWatchForTheModule(srcFolders,distFolders,{
                theming : options.theming,
                ignoreFoldersFromCopy : options.ignoreFoldersFromCopy
            });
            if(options.buildAddonsTestApp || options.buildEnginesTestApp) {
                let  addonSrcFolders =  options._cliAddonsOrEnginesBuildOptions.folders.src;
                let  addonDistFolders = options._cliAddonsOrEnginesBuildOptions.folders.dist;
                read(path.join(addonDistFolders.copyAppDir,"build","buildConf.json"),'utf-8',function(err,data){
                    let  themeFlag,ignoreFoldersFromCopy;
                    if(!err) {
                        let  buildConfObj = JSON.parse(data)
                        buildConfObj = buildConfObj[addonSrcFolders.copyAppDir];
                        options._cliAddonsOrEnginesBuildOptions.includeStyle = buildConfObj.includeStyle;
                        themeFlag = buildConfObj.theming;
                        ignoreFoldersFromCopy = buildConfObj.ignoreFoldersFromCopy;

                        Object.assign(buildUtils.RCSLDMap,buildConfObj.RCSLDMap);
                        Object.assign(buildUtils.CSLDMap,buildConfObj.CSLDMap);
                        Object.assign(buildUtils.directoryFile,buildConfObj.directoryFile);
                        Object.assign(buildUtils.lsDirectoryFile,buildConfObj.lsDirectoryFile);
                    }
                    addWatchForTheModule(addonSrcFolders,addonDistFolders,{
                        theming : themeFlag,
                        ignoreFoldersFromCopy : ignoreFoldersFromCopy
                    });
                });
            }  
        }, 

        replacer : function(options,obj) {
            let  pattern = new RegExp(obj.pattern,'g'),
                replaceWith = obj.replaceWith,
                folder = obj.folder;
            
            if(fileExist(folder)) {
                options.log.user({msg : 'replacing '+pattern+' with '+replaceWith, color : 'green'});            
                let  files = fileManipulation.lstatSync(folder).isDirectory() ? fileManipulation.getFilesListSync(folder) : [path.join(process.cwd(),folder)];
                let  content;
                files.forEach(function(file) {       
                    content = readSync(file,'utf8').replace(pattern,replaceWith);          
                    writeSync(file,content,true);  
                });             
            } else {
                options.log.user({msg : 'There is no such folder or file', color : 'red'});
            }
        },

        compileThemes : function(obj) {
            return new Promise(function(resolve,reject) {
                _cliCompileThemes(options,obj,function(err){
                    err ? errorClass.handleErrors(options,{message : err.message,stack : err.stack,systemLog : systemLog,userLog : userLog,_zl_timestamp : new Date().getTime()},reject,resolve,true) : resolve();
                });
            });      
        },

        themes : function(options) {
            return new Promise(function(resolve,reject) {         
                options.themeFlag=true;  
                options.cliTheming = true;
                let  filePath = options.lessPath;  /*no support for .ext and direct directory in the value of the key in less-min-conf file */                        
                read(filePath,'utf8',function(err,data) {
                    if(err) {
                        errorClass.handleWarnings(options,{
                            message : "Warnings : file not found "+filePath,
                            level : 2,
                            _zl_timestamp : new Date().getTime(),
                            userLog : userLog,
                            systemLog : systemLog
                        },options.disableLogs);
                        resolve();
                    } else {
                        let  content = JSON.parse(data);
                        let  mapping,obj = {}; 
                        let keysCount = 0;
                        let compiledFilesCount = 0;
                        for(let  key in content) {
                            keysCount++;
                            mapping = content[key]; 
                            obj = {
                                src : mapping,
                                dist : key,
                                themeOptions : options.themeOptions,
                                sourceMap : options.sourceMap
                            }; 
                            _cliCompileThemes(options,obj,function(err){
                                compiledFilesCount++;
                                let  fn = function() {
                                    if(keysCount == compiledFilesCount) {
                                        resolve();
                                    }
                                };
                                if(err) {
                                    errorClass.handleErrors(options,returnErrorObject(err),reject,fn);
                                } else {
                                    fn();
                                }
                            });
                        }
                        if(keysCount == 0) {
                            resolve();
                        }
                    }
                });
            }).then(function(){
                multispinnerObj.themes.text = "building themes completed";
                successSpinnerObj("themes");
            });
        },
        widget : function(options) {
            return new Promise(function(resolve,reject) {
                let filePath = options.widgetConversionFilePath;
                let overrideFile = path.join(filePath.substring(0,filePath.lastIndexOf("convert-to-asyncawait")),"convert-to-asyncawait","utilities","override.js");
                let distFile = path.join(options._appOutputFolder,"assets","lyte","override.js");
                _cliCopyFile(options,{
                    src : overrideFile,
                    dist : distFile
                },function(err) {
                    if(err) {
                        reject(err);
                    } else {
                        buildUtils.consolidate({
                            config : {
                                "assets/lyte/lyte-dependency.js" : [
                                    "assets/lyte/override.js",
                                    "bower_components/lyte/component/lyte-c.js"
                                ]
                            },
                            module : "widget-min-conf.json"
                        }).then(function(){
                            remove(distFile,function(err){
                                err ? reject(err) : resolve();
                            });
                        }).catch(function(err){
                            reject(err);
                        });
                    }
                })
            }).then(function(){
                multispinnerObj.widget.text = "building widget completed";
                successSpinnerObj("widget");
            });
        },
        addons : function(options,addonsList) {
            return addonsEnginesBuilding(options,"addons",addonsList);   
        },
        engines : function(options,enginesList) {
            return addonsEnginesBuilding(options,"engines",enginesList);      
        },
        _super : function(module,superOptions) {       
            let  file,
                modification,
                promiseArray =[],
                ignoreFolders = [],
                beforeCompilation,
                srcModule = srcFolders[module],
                distModule = distFolders[module],  
                   
                copyTheModule = function(options) {      
                    return new Promise(function(resolve,reject) {
                        let  args = {
                            minify : false,
                            transpile : transpileOpt,
                            beforeCompilation : beforeCompilation         
                        };                
                        if(file) {
                            let  cb = function(err){
                                if(err){
                                    errorClass.handleErrors(options,returnErrorObject(err),reject,resolve);
                                } else {
                                    resolve();
                                }
                            };
                            args.src = file;
                            args.dist = file.replace(srcModule,distModule);
                            lstat(file,function(err,stat){
                                if(err){
                                    cb(new Error(err));
                                } else {
                                    stat.isSymbolicLink() ? fileManipulation.copyWithSymbolicLink(args,cb) : (stat.isDirectory() ? _cliCopyFolder(options,args,cb) :_cliCopyFile(options,args,cb));
                                }
                            });                             
                        } else { 
                            let mod = module;
                            args.src = srcModule;
                            args.dist = distModule;                                         
                            _cliCopyFolder(options,args,function(err){
                                if(err) {
                                    reject(err);
                                } else {          
                                    systemLog({msg :"[Copy] "+relativeSrcFolders[mod]+" => "+path.relative(srcFolders.copyAppDir,args.dist)+"\n",type:"INFO",_zl_timestamp: new Date().getTime()})     
                                    resolve();
                                }
                            });                
                        }    
                    });      
                };
            if(superOptions) {
                if(Array.isArray(superOptions)) {
                    ignoreFolders = superOptions;
                } else {
                    file = superOptions.file;
                    modification = superOptions.modification;
                    beforeCompilation = superOptions.beforeCompilation;
                    ignoreFolders = superOptions.ignoreFolders;
                }           
            } 
            switch(module) {
                case "copyAppDir": 
                    if(modification) {  
                        delete options.fileContent[file];
                        switch(modification) {
                            case "deleted" : 
                                if(options.autoBundle && path.parse(file).name == path.parse(options.bundleJsFileName).name) {
                                    promiseArray.push(buildUtils.consolidate({
                                        file : file,
                                        modification : modification
                                    }));                                             
                                } else { 
                                    let distFile = file.replace(srcModule,distModule);
                                    removeTheFiles(distFile);
                                }
                                break;
                            case "changed":
                            case "added" :
                                if(options.autoBundle && path.parse(file).name == path.parse(options.bundleJsFileName).name) {
                                    promiseArray.push(buildUtils.consolidate({
                                        file : file,
                                        modification : modification
                                    }));                                             
                                } else if(file == srcFolders.routers && options.server){ 
                                    options.routerBaseUrl = require("../utilities/routerTraverse.js")(file);
                                    promiseArray.push(copyTheModule(options));      
                                } else {
                                    promiseArray.push(copyTheModule(options));      
                                }                                  
                                break;              
                        }          
                    } else {                     
                        let  distPath = path.relative(srcModule,distModule);                                       
                        if(ignoreFolders) {
                            ignoreFolders = ignoreFolders.map(function(value){
                                return path.join(srcModule,value);
                            });
                        } else {
                            ignoreFolders = [];
                        }
                        ignoreFolders.push(path.join(srcModule,"templateWithOldSyntax"));
                        if(!distPath.includes("..")) {
                            
                            ignoreFolders.push(path.join(srcModule,distPath));
                        }
                        let bowerComponentsPath  = path.join(srcFolders.copyAppDir,"bower_components");
                        let  defaultIgnoreFolderList = [
                            srcFolders.routes,
                            srcFolders.components,
                            bowerComponentsPath,
                            srcFolders.mixins,
                            
                            srcFolders.models,
                            srcFolders.adapters,
                            srcFolders.serializers,
                            srcFolders.build,
                            path.parse(srcFolders.models).dir,
                            path.join(srcFolders.copyAppDir,"node_modules"),
                            srcFolders.rules,
                            path.join(srcModule,"package-lock.json"),
                            path.join(srcModule,"addons"),
                            path.join(srcModule,"engines"),

                        ];
                        fileManipulation.merge_array(defaultIgnoreFolderList,ignoreFolders);
                        if(options.addons || options.engines) {
                            defaultIgnoreFolderList.push(path.join(srcModule,"testApp"));
                        }
                        options.ignoreFoldersFromCopy = defaultIgnoreFolderList;                   
                        let  appDir = fileManipulation.readdirSync(srcModule);                                               
                        let  validList = appDir.filter(function(val) {
                            if(fileManipulation.validateFile(val)) {
                                val = path.join(srcModule,val);
                                if(defaultIgnoreFolderList.includes(val)) {
                                    return false;
                                } 
                                return true;                   
                            } 
                            return false;
                        });
                        let  len = validList.length;
                        let  copiedFileCount = 0;  
                        if(len) {                             
                            let  index;  
                            let copyTheFolder=function(args,src,dist,callback) {
                                lstat(src,function(err,stats) {
                                    if(err) {
                                        callback(err);
                                    } else {
                                        args.src = src;
                                        args.dist =  dist;
                                        stats.isSymbolicLink() ? fileManipulation.copyWithSymbolicLink(args,callback) : (stats.isDirectory() ?  _cliCopyFolder(options,args,callback) : _cliCopyFile(options,args,callback));  
                                    }
                                }); 
                            }                          
                            promiseArray.push(new Promise(function(resolve,reject) {
                                let args =  {
                                    minify : false,
                                    transpile : transpileOpt,
                                    beforeCompilation : beforeCompilation
                                };    
                                let callback = function(err) {
                                    copiedFileCount++;  
                                    let errorCallback =  function(err,reject,resolve) {
                                        errorClass.handleErrors(options,returnErrorObject(err),reject,resolve);
                                    }   
                                    if(err) {
                                        errorCallback(err,reject);
                                    }         
                                    if(copiedFileCount == len) { 
                                        let distPath = path.join(distModule,"bower_components")
                                        fileManipulation.readdir(bowerComponentsPath,function(err,folders) {
                                            if(err) {
                                                resolve();
                                            } else {
                                                let copiedBowerComponentCount = 0;
                                                let foldersLength = folders.length;
                                                let originalBeforeCompilation = args.beforeCompilation;
                                                let callbackBowerComponent =  function() {
                                                    copiedBowerComponentCount++;
                                                    if(copiedBowerComponentCount == foldersLength) {
                                                        resolve();
                                                    }
                                                }
                                                folders.forEach(function(folder) {
                                                    if(folder.indexOf("lyte") != -1) {
                                                        args.beforeCompilation = lytePackageBeforeCompilation
                                                    } else {
                                                        args.beforeCompilation = originalBeforeCompilation;
                                                    }
                                                    copyTheFolder(args,path.join(bowerComponentsPath,folder),path.join(distPath,folder),callbackBowerComponent)
                                                });
                                            }
                                        })                           
                                      
                                    }
                                };   
                                for(index = 0; index < len; index++) {
                                    let folder = validList[index];                                            
                                    multispinnerObj.copyAppDir.text = 'copying '+folder+' to '+distPath;
                                    copyTheFolder(args,path.join(srcModule,folder),path.join(distModule,folder),callback)                                                                                                                                                                                                                                                                                              
                                }     
                            }));                                                                                       
                        }                                                     
                    }
                    break;
                case "routes" :               
                    if(modification) {
                        delete options.fileContent[file];
                        switch(modification) {
                            case "deleted" : 
                               
                                promiseArray.push(new Promise(function(resolve,reject) {
                                    let  ext = fileManipulation.getTheFileExt(file);
                                    file = file.replace(srcModule,distModule);
                                    if(fileExist(file)) {       
                                        if(ext){ 
                                            removeTheFiles(file);                                            
                                            resolve();
                                        } else {
                                            fileManipulation.readdir(file,function(err,files){                                    
                                                if(err) {
                                                    errorClass.handleErrors(options,returnErrorObject(err),function(){},resolve);
                                                }
                                                let  singleFile;
                                                files.forEach(function(dirFile) {
                                                    singleFile = path.join(file,dirFile);   
                                                    removeTheFiles(singleFile);                          
                                                });   
                                                removeTheFiles(file);
                                                removeTheFiles(file+'.js');                                            
                                                resolve();
                                            });  
                                        }    
                                    } else {
                                        resolve();
                                    } 
                                }));                 
                            break;
                            case 'changed':
                            case 'added':                           
                                promiseArray.push(copyTheModule(options));
                            break;  
                        }  
                    } else {
                        if(fileExist(srcModule)) {
                            promiseArray.push(copyTheModule(options)); 
                        }  
                    }
                    break;
                case "components":          
                    if(modification) {
                        let  submodule;
                        let  logFileContent,templateFile,javascriptFile,styleFile;
                        let fileObj = path.parse(file);
                        let dir = fileObj.dir;
                        let name = fileObj.name;
                        switch(modification) {
                            case "added" :                           
                                let  imageSrcPath = path.join(srcFolders.components,"images");
                                if(dir.includes(imageSrcPath)) {                                        
                                    promiseArray.push(buildUtils.buildComponents(superOptions))
                                } else {
                                    templateFile = path.join(dir.replace(srcFolders.javascript,srcFolders.templates).replace(srcFolders.styles,srcFolders.templates),name+'.html');
                                    javascriptFile = path.join(dir.replace(srcFolders.templates,srcFolders.javascript).replace(srcFolders.styles,srcFolders.javascript),name+'.js');
                                    styleFile = path.join(dir.replace(srcFolders.templates,srcFolders.styles).replace(srcFolders.javascript,srcFolders.styles),name+'.css');                                                                           
                                    if(fileObj.ext) {                                      
                                        if(fileExist(templateFile) && fileExist(javascriptFile)){
                                            if(options.theming) { 
                                                systemLog({msg :"[Watch] file added => calling buildComponents ",_zl_timestamp: new Date().getTime(),type:"INFO"})
                                                promiseArray.push(buildUtils.buildComponents(superOptions));
                                            } else {
                                                if(fileExist(styleFile)){
                                                    systemLog({msg: "Build components"+javascriptFile+"called",_zl_timestamp: new Date().getTime(),type:"INFO"});
                                                    promiseArray.push(buildUtils.buildComponents(superOptions));
                                                }
                                            }
                                        }                                                                                                         
                                    } else {
                                        submodule = dir.indexOf('javascript') != -1  ?  "javascript" : (dir.indexOf('templates') != -1 ? "templates" : (dir.indexOf('styles') != -1 ? "styles" : "images"));
                                        file = file.replace(srcFolders[submodule],distFolders[submodule]);
                                        if(!fileExist(file)) {
                                            fileManipulation.mkdirSync(file);
                                        }
                                    }   
                                }
                                break;

                            case "deleted" :
                                submodule = dir.indexOf('javascript') != -1  ?  "javascript" : (dir.indexOf('templates') != -1 ? "templates" : (dir.indexOf('styles') != -1 ? "styles" : "images")); 
                                if(submodule != "images" ) { /*file deleted manually*/
                                    logFileContent = readSync(options.logPath,'utf-8');
                                    templateFile = path.join(dir.replace(srcFolders.javascript,srcFolders.templates).replace(srcFolders.styles,srcFolders.templates),name+'.html');
                                    javascriptFile = path.join(dir.replace(srcFolders.templates,srcFolders.javascript).replace(srcFolders.styles,srcFolders.javascript),name+'.js');
                                    styleFile = path.join(dir.replace(srcFolders.templates,srcFolders.styles).replace(srcFolders.javascript,srcFolders.styles),name+'.css');
                                    if(logFileContent.indexOf('Removed File : '+file)!= -1) {  
                                        let  distJsFile = javascriptFile.replace(srcFolders.javascript,distFolders.javascript);
                                        if(!(fileExist(templateFile)) && !(fileExist(javascriptFile)) && !(fileExist(styleFile)) && fileExist(distJsFile)) {                                                                                           
                                            removeTheFiles(distJsFile);
                                        }
                                    } else {   
                                        systemLog({msg : "[Watch] file deleted manually =>  "+path.relative(srcFolders.copyAppDir,file)+" calling buildComponents",_zl_timestamp: new Date().getTime(),type:"INFO"})                                 
                                        promiseArray.push(buildUtils.buildComponents(superOptions));
                                        
                                    }                         
                                } else {
                                    file = file.replace(srcFolders.images,distFolders.images);
                                    removeTheFiles(file);
                                   
                                }    
                                break;

                            case "changed" : 
                                promiseArray.push(buildUtils.buildComponents(superOptions));
                                break;
                        }
                    } else {
                        systemLog({msg : "Building components ....",_zl_timestamp: new Date().getTime(),type:"INFO"});   
                        if(fileExist(srcModule)) {                    
                            promiseArray.push(buildUtils.buildComponents(superOptions));
                        }                                                          
                    }
                    break;
                case "models": 
                    if(modification) {
                        delete options.fileContent[file];
                        switch(modification) {
                            case "added" :                      
                                let ext = fileManipulation.getTheFileExt(file);
                                systemLog({msg : "[Watch] file added => "+file,_zl_timestamp : new Date().getTime(),type:"INFO"});
                                ext ?  promiseArray.push(buildUtils.buildModels(superOptions)) :   fileManipulation.mkdirSync(file.replace(srcModule,distModule));
                            break;
                            case "deleted" : 
                                if(file.indexOf('models')!=-1) {
                                    if(path.parse(file).name == "application") {
                                        promiseArray.push(buildUtils.buildModels(superOptions));
                                    } else {
                                        file = file.replace(srcModule,distModule);
                                        removeTheFiles(file);
                                    }
                                } else {
                                    promiseArray.push(buildUtils.buildModels(superOptions));
                                }
                            break;
                            case "changed" :
                                promiseArray.push(buildUtils.buildModels(superOptions));
                            break;
                        }
                    } else {
                        systemLog({msg :"Building models ..............\n",_zl_timestamp:new Date().getTime(),type:"INFO"});   
                        if(fileExist(srcModule) ||  fileExist(srcFolders.serializers) || fileExist(srcFolders.adapters)) {     
                            promiseArray.push(buildUtils.buildModels(superOptions));
                        }
                    }
                    break;
                case "helpers":
                    let commonFunction = function(matchedValue,file) {

                        if(!commonCliUtils.validateHelperName(matchedValue)) {
                            errorClass.handleWarnings(options,{
                                message : 'Validation for helper name failed in the file '+path.relative(srcFolders.copyAppDir,file)+' : Helper name '+matchedValue+' should not contain hyphen and characters of arithmetic and unary operator ',
                                level : 2,
                                systemLog : systemLog,
                                userLog : userLog
                            },options.disableLogs);
                        }
                    }
                    beforeCompilation = function() {
                        let data = this.data;
                    
                        // let node = espree.parse(data);
                        // let body = node.body;
                        // for(let i = 0,len = body.length ;i < len;i++) {
                        //     let bodyIndex = body[index];
                        //     if(bodyIndex.type == "ExpressionStatement") {
                        //         let exp =  bodyIndex.expression == 'CallExpression';
                        //         let callee;
                        //         if(exp.type == "CallExpression" && (callee = exp.callee) && callee.property.name == "registerHelper") {
                        //             let zerothArgs = exp.arguments[0];
                        //             if(zerothArgs.type == "Literal") {
                        //                 commonFunction(zerothArgs.value,file);
                        //             }
                        //         }
                        //     } 
                        // }
                        /*Using regex*/
                        var regex = new RegExp('Lyte.Component.registerHelper\\((.*)\\s*,\\s*function\\s*\\(\\s*','g');
                        while (matches = regex.exec(data)){
                            let matchedValue = matches[1];
                            commonFunction(matchedValue,this.file);
                        }
                        return data;
                    } 
                case "mixins":
                case "services":
                    if(modification) {
                        delete options.fileContent[file];
                        switch(modification) {
                            case "deleted":
                                file = file.replace(srcModule,distModule);
                                removeTheFiles(file);
                                break;
                            case "added":
                            case "changed":
                                promiseArray.push(copyTheModule(options));
                        }
                    } else {
                        if(fileExist(srcModule)) {
                            systemLog({msg : "Building "+module+" .....",_zl_timestamp : new Date().getTime(),type:"INFO"});
                            promiseArray.push(copyTheModule(options));
                        }
                    }
                    break; 
            }
            return Promise.all(promiseArray);
        }, 
        _completed : function(module) {      
            let  configFiles = consolidateFilesObj.map;
            if(multispinnerObj[module].state === "incomplete") {              
                multispinnerObj[module].text= 'building '+module+' completed';           
                successSpinnerObj(module);
                timerEnd(module);
            }
            let  array = [];
            let  moduleConfigFile;
            if(defaultModules.includes(module)) {
                if(module == "copyAppDir") { 
                    for(let  key in configFiles[module]) {
                        moduleConfigFile = path.join(srcFolders.build,configFiles[module][key]);
                        array.push(buildUtils.consolidate({configPath : moduleConfigFile}));  
                    }
                } else {
                    moduleConfigFile = path.join(srcFolders.build,configFiles[module]);
                    array.push(buildUtils.consolidate({configPath : moduleConfigFile}));   
                }
            }
            return Promise.all(array);          
        },
        buildModels : function(superOptions) {  
            return new Promise(function(resolve,reject) {
                let  storeJson = {},
                    beforeCompilation,
                    file;
                if(superOptions) {     
                    file = superOptions.file;
                    modification =  superOptions.modification;            
                    beforeCompilation  = superOptions.beforeCompilation;
                }  
                let allFilesIterated = false;
                let itemParsed = 0;
                let totalFiles;
                let  srcModels = srcFolders.models,
                    srcAdapters = srcFolders.adapters,
                    srcSerializers = srcFolders.serializers,
                    distCopyAppDir = distFolders.copyAppDir;
                let  modules = ['adapters','serializers'];      
                if(file) { //changing the serializers and adapters files to model files
                    if(file.indexOf('serializers') != -1) {
                        file = file.replace(srcSerializers,srcModels);
                    } else if(file.indexOf('adapters') != -1){
                        file = file.replace(srcAdapters,srcModels);
                    }
                    let initialArrayValue =[];
                    if(fileExist(file)) { /*check for model file existence */
                        initialArrayValue = [path.relative(distCopyAppDir,file)]
                    } else {
                        if(path.parse(file).name.indexOf("application") == -1) {
                            resolve();
                            return;
                        }
                    }
                    createStoreJSON(file,initialArrayValue,function(){
                        callConsolidateFn();
                    });  
                } else {
                    let callback = function(){
                        if(allFilesIterated && itemParsed == totalFiles) {
                            callConsolidateFn();
                        }
                    };
                    getFilesList(srcModels,null,function(err,items) {    
                        allFilesIterated = true;    
                        totalFiles = items.length;  
                        var distPathOfApplication = path.relative(distCopyAppDir,path.join(distFolders.models,"application.js"));
                        if(!storeJson[distPathOfApplication]) {
                            totalFiles = totalFiles+1;
                            createStoreJSON(path.join(srcModels,"application.js"),[],callback);
                        } else {
                            callback();
                        }
                    },function(item) {
                        createStoreJSON(item,[path.relative(distCopyAppDir,item)],callback);
                    });
                }        
                function createStoreJSON(file,initialValue,callback) {
                    let moduleTraversedCount = 0;     
                    let distModelFile = path.relative(distCopyAppDir,file.replace(srcModels,distFolders.models));                      
                    storeJson[distModelFile] = initialValue;           
                    modules.forEach(function(module) {
                        let otherFile  = file.replace(srcModels,srcFolders[module]);
                        read(otherFile,'utf-8',function(err,data) {
                            moduleTraversedCount++;
                            if(!err) {
                                if(beforeCompilation) {
                                    let  result = beforeCompilation.call({
                                        file : otherFile,
                                        data : data
                                    });
                                    if(result != data) {
                                        data = (result != undefined && result != null) ? result : data;
                                    }
                                }
                                options.fileContent[otherFile] = data;
                                storeJson[distModelFile].push(path.relative(distCopyAppDir,otherFile));           
                            }
                            if(moduleTraversedCount == 2) {
                                itemParsed++;
                                callback();
                            }
                        });       
                    }); 
                }
                function callConsolidateFn() {
                    buildUtils.consolidate({
                        config : storeJson,
                        module :'$store'
                    // afterCompilation : afterConsolidation
                    }).then(function(){
                        resolve();
                    }).catch(function(err){
                        reject(err);
                    });
                }
            });
        },
    
        buildComponents : function(superOptions) {  
            return new Promise(function(resolve,reject) {
                let templateJSONFile = path.join(distFolders.copyAppDir,'build','processedTemplateContent.json');
                let buildComponentsReject = function(err) {
                    remove(templateJSONFile,function(){
                        reject(err);
                    });
                };
                let buildComponentsResolve = function(){
                    remove(templateJSONFile,function(){
                        resolve();
                    });
                };
                try {
                    let  singleFile = false,
                        mappingList= {},
                        allJsFiles = [],     
                        file,
                        includeStyle,                        
                        modification,   
                        beforeCompilation,
                        afterCompilation;
                    let distCopyAppDir = distFolders.copyAppDir;
                    let srcCopyAppDir = distFolders.copyAppDir;
                    let  jsSrcPath  = srcFolders.javascript;
                    let  jsDistPath = distFolders.javascript;
                    let  templateSrcPath = srcFolders.templates;
                    let  styleSrcPath = srcFolders.styles;
                    let  mkdir = fileManipulation.mkdir;
                    let  imageSrcPath = srcFolders.images;
                    let  imageDistPath = distFolders.images;
                    let  jsContent = '';
                    let  js = {};
                    let  html = {};
                    let  css = {};
                    let commonFn = function(lyteFile,distJsFile,sourceJsFile,data,callback) {
                        remove(lyteFile,function(err){
                            if(transpileOpt) {
                                fileManipulation.transpileFn(options,{
                                    src : sourceJsFile,
                                    dist : distJsFile,
                                    content : data
                                },callback);
                            } else {
                                fileManipulation.customFsWriteFn(options,data,distJsFile,afterCompilation,false,callback);                         	
                            }
                        })
                    }
                    let writeToDistGlobal;
                    let parentFolder = options.parentOutputFolder || distCopyAppDir;
                    if(options.sourceMap) {
                        writeToDistGlobal = function(data,indx,lyteFile,template,sourceJsFile,distJsFile,callback) {  
                            commonCliUtils.constructMappingForComponents(data.slice(0,indx),template,data.slice(indx,data.length),path.relative(parentFolder,sourceJsFile),distJsFile,data,function(err,resultData,map) {
                                if(err) {
                                    errorClass.handleErrors(options,returnErrorObject(err),buildComponentsReject,callback);
                                } else {
                                    // let  toFolderObj = path.parse(distJsFile);
                                    // resultData = resultData+"\n//# sourceMappingURL="+toFolderObj.name+toFolderObj.ext+".map";
                                    options.fileContent[distJsFile+'.map'] = map;
                                    commonFn(lyteFile,distJsFile,sourceJsFile,resultData,callback)
                                }
                            });
                        }
                    } else {
                        
                        writeToDistGlobal = function(data,indx,lyteFile,template,sourceJsFile,distJsFile,callback) {   
                            commonFn(lyteFile,distJsFile,sourceJsFile,data.slice(0,indx)+"\n"+template+data.slice(indx,data.length),callback)
                        }
                    }
                   let generateDistTemplates = function(mappingList) {
           
                        //return new Promise(function(resolve,reject) {            
                            let  unclosedTags = [],
                                unclosedTagFinder,
                                finder,
                                templateFileslen = allJsFiles.length,               
                                readFinishCount = 0,
                                functionSyntax = '',
                                evaltry = "\n try { \n \nvar  data = ";
                                evalStr = "; eval(data)\n \n } catch(e) {";
                            let errorHandlingInComponent = function(jsFile,callback) {
                                let distJsFile = jsFile.replace(jsSrcPath,jsDistPath);
                                removeTheDistFile(distJsFile);
                                if(singleFile){
                                    buildComponentsResolve();
                                } else {
                                    callback();
                                }
        
                            };
                            let unclosedTagsErrorCallBack = function(htmlFile,msg,errMsg,jsFile,tag,line) { // msg - message to be displayed in console with line numbers                                                       // errMsg - message to be displayed in browser during serve without line numbers
                                errorClass.handleErrors(options,{message : msg,stack : new Error(msg).stack,userLog : userLog,systemLog : systemLog,file : htmlFile,tag:tag,line : line,errMsg:errMsg,_zl_timestamp : new Date().getTime()},reject,function() {
                                    readFinishCount++;
                                    errorHandlingInComponent(jsFile,unclosedTagsSuccessCallback);
                                }); 
                            };
                            systemLog({msg :"Searching for syntax errors.....",type :"INFO",_zl_timestamp : new Date().getTime()});
                            multispinnerObj.components.text='Searching for syntax errors...';
                            options.time("unclosedTags");
                            if(!production) {                    
                                unclosedTagFinder = require('unclosed-tag-finder');
                                finder = new unclosedTagFinder.builder();
                            }
                            function getJsCssLyteContent(options,obj,jsFile,cssFile,callback) {
                                let name = obj.name;
                                let cb = function() {
                                    read(jsFile,'utf-8',function(err,data) {                                   
                                        if(err) {
                                            errorClass.handleErrors(options,returnErrorObject(err),buildComponentsReject);
                                        } else {
                                            js[name] = data;
                                            data = JSON.stringify('\n(function() {\n'+data+"\n})()");
                                            jsContent += evaltry+data+evalStr+"\ncatchFn(data,'"+name+"') \n } \n";
                                        }
                                        read(cssFile,'utf-8',function(err,data) {
                                            readFinishCount++;
                                            if(err) {
                                                css[name] = '';
                                            } else {
                                                css[name] = data;
                                            }
                                            callback();
                                        });
                                    });                
                                };
                                commonCliUtils.convertHTMLToJS(options,obj,function(err,returnObj) {
                                    if(err) {
                                        errorClass.handleErrors(options,returnErrorObject(err),buildComponentsReject,function() {
                                            errorHandlingInComponent(jsFile,function() {
                                                html[name] = '';
                                                cb();
                                            });
                                        });
                                    } else {
                                        let functionalSyntaxVal = returnObj.functionSyntax;
                                        functionalSyntaxVal && (functionSyntax += functionalSyntaxVal);
                                        html[name] = returnObj.htmlContent;  
                                        cb();
                                    }          
                                });
                            }
                                
                            for(let key in mappingList){     
                                let maplist = mappingList[key];       
                                let htmlFile = maplist.html;  
                                let lyteFilePath = maplist.lyteFilePath;
                                let jsFile = maplist.js;
                                let cssFile = maplist.css;                       
                                read(htmlFile,'utf-8',function(err,data) {                  
                                    if(err) {
                                        err = new Error(err);
                                        errorClass.handleErrors(options,returnErrorObject(err),buildComponentsReject,function() {
                                            readFinishCount++;
                                            unclosedTagsSuccessCallback();
                                        });
                                    } else {                           
                                        if(beforeCompilation) {
                                            let  result = beforeCompilation.call({
                                                data : data,
                                                file : htmlFile
                                            });
                                            if(data != result) {
                                                data = result != undefined && result != null ? result : data;
                                            }
                                        }                                                   
                                        if(production) { /*for production skip the unclosed tag finder */
                                            getJsCssLyteContent(options,{
                                                htmlFile : htmlFile,
                                                lyteFilePath :lyteFilePath,
                                                name : key,
                                                htmlContent : data
                                            },jsFile,cssFile,unclosedTagsSuccessCallback);
                                        } else {                                                                 
                                            unclosedTags = finder.getUnclosedTags(data.replace(/<!--(.|\s)*?-->/g,''));
                                            unclosedTagsLength = unclosedTags.length;
                                            if(unclosedTagsLength == 0) {                                       
                                                getJsCssLyteContent(options,{
                                                    htmlFile : htmlFile,
                                                    lyteFilePath : lyteFilePath,
                                                    name: key,
                                                    htmlContent : data
                                                },jsFile,cssFile,unclosedTagsSuccessCallback);                                                                             
                                            } else {
                                                unclosedTags.forEach(function(error) {
                                                    if(error.hasNoCloseTag) {
                                                        let  errorTag = error.tag;
                                                        if((errorTag.includes('if') || errorTag.includes('switch') || errorTag.includes("else\ if") || errorTag.includes("for")) && !errorTag.includes("{{"))  {                                                    
                                                            if(errorTag.includes(error.name)) { // to check for where error.name is there
                                                                unclosedTagsLength = unclosedTagsLength - 1;
                                                            }
                                                        } else {  
                                                            systemLog({msg:"[UnclosedTags Failed] =>"+path.relative(srcCopyAppDir,htmlFile),type:"INFO",_zl_timestamp: new Date().getTime()})  
                                                            unclosedTagsErrorCallBack(htmlFile,"Unclosed '"+error.name+ "' tag at "+htmlFile+" in "+error.line+' => '+error.tag,"Unclosed '"+error.name+ "' tag",jsFile,error.tag,error.line);                                                                                      
                                                        }
                                                    } else { 
                                                        systemLog({msg :"[UnclosedTags Failed] =>"+path.relative(srcCopyAppDir,htmlFile),type :"INFO",_zl_timestamp: new Date().getTime()});                                                 
                                                        unclosedTagsErrorCallBack(htmlFile, "Unopened '"+error.name+ "' tag at "+htmlFile+" in "+error.line+' => '+error.tag,"Unopened '"+error.name+ "' tag",jsFile,error.tag,error.line);
                                                    }
                                                });                                       
                                                if(unclosedTagsLength == 0) { 
                                                    getJsCssLyteContent(options,{
                                                        htmlFile : htmlFile,
                                                        lyteFilePath : lyteFilePath,
                                                        name : key,
                                                        htmlContent : data
                                                    },jsFile,cssFile,unclosedTagsSuccessCallback);
                                                }                          
                                            }
                                        }
                                    }
                                })                                       
                            }
                            
                            function unclosedTagsSuccessCallback() {
                                if(readFinishCount == templateFileslen) {   
                                                       
                                    let  processTheTemplateFn = function() { 
                                        let  obj = {
                                            json :  {
                                                html : html,
                                                js :  jsContent
                                            },
                                            resolve : buildComponentsResolve,
                                            reject : buildComponentsReject
                                        };                     
                                        multispinnerObj.components.text ='Generating dynamic nodes...';
                                        options.time("dynamicNodes"); 
                                        templateProcessor(options,obj.json,singleFile,function(err,processedTemplate){                        
                                            if(err) {
                                                errorClass.handleErrors(options,returnErrorObject(err),obj.reject,obj.resolve);
                                            } else {
                                                let  dynamicNodesEndTime = options.time("dynamicNodes");
                                                if(options.performance) {
                                                    userLog({msg :"Time to end the dynamic nodes"+dynamicNodesEndTime});
                                                }  
                                                systemLog({msg :"Time to end the dynamic nodes"+dynamicNodesEndTime,type:"INFO",_zl_timestamp: new Date().getTime()});
                                                systemLog({msg :"Generating dist components...\n",type:"INFO",_zl_timestamp : new Date().getTime()});
                                                options.time("processingTemplate");
                                                multispinnerObj.components.text='Generating dist components...';                                                            
                                                let errorInComponent = false;                                             
                                                let writtenFileCount = 0;
                                                let allJsFilesLen = allJsFiles.length;                                   
                                                let writeCallback = function(err){
                                                    writtenFileCount++;
                                                    if(err) {
                                                        errorClass.handleErrors(options,returnErrorObject(err),buildComponentsReject);
                                                    }
                                                    if(writtenFileCount == allJsFilesLen) {
                                                        remove(templateJSONFile,function() {
                                                            systemLog({msg :"Time to end processing template"+options.time("processingTemplate"),type :"INFO",_zl_timestamp: new Date().getTime()});
                                                            if(errorInComponent) {  
                                                                if(strictModeViolation) {
                                                                    buildComponentsReject(new Error("Strict mode violation in the components"));
                                                                } else {
                                                                    if(!options.watch) {
                                                                        buildComponentsReject(new Error('Compilation of components failed'));
                                                                    } else {
                                                                        buildComponentsResolve();
                                                                    }
                                                                }
                                                            } else {
                                                                buildComponentsResolve();  
                                                            }
                                                        });
                                                    }
                                                };
                                                let  writeToDist = function(data,template,sourceJsFile,distJsFile,lyteFile,callback) {                                   
                                                    let indx = 0;
                                                    if(data) {
                                                        let remStr = data.substring((indx = data.indexOf(lyteCompStr)+lenlyteCompStr),data.length);
                                                        indx += remStr.indexOf("{")+1;                                                   
                                                        writeToDistGlobal(data,indx,lyteFile,template,sourceJsFile,distJsFile,callback)
                                                     } else {
                                                        errorClass.handleErrors(options,{
                                                            message : "No data found for js file "+sourceJsFile,
                                                            userLog : userLog,
                                                            systemLog : systemLog,
                                                            _zl_timestamp : new Date().getTime(),
                                                            stack : new Error("No data found for js file "+sourceJsFile).stack
                                                        },buildComponentsReject,callback);
                                                    }
                                                };
                                                let strictModeViolation = false;      
                                                let lyteCompStr = 'Lyte.Component.register(';  
                                                let lenlyteCompStr = lyteCompStr.length;
                                                for(let  key in processedTemplate) {       
                                                    let processedComponent = processedTemplate[key];
                                                    let _componentName = processedComponent.componentName;
                                                    let _template = processedComponent.template;  
                                                    let _errors = processedComponent.errors;
                                                    let _warnings = processedComponent.warnings; 
                                                    let _timeoutError = processedComponent.timeoutError;
                                                    let _jsError = processedComponent.jsError;
                                                    let _jsWarning = processedComponent.jsWarnings;
                                                    let mapList =  mappingList[_componentName]; 
                                                    let jsData = js[_componentName]; 
                                                    
                                                    if(mapList) {
                                                        let sourceJsFile = mapList.js;
                                                        let sourceStyleFile = mapList.css;
                                                        let lyteFileJsPath = mapList.lyteFilePath;  
                                                        let distJsFile = sourceJsFile.replace(srcFolders.javascript,distFolders.javascript);                              
                                                        if(_timeoutError) {
                                                            systemLog({msg :"time out error \n"+_timeoutError,type:"SEVERE"});
                                                        }
                                                        if(_jsWarning) {
                                                            let msg = "Warnings in the component :"+_componentName+"\n";
                                                            msg+="\t\t"+"Invalid component names : "+_jsWarning+"\n";
                                                            errorClass.handleWarnings(options,{
                                                                message : msg,
                                                                tableDisplay : "yes",
                                                                commonContent : "Invalid component data names in the component",
                                                                commonFilePath : relativeSrcFolders.javascript,
                                                                tableContent : [ _componentName, _jsWarning],
                                                                level : 2,
                                                                _zl_timestamp : new Date().getTime(),
                                                                userLog : userLog,
                                                                systemLog : systemLog
                                                            },options.disableLogs);
                                                        }
                                                        if(_jsError) {
                                                            removeTheDistFile(distJsFile);
                                                            writeCallback({message : _jsError.message+" in the file "+sourceJsFile+" at "+_jsError.line+":"+_jsError.column,stack : _jsError.stack,line :_jsError.line,column : _jsError.column,file : sourceJsFile,errMsg : _jsError.message ,sourceCode : jsData});
                                                        } else {                               
                                                            if(_errors) {
                                                                _errors = JSON.parse(_errors);
                                                                errorInComponent = true;
                                                                let stack;
                                                                let messages = "Error in Component : "+_componentName+"\n";
                                                                for(let  errCount = 0,len = _errors.length;errCount < len; errCount++) {
                                                                    if(_errors[errCount].strict == true) { 
                                                                        strictModeViolation = true; 
                                                                    }
                                                                    messages = messages + _errors[errCount].message;
                                                                    
                                                                    stack = _errors[errCount].stack;
        
                                                                    errorClass.handleErrors(options,{
                                                                        file : mapList.html,
                                                                        _zl_timestamp : new Date().getTime(),
                                                                        message : messages,
                                                                        stack : stack,
                                                                        userLog : userLog,
                                                                        systemLog : systemLog
                                                                    },function() {
                                                                        userLog({msg : messages,stack : stack,color:"red"});
                                                                    },function(){
        
                                                                    });     
                                                                    messages = '';                           
                                                                }
                                                                removeTheDistFile(distJsFile);
                                                                writeCallback();
                                                            } else { 
                                                                let template;
                                                                let othertemplateAttr;                                                       
                                                                if(_warnings.length) {
                                                                    let warningMsg = '';
                                                                    warningMsg+= "Warnings in Component :"+_componentName+"\n"
                                                                    for(let  warningCount = 0,warningsLen = _warnings.length;warningCount < warningsLen ; warningCount++) {                                 
                                                                        warningMsg += "\t"+_warnings[warningCount].message+"\n"
                                                                    }
                                                                    errorClass.handleWarnings(options,{
                                                                        message : warningMsg,
                                                                        level : 2,
                                                                        _zl_timestamp : new Date().getTime(),
                                                                        userLog : userLog,
                                                                        systemLog : systemLog
                                                                    },options.disableLogs);
                                                                }
                                                                if(_template) {                       
                                                                    let  _templateAttribute = processedComponent._templateAttributes,
                                                                        _observedAttributes = processedComponent._observedAttributes ||[];
                                                                    othertemplateAttr = "_dynamicNodes : "+JSON.stringify(processedComponent.dynamicNodes)+",\n";
                                                                    if(_templateAttribute) {
                                                                        othertemplateAttr +="_templateAttributes :"+JSON.stringify(_templateAttribute)+',\n';  
                                                                    }
                                                                    if(_observedAttributes.length) {
                                                                        othertemplateAttr += "_observedAttributes :"+JSON.stringify(_observedAttributes)+",\n"
                                                                    }
                                                                    if(includeStyle) {
                                                                        template = '_template:'+JSON.stringify(JSON.parse(_template)+(css[_componentName].length ? "\n<style>"+css[_componentName]+"</style>" : ''))+",\n";                                                                                 
                                                                        writeToDist(jsData,template+othertemplateAttr,sourceJsFile,distJsFile,lyteFileJsPath,writeCallback)
                                                                    } else {
                                                                        template = '_template:'+_template+",\n";
                                                                        let destStylePath = sourceStyleFile.replace(srcFolders.styles,distFolders.styles);
                                                                        mkdir(path.parse(destStylePath).dir,function(err) {
                                                                            if(err) {
                                                                                errorClass.handleErrors(options,returnErrorObject(err),buildComponentsReject,writeCallback);
                                                                            } else {
                                                                                write(destStylePath,css[_componentName],function(){
                                                                                    writeToDist(jsData,template+othertemplateAttr,sourceJsFile,distJsFile,lyteFileJsPath,function(err) {
                                                                                        if(transpileOpt) {
                                                                                            let es6StylePath = destStylePath.replace(distFolders.copyAppDir,options.es6Path);
                                                                                            mkdir(path.parse(es6StylePath).dir,function(err) {
                                                                                                if(err) {
                                                                                                    errorClass.handleErrors(options,returnErrorObject(err),reject,writeCallback);
                                                                                                } else {
                                                                                                    write(es6StylePath,css[_componentName],writeCallback);
                                                                                                }
                                                                                            });
                                                                                        } else {
                                                                                            writeCallback(err);
                                                                                        }
                                                                                    });  
                                                                                });
                                                                            }
                                                                        });
                                                                    }
                                                                }                                                         
                                                            } 
                                                        } 
                                                    }                                                                     
                                                }                                                               
                                            }    
                                        }); 
                                    }
                                    let  endTimeUnclosedTags = options.time("unclosedTags");                 
                                    if(options.performance) {
                                        userLog({msg : "Time difference to find unclosedTags "+endTimeUnclosedTags});                                    
                                    }  
                                    systemLog({msg :"Finding the unclosed tags compilation over",type :"INFO",_zl_timestamp: new Date().getTime()});                                                                               
                                    systemLog({msg :"[Time] => find unclosedTags => "+endTimeUnclosedTags,type:"INFO",_zl_timestamp : new Date().getTime()}) 
                                    systemLog({msg :"Running compilerule ...",type :"INFO",_zl_timestamp : new Date().getTime()});        
                                    multispinnerObj['components'].text='Compiling components files...';            
                                    options.time("lyteSyntax");
                                    let  report;
                                    let  compileRuleCallbackFn = function() {
                                        let  lyteSyntaxTime = options.time('lyteSyntax');
                                        if(options.performance) {
                                            userLog({msg : "Time difference to convert Lyte syntax => "+lyteSyntaxTime})                                                              
                                        }
                                        systemLog({msg :"[Time] => Convert Lyte syntax => "+lyteSyntaxTime,type :"INFO",_zl_timestamp: new Date().getTime()});                           
                                        read(templateJSONFile,'utf-8',function(err,data){
                                            if(!err) {
                                                let  processedTemplateContent = JSON.parse(data);
                                                fileManipulation.merge_object(html,processedTemplateContent);
                                            }
                                            processTheTemplateFn();
                                        });
                                          
                                    }                                  
                                    if(functionSyntax.length != 0) {  
                                        let  eslintRule;
                                        let define = function(jsonObj,lastRule) {
                                            return (new CLIEngine({
                                                useEslintrc: false,
                                                rulePaths : [path.join(options.cliRoot,'lib','rules','compilerule')],
                                                rules: {
                                                    compilerule : [2,distFolders.copyAppDir,jsonObj,lastRule] 
                                                },
                                                allowInlineConfig : false,
                                                envs :["es6"]
                                            }));
                                        }
                                        eslintRule = define({},true);
    
                                        report = eslintRule.executeOnText(functionSyntax);
                                  
                                        if(report.errorCount) {                           
                                            let  name;                       
                                            let  splitfiles = functionSyntax.split('/*--System generated component concatenation')
                                            splitfiles.forEach(function(content,index){
                                                if(index != 0 ) {                                    
                                                    name = content.split("---*/")[0].replace(' ','');   
                                                    fileManipulation.mkdirSync(path.parse(name).dir,{recursive : true});
                                                    writeSync(name,content.split("---*/")[1],true)
                                                }
                                            });
                                            let errStack = [];
                                            let msg ='';
                                            let lintReport;
                                            let formatter = eslintRule.getFormatter('codeframe');
                                            let errorHandling = function(reports)  {
                                                let report =  reports.results;
                                                fileManipulation.merge_array(errStack,report)
                                                msg+=formatter(report)+"\n"; 
                                            }
                                            if(file) {  
                                                let  fileObj = path.parse(file);
                                                let mapOfFile = mappingList[fileObj.name];
                                                parsingPath = [mapOfFile.lyteFilePath]
                                                let distPath = mapOfFile.js.replace(jsSrcPath,jsDistPath);
                                                if(fileManipulation.fileExist(distPath)) {
                                                    if(distPath.indexOf(jsDistPath) != -1) {
                                                        removeTheDistFile(distPath)
                                                    }
                                                }
                                            } else {
                                                let fileList = fileManipulation.getFilesListSync(jsDistPath);
                                                fileList = fileList.map(function(file) {
                                                    if(file.includes('_lyte.js')) {
                                                        return file;
                                                    } else {
                                                        return '';
                                                    }
                                                })
                                                parsingPath = fileList;                            
                                            }
                                            eslintRule = define({},false);
                                            lintReport = eslintRule.executeOnFiles(parsingPath.shift());
                                            if(lintReport.errorCount) {
                                                errorHandling(lintReport);
                                            }
                                            if(parsingPath.length) {
                                                let lastFile = parsingPath.pop();
                                                eslintRule =  define(undefined,undefined);
                                                lintReport = eslintRule.executeOnFiles(parsingPath);
                                                if(lintReport.errorCount) {
                                                    errorHandling(lintReport);
                                                }
                                                eslintRule = define(undefined,true);
                                                lintReport = eslintRule.executeOnFiles(lastFile);
                                                if(lintReport.errorCount) {
                                                    errorHandling(lintReport)
                                                }
                                            }
                                            if(msg.length) {
                                                errorClass.handleErrors(options,{message : msg,stack : new Error('').stack,errMsg  : errStack,userLog : userLog,systemLog : systemLog,_zl_timestamp : new Date().getTime()},buildComponentsReject);                                                     
                                            }
                                            compileRuleCallbackFn();
                                        } else {
                                            compileRuleCallbackFn();                                                                                                       
                                        }                       
                                    } else {
                                        systemLog({msg :"[Time] => Convert Lyte syntax => "+options.time('lyteSyntax'),_zl_timestamp : new Date().getTime(),type :"INFO"})                                      
                                        processTheTemplateFn();                               
                                    }                             
                                }
                            }
                    }
                    if(superOptions) {
                        file = superOptions.file;
                        includeStyle = superOptions.includeStyle;
                        modification = superOptions.modification;
                        beforeCompilation = superOptions.beforeCompilation;
                        afterCompilation = superOptions.afterCompilation;
                    } 
                    options.includeStyle = includeStyle;
                    let  name,dir,ext;  
                    if(!file) {    
                        let  jsFileObj;     
                        let processComponentJs = function() {
                            getFilesList(jsSrcPath,null,function(err,items){
                                if(err) {
                                    if(err.message.indexOf('No such file or directory') != -1) {
                                        buildComponentsResolve();
                                    } else {
                                        errorClass.handleErrors(options,returnErrorObject(err),buildComponentsReject,buildComponentsResolve);
                                    }
                                } else {
                                    if(!allJsFiles.length) { /*no components file exist .gitkeep files there*/
                                        buildComponentsResolve();
                                    } else {                               
                                        options.time("generateDistTemplates");
                                        generateDistTemplates(mappingList);  
                                    }
                                }
                            },function(jsFile) {
                                jsFileObj = path.parse(jsFile);
                                name = jsFileObj.name;
                                ext = jsFileObj.ext;
                                dir = jsFileObj.dir;
                                if(ext == '.js') {
                                    if(!mappingList[name]) {
                                        mappingList[name] = {
                                            html : path.join(dir.replace(jsSrcPath,templateSrcPath),name+'.html'),
                                            js : jsFile,
                                            css : path.join(dir.replace(jsSrcPath,styleSrcPath),name+'.css'),
                                            lyteFilePath : path.join(dir.replace(jsSrcPath,jsDistPath),name+'_lyte.js')
                                        };
                                        html[name] = '';
                                        js[name] = '';
                                        css[name] = '';
                                        allJsFiles.push(jsFile);  
                                    } else {
                                        let err = new Error("Component name :"+name+"already registered");
                               
                                        errorClass.handleErrors(options,returnErrorObject(err),buildComponentsReject);
                                    }
                                }
                            });
                        }   
                        if(fileExist(imageSrcPath)) {
                            _cliCopyFolder(options,{src : imageSrcPath,dist : imageDistPath},function(){
                                processComponentJs();
                            });   
                        } else {
                            processComponentJs();
                        }
                    } else {
                        let  fileObj,dirName;
                            fileObj = path.parse(file);
                            name = fileObj.name;           
                            dir = fileObj.dir;
                            ext = fileObj.ext;
                            dirName = path.join(dir,name);
                        if(ext) {
                            if(dir.indexOf(imageSrcPath) != -1) {
                                _cliCopyFile(options,{
                                    src: file,
                                    dist : file.replace(imageSrcPath,imageDistPath)
                                },function(){
                                    buildComponentsResolve();
                                });
                                return;                
                            }
                            singleFile = file; 
                            let deleteErrorObj = function(files){
                                files.forEach(function(file){
                                    if(options.errorObj[file]) {
                                        delete options.errorObj[file];
                                    }
                                });
                            };            
                            if(modification == "added") {                                               
                                allJsFiles  = [(dirName+'.js').replace(templateSrcPath,jsSrcPath).replace(styleSrcPath,jsSrcPath)]                   
                                mappingList[name] = {
                                    html : (dirName+'.html').replace(jsSrcPath,templateSrcPath).replace(styleSrcPath,templateSrcPath),
                                    js : allJsFiles[0],
                                    css  : (dirName+'.css').replace(jsSrcPath,styleSrcPath).replace(templateSrcPath,styleSrcPath),
                                    lyteFilePath : (dirName+'_lyte.js').replace(jsSrcPath,jsDistPath)
                                };                                            
                            } else if(modification == "changed"){ // javascript changes in file
                                var lyteFile;
                                if(ext == '.js') {                               
                                    allJsFiles = [file];
                                    htmlFile =  (dirName+'.html').replace(jsSrcPath,templateSrcPath);
                                    cssFile = (dirName+'.css').replace(jsSrcPath,styleSrcPath);
                                    lyteFile = (dirName+'_lyte.js').replace(jsSrcPath,jsDistPath);
                                    deleteErrorObj([file,htmlFile,cssFile,lyteFile]);
                                    mappingList[name] = {
                                        html : htmlFile,
                                        js : allJsFiles[0],
                                        lyteFilePath : lyteFile,
                                        css : cssFile
                                    };                                                               
                                } else if(ext == ".html") { //templates changes in file
                                    allJsFiles = [(dirName+'.js').replace(templateSrcPath,jsSrcPath)];
                                    let cssFile = (dirName+'.css').replace(templateSrcPath,styleSrcPath);
                                    lyteFile = (dirName+'_lyte.js').replace(templateSrcPath,jsDistPath);
                                    deleteErrorObj([allJsFiles[0],file,cssFile,lyteFile]);
                                    mappingList[name] = {
                                        html : file,
                                        js : allJsFiles[0],
                                        lyteFilePath : lyteFile,
                                        css : cssFile
                                    };  
                                } else if(ext == ".css") { //Styles changes in file 
                                    let  destStylePath = file.replace(styleSrcPath,distFolders.styles),
                                        destJsPath =(dirName+'.js').replace(styleSrcPath ,jsDistPath);                 
                                        let cssStr = readSync(file,'utf8');
                                        if(!includeStyle) {
                                            deleteErrorObj([file]);
                                            mkdir(path.parse(destStylePath).dir,function(err){
                                                options.fileContent[destStylePath] = cssStr;
                                                write(destStylePath,cssStr,function() {
                                                    if(options.transpile) {
                                                        let transpilePath = destStylePath.replace(distFolders.copyAppDir,options.es6Path);
                                                        options.fileContent[transpilePath] = cssStr;
                                                        write(transpilePath,cssStr,function(){
                                                            buildComponentsResolve();
                                                        });
                                                    } else {
                                                        buildComponentsResolve();
                                                    }
                                                });
                                            });
                                            return;   
                                        } else if(fileExist(destJsPath)){
                                            deleteErrorObj([file]);
                                            let replaceStr = function(str) {
                                                if(str.indexOf("<template") != -1) {
                                                    if(str.lastIndexOf("<style>")!=-1) {
                                                        let  replaceContent =str.substring(str.lastIndexOf("<style>")+"<style>".length,str.lastIndexOf("</style>"));                                                       
                                                        if(replaceContent) {
                                                            str = str.replace(replaceContent,JSON.stringify(cssStr).replace(/"/,'').replace(/"$/,''));
                                                        
                                                        } else {
                                                            str = str.substring(0,str.lastIndexOf("<style>")+"<style>".length)+JSON.stringify(cssStr).replace(/"/,'').replace(/"$/,'')+str.substring(str.lastIndexOf("</style>"));
                                                        }
                                                    } else {
                                                        str = str.substr(0,str.lastIndexOf('</template>')+'</template>'.length) + JSON.stringify("<style>"+cssStr+"</style>").replace(/"/,'').replace(/"$/,'') + str.substr(str.lastIndexOf('</template>')+'</template>'.length);
                                                    }
                                                }
                                                return str;
                                            };
                                            let str = readSync(destJsPath,'utf-8');
                                            str = replaceStr(str);
                                            write(destJsPath,str,function(){
                                                options.fileContent[destJsPath] = str;
                                                if(options.transpile) {
                                                    let transpilePath  =  destJsPath.replace(distFolders.copyAppDir,options.es6Path);
                                                    let transpilePathContent = readSync(transpilePath,'utf-8');
                                                    transpilePathContent = replaceStr(transpilePathContent);
                                                    write(transpilePath,transpilePathContent,function(){
                                                        options.fileContent[transpilePath] = transpilePathContent;
                                                        buildComponentsResolve();
                                                    });
                                                } else {
                                                    buildComponentsResolve();
                                                }
                                            });
                                            return;   
                                        } else {
                                            allJsFiles = [(dirName+'.js').replace(styleSrcPath,jsSrcPath)];
                                            let htmlFile = (dirName+'.html').replace(styleSrcPath,templateSrcPath);
                                            lyteFile = (dirName+'_lyte.js').replace(styleSrcPath,jsDistPath);
                                            deleteErrorObj([htmlFile,allJsFiles[0],lyteFile,file]);
                                            mappingList[name] = {
                                                html : htmlFile,
                                                js :  allJsFiles[0],
                                                lyteFilePath : lyteFile,
                                                css : file
                                            };
                                        }              
                                }
                            } else if(modification == "deleted"){
                                if(ext == '.js'){  /*deleting the js file*/
                                    /*warning about the deletion of the js file manually*/
                                    deleteErrorObj([file]);
                                    let  templateFile = (dirName+'.html').replace(jsSrcPath,templateSrcPath);
                                    //styleFile = path.join(dir.replace(jsSrcPath,styleSrcPath ),fileObj.name+'.css')
                                    if(fileExist(templateFile)){
                                        errorClass.handleWarnings(options,{
                                            message :"Warning "+file+" deleted manually",
                                            level : 2,
                                            userLog : userLog,
                                            _zl_timestamp : new Date().getTime(),
                                            systemLog : systemLog
                                        },options.disableLogs);
                                    }
                                    file = file.replace(jsSrcPath,jsDistPath);
                                    systemLog({msg : "[Watch] "+path.relative(srcCopyAppDir,file)+"deleted",type :"INFO",timstamp : new Date().getTime()});
                                    removeTheFiles(file);
                                    buildComponentsResolve();
                                    return;
                                } else if(ext == '.html') { /*deleting the html file & set the _template and _dynamicNodes to undefined */
                                    file = (dirName+'.js').replace(templateSrcPath,jsSrcPath).replace(jsSrcPath,jsDistPath);
                                    deleteErrorObj([file]);
                                    systemLog({msg : "[Watch] "+path.relative(srcCopyAppDir,file)+"deleted",type :"INFO",_zl_timestamp : new Date().getTime()});
                                    removeTheFiles(file);
                                    buildComponentsResolve();
                                    return;
                                    /*remove the html content from processedTemplateContent file*/
                                                        
                                } else if(ext == '.css') { /*deleting the css file*/
                                    
                                    if(includeStyle) { 
                                        // delete all the files
                                        let  templateFile = (dirName+".html").replace(styleSrcPath ,templateSrcPath);                   
                                        allJsFiles = [(dirName+".js").replace(styleSrcPath ,jsSrcPath)];
                                        mappingList[name] = {
                                            html : templateFile,
                                            js : allJsFiles[0],
                                            lyteFilePath : (dirName+'_lyte.js').replace(jsSrcPath,jsDistPath),
                                            css : file
                                        }; 
                                    } else {
                                       // delete the css file alone
                                        let distCssFile =  file.replace(srcFolders.styles,distFolders.styles)
                                        if(fileExist(distCssFile)) {
                                            systemLog({msg :"[Watch] "+path.relative(srcCopyAppDir,distCssFile)+"deleted",type : "INFO",_zl_timestamp : new Date().getTime()})
                                            removeTheFiles(distCssFile);
        
                                        }
                                        if(options.transpile) {
                                            if(fileExist(distCssFile = distCssFile.replace(distFolders.copyAppDir,options.es6Path))) {
                                                systemLog({msg : "[Watch] "+path.relative(srcCopyAppDir,distCssFile)+"deleted",type : "INFO",_zl_timestamp : new Date().getTime()})                                
                                                removeTheFiles(distCssFile);
                                            }
                                        }
                                        buildComponentsResolve();
                                        return;
                                    }                       
                                }
                            }
                        }  else {
                            if(modification!="deleted") {
                                fileManipulation.mkdirSync(file.replace(srcFolders.copyAppDir,distFolders.copyAppDir)); //wanna check this case ?      
                            } else {
                                removeSync(file.replace(srcFolders.copyAppDir,distFolders.copyAppDir),true)
                            }
                        }
                        options.time("generateDistTemplates");       
                        generateDistTemplates(mappingList);
                    }       
                    
                } catch(e){
                    buildComponentsReject(e);
                }
            });
        },
        clear : function() {
            // let processedTemplateContentJsonPath = path.join(distFolders.copyAppDir,"build","processedTemplateContent.json")
            // if(fileExist(processedTemplateContentJsonPath)) {
            //     removeSync(processedTemplateContentJsonPath,true);
            // }
            let eslintrcCacheFile = path.join(options.folders.src.copyAppDir,".eslintcache") ;
            if(fileExist(eslintrcCacheFile)){
                removeSync(eslintrcCacheFile,true);
            }
        },
        dirNameSpaceHandler : function(dir) {
            if(os=='win32'){
                dir="\""+dir+"\"";
            } else {
                dir = dir.replace(/(?=[() ])/g,'\\')
            }
            return dir;
        }
    }
    process.setMaxListeners(0);
    handleSignals();
    
module.exports = buildUtils;


