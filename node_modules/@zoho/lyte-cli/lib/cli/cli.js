let req = require;
global.required = {};
global.defaultReq = req;
global.require = function(name){
    if(!global.required[name]){
        try {
            global.required[name] = req(name);
        } catch(e) {
            if(e.message.indexOf("Cannot find module") != -1) {
                if(process.env.PRODUCTION) {
                    throw new Error("Missing dependencies "+name+".\nInstall the dependencies of lyte-cli that need for development mode");
                } 
                throw e;
            } 
            throw e;
        }
    }
    return global.required[name];
};
require = global.require;
let path = require("path");
let pathRelativeFn = path.relative;
let pathParseFn = path.parse;
path.relativeCache = {};
let isAbsolute = path.isAbsolute;
path.relative = function(src,dist) {
  if(!path.relativeCache[src+dist]) {
    path.relativeCache[src+dist] = pathRelativeFn(src,dist);
  }  
  return path.relativeCache[src+dist];
};
path.parseCache = {};
path.parse = function(value) {
    if(!path.parseCache[value]) {
      path.parseCache[value] = pathParseFn(value);
    } 
    return path.parseCache[value];
};
path.isAbsolute = function(filePath) {
    return isAbsolute(filePath);
};
function CLI(options) {
    let utils = require("@zoho/lyte-cli-utils"),
        fileManipulation = utils.fileManipulation,
        commonCliUtils = utils.commonCliUtils;
    options.systemLogsObj = [];
    options.systemLogs = '';
    options.pushTheLog = [];

   // options.localCliLocation = path.join(process.env[(process.platform == 'win32') ? 'USERPROFILE' : 'HOME'],".lyte");
    options.log = {
        system : function(obj) { 
            options.systemLogsObj.push(obj);
            options.systemLogs += obj.msg + "\n";
        }
    };
    let userLog = function(obj) { 
        console.log(obj.msg+'\n'+obj.stack ? obj.stack : '')
    };
    let systemLog = options.log.system;
    let command;
    let fromCommandLine = options.fromCommand; 
    if(fromCommandLine == undefined) {
        fromCommandLine  = true; /*remove tis in next version */
    } else {
        options.cliRoot = path.join(__dirname,"..","..");
    }
    let writeToLog = function(options) {
        var logPath = options.logPath;
        if(logPath) {
            let  dir = path.parse(logPath).dir;
            if(!fileManipulation.fileExist(dir)) {
                fileManipulation.mkdirSync(dir);
            }
            fileManipulation.writeSync(logPath,options.systemLogs); 
            options.systemLogs = '';
        }
        if(options.eslint) {
            var eslintLogs = options.eslintLogContent;
            if(eslintLogs) {
                if(eslintLogs.length > 1000) {
                    fileManipulation.writeSync(options.eslintLogFile,options.eslintLogContent)
                } else {
                    userLog({msg : eslintLogs});    
                }
            }
           
            options.eslintLogContent='';
        }
    }
    
    return new Promise(function(resolve,reject){
        let appPath = options.root;
        let packageConfig = JSON.parse(fileManipulation.readSync(path.join(options.cliRoot,"package.json"),'utf-8'));
        packageConfig.productionScope && (process.env.PRODUCTION = true);
        options.cliVersion = packageConfig.version;
        if(appPath.includes('[') || appPath.includes(']')) {
            throw new Error("File path do not contain the characters [");
        }
        let buildFilePath;
        let buildFileObj;
        let commands = {
            version : "version",    
            build : "build",
            new : "new",
            help : "help",
            replace : "replace",
            rename : "rename",
            generate : "generate",g : "generate",
            destroy : "destroy",d : "destroy",
            server : "server",serve : "server",
            migrate : "migrate",
            test : "test",
            fix : "fix",
            loc : "location",location : "location",
            install : "install",
            output :"output",
            lint : "lint",
            add : "add",
            remove : "remove"
        },
        actions = {};
        options.path = path;
        
        options.resolve = resolve;
        options.reject = reject;
        options.minifyCount = 0;
        options.moduleList = ["route","component","helper","model","adapter","mixin","serializer","test","theme","blueprint","service"]
                    
        let defineSpinner = function() {
            try {
                options.ui = new utils.cliSpinner({ production : options.production,nospinner : options.nospinner})
                options.log.user = function(obj,callback) {                       
                    if(typeof obj == "object") {
                        obj.callback = callback;
                        options.ui.startSpinner(obj,options);           
                    } else {               
                        options.ui.startSpinner({msg : obj},options);            
                    }           
                
                }
                userLog = options.log.user;
            } catch(e) {
                throw e;
            }
        }
        options.errorCount = 0;
        options.warningsCount = 0;
        options.buildVersion = 1;        
        options.consoleTime = {};
        options.time = function(fn) {
            let end,
                consoleTime = options.consoleTime;
            if(end = consoleTime[fn]) {
              delete consoleTime[fn];
              return ((new Date().getTime()-end)/1000)+" s";
            } else {
              consoleTime[fn] = new Date().getTime();
            }
        };
    
        function getParams() { 
            let cliArgs = [],
                hyphen,
                nextCliArgs,
                param;
            let defineProperty = function(property) { /*giving preference to cli arguments options */
                let value;
                Object.defineProperty(options,property,{
                    get() {
                        return value;
                    },
                    set(newValue) {
                        if(!value) {
                            value = newValue;
                        }
                    }
                });
            };
            for(let argLen = options.cliArgs.length,i = 0;i < argLen;) {
                param = options.cliArgs[i];
                if(param && ((param.indexOf('--') == 0) || (hyphen = param.indexOf('-') == 0))) {
                    param = param.substring(hyphen ? 1 : 2,param.length);
                    if(param.indexOf('=') != -1) {
                        let split = param.split('=');
                        let propertyVal = split[1];
                        defineProperty(split[0]);
                        if(propertyVal == "true" || propertyVal == "false") {
                          propertyVal = JSON.parse(propertyVal);
                        } 
                        options[split[0]] = propertyVal;
                    } else if((nextCliArgs = options.cliArgs[i+1]) && (nextCliArgs.indexOf('--') != 0 && nextCliArgs.indexOf('-') != 0)) {
                        defineProperty(param);
                        options[param] = options.cliArgs[i+1];
                        i++;
                    } else {
                        defineProperty(param);
                        options[param] = true;
                    }
                } else {
                    cliArgs.push(param); 
                }
                i++;
                hyphen=false;
            }
            options.cliArgs = cliArgs;
        }
        //if(options.commandLineArgsProcessed) { /* temporary comment */
        getParams();
        //}
        options.disableLogs = options.disableLogs == undefined ? false :  options.disableLogs;
        options.showReleventCommand = function(term,commands) {
            if(process.env.PRODUCTION) {
                userLog({msg :'Not a valid lyte command.',color : 'red'});
            } else {
                let compare = term.toLowerCase(),
                    fusecommands = [],
                    Fuse = require("fuse.js"),
                    fuse,
                    result;
                let fuseOptions = {
                        shouldSort: true,
                        threshold: 0.4,
                        location: 0,
                        distance: 400,
                        maxPatternLength: 15,
                        minMatchCharLength: 1,
                        keys: [
                            "commandname"
                        ]
                    };
                function checkAndAdd(name) {
                    let found = fusecommands.some(function (el) {
                        return el.commandname === name;
                    });
                    if (!found) { 
                        fusecommands.push({ commandname : commands[command] || name}); 
                    }
                }
                for(let command in commands) {
                    checkAndAdd(commands[command] || command);
                }
                fuse = new Fuse(fusecommands,fuseOptions);
                result = fuse.search(compare);
                if(result.length) {
                    result.forEach(function(command,index) {
                        if(index == 0) {
                            let msg = 'Did you mean ?';
                            userLog({msg : msg, color : 'red'});
                        }
                        userLog({msg : '\t'+command.commandname,color : 'red'});
                    });
                } else {
                    userLog({msg : 'Not a valid lyte command.',color : 'red'});
                }
                return result;
            }
        };
        function getBuildOptions(command,callback) {
            try {                      
                let appBuildVersion;                 
                buildFilePath = path.join(appPath,"build","build.js");                    
                if(fileManipulation.fileExist(buildFilePath)) {
                    let setAllVariables = function() {
                        try {
                            buildFileObj.configureFolders(options);                        
                            if(options.outputFolder == path.sep) {   
                                throw new Error("Invalid outputFolder");  
                            } else {   
                                // debugger;               
                                let outputPath = options.outputFolder;
                                if(!path.isAbsolute(outputPath)) {
                                    outputPath  =  path.join(appPath,outputPath)
                                }
                                if(options.inapp || options.addons || options.engines) {
                                    options.outputFolder = outputPath+'@overwrite';
                                    options._appOutputFolder = options.outputFolder;
                                } else {
                                    options._appOutputFolder = outputPath;
                                }                
                            }
                        } catch(e) {
                            if(!options.outputFolder) {
                                throw new Error('Resulting undefined for outputFolder options. Property outputFolder not defined');
                            } else {
                                throw e;
                            }
                        }
                        let srcFolders = options.folders.src;
                        let distFolders = options.folders.dist; 
                        srcFolders.copyAppDir = srcFolders.copyAppDir || appPath;
                        distFolders.copyAppDir = distFolders.copyAppDir || options._appOutputFolder;
                        srcFolders.themes = srcFolders.themes || path.join(srcFolders.copyAppDir,"css");
                        distFolders.themes = distFolders.themes || path.join(distFolders.copyAppDir,"css");
                        srcFolders.build = srcFolders.build || path.join(srcFolders.copyAppDir,"build");
                        distFolders.build = distFolders.build || path.join(distFolders.copyAppDir,"build");
                        srcFolders.rules = srcFolders.rules || path.join(srcFolders.copyAppDir,"rules"); 
                        distFolders.rules = distFolders.rules || path.join(srcFolders.copyAppDir,"rules"); 
                        srcFolders.services = srcFolders.services || path.join(srcFolders.copyAppDir,"services"); 
                        distFolders.services = distFolders.services || path.join(srcFolders.copyAppDir,"services"); 
                        options.logPath = path.join(options._appOutputFolder,'build','log.txt');
                        options.development = !options.production;
                        callback();
                    };
                    buildFileObj = require(buildFilePath); 
                    appBuildVersion = buildFileObj.version;
                    buildFileObj.addon ? (options.addons = true,options.appName="addon") : (buildFileObj.engine ? (options.engines = true,options.appName="engine") :  (buildFileObj.widget ? (options.widget=true,options.appName="widget") :options.app = true ));
                    if(appBuildVersion == options.buildVersion) {                      
                        if(options.addons || options.engines) {
                            if(options.sourceMap != undefined) {
                                let valueSourceMap = options.sourceMap;
                                Object.defineProperty(options,'sourceMap', {
                                    get() {
                                        return valueSourceMap;
                                    },
                                    set(newValue) {
                                        
                                    }                         
                                });
                            }
                            if(!options.inapp) {
                                if(command == "build" || command == "server") {
                                    var testAppPath = path.join(appPath,"testApp");
                                    let packageJSON = path.join(appPath,"package.json");
                                    fileManipulation.read(packageJSON,'utf-8',function(err,packageJSONContent) {
                                        if(err) {
                                            callback(new Error("No package.json file in the addons"));
                                        } else {
                                            packageJSONContent = JSON.parse(packageJSONContent);
                                            if(fileManipulation.fileExist(testAppPath)) {
                                                options.appName = undefined;
                                                if(options.addons) {
                                                    options.addons = false;
                                                    options.buildAddonsTestApp = true;
                                                } else {
                                                    options.engines = false;
                                                    options.buildEnginesTestApp = true;
                                                }                                                                              
                                                options.addonsOrEnginesToBeWatched = packageJSONContent.name;
                                                options.root = appPath = testAppPath;
                                                buildFilePath = path.join(appPath,"build","build.js");
                                                buildFileObj = require(buildFilePath);
                                                setAllVariables();
                                            } else {
              
                                                var value = options.outputFolder;
                                                let rootOb = packageJSONContent.name;
                                                Object.defineProperty(options,"outputFolder",{
                                                    get() {
                                                        return value;
                                                    },
                                                    set(newValue) {
                                                        if(newValue.indexOf("@overwrite") != -1) {
                                                            value = newValue.split('@overwrite')[0];
                                                        } else  {
                                                            if(options.addons) {
                                                                value = path.join("addons",rootOb,newValue);
                                                            } else {
                                                                value = path.join("engines",rootOb,newValue);
                                                            }
                                                        }
                                                    }
                                                })
                                                setAllVariables();
                                            }
                                        }
                                    });
                                } else {
                                    setAllVariables();
                                }
                            } else {    
                                let value = options.outputFolder;                      
                                Object.defineProperty(options,'outputFolder',{
                                    get() {
                                        return value;
                                    },
                                    set(newValue) {
                                        if(newValue.indexOf("@overwrite") != -1) {
                                            value = newValue.split('@overwrite')[0];
                                        } else {
                                            if(options.addons || options.engines) {                                                                                                                                                                                                                                          
                                                value = path.join(options.addToPath,newValue);                                   
                                            } else {
                                                value = newValue;
                                            }
                                        }

                                    }
                                });
                                setAllVariables();
                            }                            
                        } else {
                            setAllVariables();
                        }
                    } else {            
                        throw new Error('Old version of build.js .\nCheck the new version of build.js at '+path.join(options.cliRoot,'blueprints',"app","build","build.js"));        
                    }  
                } else {
                    throw new Error("Specified path doesn't contain the build configuration file");
                }
            } catch(e) {
                throw e;
            }
        }
        function processKillPrompt(pid,msg){
            if(!options.processKilled){
                let promp = fileManipulation.prompt(msg,'red');
                if(promp){
                    let val = process.kill(pid);
                    return val;
                } else {
                    process.exit(2);
                }
            }
        }
        function checkAlreadyRunning(type){
            let killPid;
            try{    
                let confObj = {};
                let confPath = path.join(options._appOutputFolder,"build","buildConf.json"); 
                let _appOutputFolder = options._appOutputFolder;
                if(fileManipulation.fileExist(confPath)) {
                    let content = fileManipulation.readSync(confPath,'utf-8');
                    if(content.length!=0) {
                        confObj = JSON.parse(content);
                        if(confObj.port && type == "build"){
                            delete confObj.port;
                        }
                        killPid = confObj[appPath];
                        if(killPid)  {
                            let os = process.platform;
                            let stdout;
                            let execSync = require("child_process").execSync;
                            let msg='Do you want to kill the already running lyte process for the same folder.[Y/N]:';
                            try {
                                if(os == "win32") {
                                    stdout =execSync("tasklist /FI \"PID eq "+killPid+"\"").toString().trim();
                                    if(stdout != "INFO: No tasks are running which match the specified criteria."){
                                        processKillPrompt(killPid,msg);
                                    }  
                                } else {
                                    stdout = execSync("ps -ax | grep \"lyte\"|grep -v grep").toString().trim();
                                    let task = stdout.split("\n");
                                    task.forEach(function(proc){
                                        let p=proc.trim().split(/[ ]+/g);                              
                                        if(p[0]==killPid){
                                            processKillPrompt(killPid,msg);
                                        }
                                    }); 
                                }
                            } catch(e) {
                                let stdout = e.stdout;
                                if(stdout) { 
                                    if(stdout.toString().length) {
                                        throw(e);
                                    }
                                } else {
                                    throw(e);
                                }
                            } 
                        }
                    } 
                    //fileManipulation.removeSync(confPath,true);                  
                } //else {
                    fileManipulation.removeSync(_appOutputFolder,true);
                //}
                // let lyteCliMtime = fileManipulation.lstatSync(options.cliRoot).mtime,
                //     buildFileMtime = fileManipulation.lstatSync(path.join(options.folders.src.build,"build.js")).mtime,
                //     opFolderMtime;
                // if(fileManipulation.fileExist(_appOutputFolder)) {
                //     opFolderMtime = fileManipulation.lstatSync(_appOutputFolder).mtime;
                //     if(lyteCliMtime > opFolderMtime || buildFileMtime > opFolderMtime) { 
                //         fileManipulation.removeSync(_appOutputFolder,true);                            
                //     }        
                // }
                confObj.type= "development";          
                confObj[appPath]=process.pid;
                options.buildCacheObj = confObj;
                // fileManipulation.mkdirSync(path.parse(confPath).dir);
                // fileManipulation.writeSync(confPath,JSON.stringify(confObj));
            } catch(e){
                if(e.message && e.message.includes("kill")) {
                   throw new Error("Your build is already running in your machine in the process id ."+killPid+"\nKill the process manually using the command 'kill -9 "+killPid+"'");
                } else if(e.stack && e.stack.includes('SyntaxError') || e.message && e.message.indexOf("SyntaxError") != -1){ /*if error in buildConf.json */
                    fileManipulation.removeSync(_appOutputFolder,true);
                    options.deleteCache=true;
                } else {
                    throw(e);
                } 
            }
        }    
        
        command = options.cliArgs[0]  ? (commands[options.cliArgs[0]] || options.cliArgs[0]) :((options.v || options.version) ? commands.version : commands.help);
        options.command = command;
        
        let resolveFn = function(options,sane) {
            if(options.watch) { 
                resolve(options);   
                let addWatch = options.addWatchFn;                     
                addWatch(options,sane);                                                  
            } else {
                if(options.chromiumBrowser) {
                    options.chromiumBrowser.close().then(function(){
                        resolve(options);
                    }).catch(function(err) {
                        reject(err);
                    });
                } else {
                    resolve(options);     
                }                         
            }
        }
        
        switch(command) {
            case 'build':           
                commonCliUtils.tryCatch(function() {
                    options.fileContent = {}; 
                    getBuildOptions('build',function(err) { 
                        if(err){
                            reject(err);
                        } else {
                            defineSpinner();                             
                            let sane;  
                            options.ui.startSpinner({module :"build",msg :"Building the module ",color :"green"},options); 
                            if(options.production) {
                                if(options.watch) {
                                    throw(new Error("Lyte watch not supported in production mode"));
                                }
                                if(options.debug) {
                                    throw(new Error("Debug mode for lyte build not supported in production mode"))
                                }
                                if(!options.inapp) {
                                    console.log("Building ..........");
                                }
                                sane = {};   
                            } else {
                                sane = require("sane");       
                                checkAlreadyRunning("build"); 
                            }                                                                                                                                                              
                            let fs = require("fs");
                            actions.build = buildFileObj.build;                           
                            actions[command](options,{fs,sane}).then(function(){    
                                fileManipulation.append(options.logPath,options.systemLogs,function() {        
                                    options.multispinner.spinners.build.text= 'building completed';                      
                                    if(!options.inapp) {                        
                                        resolveFn(options,sane);
                                    } else {
                                        systemLog({msg : "Build sucesss",type :"INFO","_zl_timestamp": new Date().getTime()});
                                        resolve(options); 
                                    }     
                                });          
                            }).catch(function(e) {
                                reject(e);                      
                            });
                        }
                    });
                });     
                break;
                
            case 'server':
                commonCliUtils.tryCatch(function() {
                    let killProcessByPort = function(port){
                        let result;
                        let val;
                        let os=process.platform;
                        let execSync = require("child_process").execSync;
                        try{
                            if(os == "win32"){           
                                result =execSync('netstat -a -n -o | findstr :'+port).toString().trim();
                                val = result.split("\r\n")[0].split(/[ ]+/g).pop(); 
                            } else {
                                result=execSync('lsof -i TCP:'+port).toString().trim();
                                val = result.split('\n')[1].split(/[ ]+/g)[1];
                            }
                            msg='Do you want to kill the process running on the same port.[Y/N]:';
                            options.portFree = processKillPrompt(val,msg);
                        } catch(e) {
                            if(e.message.includes("kill")){
                                throw new Error("Your build is already running in your machine in the process id ."+val+"\nKill the process manually using the command 'kill -9 "+val+"'");
                            } else if(e.message.includes("Command failed")){
                                throw new Error("Your port is not free.Please kill the process running on "+port+" manually");
                            } else {
                                throw e;
                            }
                        }
                    };
                    let origPort= options.port || 3000;
                    if(!(/^\d+$/.test(origPort))) {
                        throw(new Error('Value given for port number is not valid'));                  
                    }
                    options.fileContent = {}; 
                    getBuildOptions('server',function(err) {
                        if(err) {
                            reject(err);
                        } else {
                            if(options.production) {
                                options.watch = false;
                            } else {
                                options.watch = true;
                            }
                            let server = require("../../lib/commands/serve");
                            defineSpinner();
                            let getPort = require('get-port');  
                            actions.server = actions.serve = server;
                            options.ui.startSpinner({module :"server",msg :"Building the module ",color :"green"},options);                                                                               
                            getPort({port : origPort}).then(function(port){
                                commonCliUtils.tryCatch(function() {    
                                    if(origPort != port){
                                        systemLog({msg : "Requested port is not free.Going to kill the process at the port"+origPort,type : "INFO",_zl_timestamp: new Date().getTime()});                               
                                        options.processKilled = killProcessByPort(origPort);
                                    } else {
                                        options.portFree = true;
                                    }  
                                    checkAlreadyRunning("serve");
                                    let sane = require("sane"),
                                        fs = require("fs");
                                    actions[command](options,{fs,sane}).then(function(){
                                        fileManipulation.append(options.logPath,options.systemLogs,function() {                                       
                                            options.multispinner.spinners.server.text= 'building completed';                                          
                                            if(!options.inapp) {  
                                                resolveFn(options,sane);                 
                                            } else {
                                                systemLog({msg : "Build sucesss",type :"INFO","_zl_timestamp": new Date().getTime()});
                                                resolve(options);
                                            } 
                                        });
                                    }).catch(function(e){
                                        reject(e);
                                    });                      
                                });
                            }).catch(function(e){
                                reject(e);
                            });  
                        } 
                    });                                        
                });
                break;
    
            case 'rename' :
                commonCliUtils.tryCatch(function() {
                    let rename = require("../../lib/commands/rename");
                    defineSpinner();
                    actions.rename = rename;
                    getBuildOptions('rename',function(err) {
                        if(err){
                            reject(err);
                        } else {
                            actions[command].call(
                                {
                                    resolve : resolve,
                                    reject : reject
                                },options);
                        }
                    });
                });
                break;
    
            case 'generate':
            case 'destroy':
                commonCliUtils.tryCatch(function() {
                    let commandPath = require("../../lib/commands/"+command);
                    defineSpinner();
                    actions[command] = commandPath;
                    if(options.test){
                        options.root =path.join(appPath,"testApp");
                    }  
                    getBuildOptions(command,function(err) {
                        if(err){
                            reject(err);
                        } else {
                            if(!options.cliArgs[1]) {
                                reject(new Error("Please enter the module name."));              
                            } else {                   
                                if(!options.cliArgs[2]) {
                                    reject(new Error("Please enter the file name."));
                                } else {
                                    actions[command].call({
                                        resolve : resolve,
                                        reject : reject
                                    },options);
                                }
                            }
                        }
                    });               
                });
                break;
    
            case 'test':
                commonCliUtils.tryCatch(function() {
                    let tester = require("../../lib/commands/tester");
                    defineSpinner();
                    actions.test = tester;          
                    getBuildOptions('test',function(err) {
                        if(err){
                            reject(err);
                        } else {
                            actions[command].call(
                                {
                                resolve : resolve,
                                reject : reject
                            },options);   
                        }
                    });
                             
                });
                break;
            case 'replace':
                commonCliUtils.tryCatch(function(){
                    let replace = require("../../lib/commands/replacer");
                    defineSpinner();
                    actions.replace = replace;               
                    getBuildOptions('replace',function(err){
                        if(err) {
                             reject(err);
                        } else {
                            const args = options.cliArgs;
                            actions[command].call(
                            {
                                resolve: resolve,
                                reject: reject
                            }, args, options);
                        }
                    });
                 
                }); 
                break;
    
            case 'help':
                let help = require("../../lib/commands/help");
                actions.help = help;
                actions[command](options);
                break;
    
            case 'new':
                commonCliUtils.tryCatch(function(){
                    defineSpinner();
                    let newapp = require("../../lib/commands/new");
                    actions.new = newapp;
                    actions[command](options);
                });
                break;
            case 'migrate' :
                commonCliUtils.tryCatch(function() {
                    defineSpinner();
                    getBuildOptions('migrate',function(err){
                        if(err) {
                            reject(err);
                        } else {
                            var migrateFilePath = path.join(options.root,"node_modules","@zoho","lyte-cli-migrate");
                            var migrate = require(migrateFilePath);
                            migrate(options);
                        }
                    })
                },'migrate','@zoho/lyte-cli-migrate')
                break;
            case 'version':
                console.log(packageConfig.name+'\n'+options.cliVersion);
                break;
    
            case 'location':
                console.log(options.cliRoot);
                break;
    
            case 'fix':
                commonCliUtils.tryCatch(function() {
                    defineSpinner();
                    getBuildOptions('fix',function(err){
                        if(err){
                            reject(err);
                        } else {
                            let fix = require("../../lib/commands/eslintFix");
                            actions.fix= fix;
                            actions[command](options);
                        }
                    });
                   
                }); 
                break;
            case "add" : 
                let add = require("../../lib/commands/add");
                defineSpinner();
                actions.add = add;
                actions[command](options,resolve,reject);
                break;
            case "install" :
                commonCliUtils.tryCatch(function() {                
                    getBuildOptions('install',function(err) {
                        if(err) {
                            reject(err);
                        } else { 
                            defineSpinner();
                            let install = require("../../lib/commands/install");
                            actions.install = install;
                            options.registry = "http://integ-docker:4873";
                            actions[command](options,resolve,reject);
                        }
                    });
                    
                });
                break;
            case "output" :
                commonCliUtils.tryCatch(function() {               
                    getBuildOptions('output',function() {
                        console.log(options._appOutputFolder);
                    });
                });
                break;
            case "lint":
                commonCliUtils.tryCatch(function() {               
                    getBuildOptions('lint',function(err) {
                        if(err) {
                            reject(err);
                        } else {
                            defineSpinner();
                            if(options.cliArgs[1]){
                                let lint;
                                let oldNodeModulesPath
                                if(options.old)  {
                                    oldNodeModulesPath = path.join(options.root,"node_modules","toAsyncAndAwait")
                                    if(fileManipulation.fileExist(oldNodeModulesPath)) {
                                        lint = require(oldNodeModulesPath)
                                    } else {
                                        lint = require(path.join(options.root,"node_modules","@zoho","toasync-and-await"));
                                    }
                                } else {
                                    oldNodeModulesPath = path.join(options.root,"node_modules","convert-to-asyncawait");
                                    if(fileManipulation.fileExist(oldNodeModulesPath)) {
                                        lint = require(oldNodeModulesPath);
                                    } else {
                                        lint = require(path.join(options.root,"node_modules","@zoho","convert-to-asyncawait"))
                                    }
                                }
                                let fileTolint = path.join(appPath,options.cliArgs[1]);
                                let obj = {};
                                    obj.src  = fileTolint;
                                    obj.watch = options.watch ? true : false;
                                    obj.minify = options.m ? true : false;
                                    obj.sourceMap = options.sourceMap ? true : false;
                                if(fileManipulation.fileExist(fileTolint)){
                                    if(options.o) {
                                        let outputFile = path.join(appPath,options.o);
                                        obj.dist = outputFile;
                                    }
                                    lint(obj);
                                } else {
                                    throw new Error("File named "+fileTolint+" not found");
                                }
                            } else {
                                throw new Error("Please enter your filename to lint");
                            }
                        }
                    });
                    
                });
                break;
            case "remove" : 
                let remove = require("../../lib/commands/remove");
                defineSpinner(); 
                actions.remove = remove;
                actions[command](options,resolve,reject);
                break;
            default:
                defineSpinner();
                let commandsObjPath  = path.join(options.cliRoot,"commands.json");
                var content = JSON.parse(fileManipulation.readSync(commandsObjPath,'utf-8'));
                if(content[command]) {
                    let packageArray = content[command];
                    let packageToResolve;
                    if(packageArray.length == 1) {
                        packageToResolve = packageArray[0];
                    } else {
                        if(options.packageName) {
                            let index = packageArray.indexOf(options.packageName);
                            if(index != -1) {
                                reject("No such commands exist in the package "+options.packageName);
                            } else {
                                packageToResolve = packageArray[index];
                            }
                        } else {
                            packageToResolve = packageName.pop();
                        }
                    }
                    try {
                        require(path.join(options.cliRoot,"node_modules",packageToResolve,'commands',command))(options);
                    } catch(e) {
                        reject(e);
                    }
                    return;
                } else {
                    options.showReleventCommand(command,commands);
                }
        }   
    }).then(function(returnOptions) {
        if(options.multispinner){
            writeToLog(options);
            options.multispinner.success(command);
        }
        if(options.fromDockerCall) {
            process.exit();
        }
        return returnOptions;
    }).catch(function(e){

        options.chromiumBrowser &&  options.chromiumBrowser.close();
        systemLog({msg : e.message,stack :e.stack,_zl_timestamp : new Date().getTime(),info : "SEVERE"});
        userLog({msg :e.message,stack : e.stack,color :"red"},function() {
            writeToLog(options);
            if(fromCommandLine) {
                systemLog({msg :"exit calling"})
                // if(!options.inapp) {    
                    process.exit(2);
                // }
            }
        });
        if(options.multispinner) {
            options.multispinner.error(command);
            if(!fromCommandLine) {
                throw e;
            } 
        }
       
    });
}
module.exports = CLI;
