require = global.require;
var path = require('path'),
	dontEnter = 1,
	count = 0;
module.exports = {
	create : function(context) {   
		var oldtxt = context.options[0].split(path.sep),
			newtxt = context.options[1].split(path.sep),
			replacePath = context.options[2];
		function rename(node) {
			var replaceRange =[],
			fix = function(fixer) {			
					return fixer.replaceTextRange(replaceRange,newtext);
	       		},	
			newtext;
			if(oldtxt.length >=1 && dontEnter ) { 
				for(i = 0 ; i < node.body.body.length && dontEnter; i++) {				
					if(node.body.body[i].type == "ExpressionStatement" && node.body.body[i].expression.arguments[0].value == oldtxt[count]) {
						count++;					
						if(count == oldtxt.length) {							
							replaceRange[0] = node.body.body[i].expression.arguments[0].range[0];
							if(node.body.body[i].expression.arguments[1] && node.body.body[i].expression.arguments[1].type == "ObjectExpression"){
								replaceRange[1] = node.body.body[i].expression.arguments[1].range[1];
								if(replacePath == undefined) {
									replacePath = replaceNode(node.body.body[i].expression.arguments[1])
								}							
								newtext = "\""+newtxt[count-1]+"\",{ path :\""+replacePath+"\"}";
							} else {
								replaceRange[1] = node.body.body[i].expression.arguments[0].range[1];
								if(replacePath != undefined) {
									newtext = "\""+newtxt[count-1]+"\",{ path :\""+replacePath+"\"}";	
								} else {
									newtext ="\""+newtxt[count-1]+"\"";
								}
							}
							if(dontEnter) {
								context.report({
					    			node: node,	
					    			message: "Missing semicolon",	
					    			fix: fix
					            });
							}
							dontEnter = 0;							
						} else {
							nodeReset = node.body.body[i].expression.arguments[node.body.body[i].expression.arguments.length-1];
							if((node.body.body[i].expression.arguments[node.body.body[i].expression.arguments.length-1].type) === "FunctionExpression"){
								rename(nodeReset);
							} 
						}
					}
				}

			}
		}
		function replaceNode(replacenode) { 
			if(replacenode.type == "Literal") {
				return replacenode.value;
			} else if(replacenode.type == "ObjectExpression") {
				return replacenode.properties[0].value.value;
			}
		}
		return {
			"FunctionExpression" : rename
		};
	}
};
