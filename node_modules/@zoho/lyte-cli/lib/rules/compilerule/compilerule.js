"use strict";
require = global.require;
var path = require("path"),
	utils = require("@zoho/lyte-cli-utils"),
	fileManipulation = utils.fileManipulation,
	replaceSpecialCharWithHTML = utils.stringManipulation.replaceSpecialCharWithHTML,
	minifyHTMLContent =  utils.commonCliUtils.minifyHTMLContent,
	expHandlers = require('../../lib/utilities/expHandlers'),
	json = {},
	lastFile;
module.exports = {
	create : function(context) {
		var output = "";
		var errorCount = [0];
		var contextOpt = context.options;
		var returnFromFn = '';			
		var sourceCode = context.getSourceCode();
		var file = path.join(contextOpt[0],"build","processedTemplateContent.json");		
		json = contextOpt[1] || json;
		lastFile = contextOpt[2];
		function checkForError(obj) {
			var node = obj.node;				
			if(node) {	
				var errorMsg = obj.errorMsg;
				errorCount[context.getFilename()] = 1;
				context.report({
					node :  node,
					message :errorMsg
				});
			}
		}
		function writeToFile() {
			if(lastFile) {
				//fileManipulation.mkdirSync(path.parse(file).dir,{recursive : true});
				fileManipulation.writeSync(file,JSON.stringify(json));
			}
		}

		function handleForEach(expressionObj){
			var item;
			var index;
			var expressionObjArgs = expressionObj.arguments;
			var argsZero = expressionObjArgs[0].params[0]
			var argsOne = expressionObjArgs[0].params[1]
			if(argsZero) {
				item = argsZero.name;
			}
			index = argsOne ? argsOne.name : "index";
			var options = {};
			var expObj;
			var key,value,objKey;
			var len = expressionObj.arguments.length,i;
			for(i = 1 ;i < len;i++) {
				expObj = expressionObjArgs[i].properties[0];
				
				if(expressionObj.arguments[i].type == "ObjectExpression") {
					key =  expObj.key;
					value = expObj.value
					objKey = key.value || key.name
					options[objKey] = {};
					options[objKey].value = value.value || value.name;
					options[objKey].type =	value.type
				}	
			}
			var callee = expressionObj.callee;
			var propName = callee.property.name;
			if(propName == "forEach") { 
				output += '<template is="for" items="{{';
			} else if(propName == "forIn") {
				output += '<template is="forIn" object="{{';
			}
			var calleeObj = callee.object
			var calleeType = calleeObj.type;
			if(calleeType === "ArrayExpression") {
				checkForError({errorMsg : "Static Array to forEach",node : callee.object});
			}else if(calleeType === "LogicalExpression"){
				checkForError({errorMsg : "LogicalExpression to forEach",node : callee.object});
			}else if(calleeType === "BinaryExpression"){
				checkForError({errorMsg : "BinaryExpression to forEach",node : callee.object});
			} else if(calleeType === "ConditionalExpression") {
				checkForError({errorMsg : "ConditionalExpression to forEach",node : callee.object});
			} else {
				try {
					returnFromFn = replaceSpecialCharWithHTML(sourceCode.getText(calleeObj));				
					output += returnFromFn;
				} catch(e) {
					checkForError({errorMsg : e.message,node : e.node});
				}
			}
			if(propName == "forEach") { 
				if(item) {
					output += '}}" item="'+item+'" index="'+index+'" ';
				} else {
					output += '}}" item="item" index="index" ';
				}									
			} else if(propName == "forIn") {				
				if(item && argsOne) {
					output += '}}" value="'+item+'" key="'+index+'" ';
				} else if(item) {
					output += '}}" value="'+item+'" key="key" ';
				} else {
					output += '}}" value="value" key="key" ';
				}				
			}
			if(options) {	
				var key;
				var optionsVal;					
				for(key in options) { 
					optionsVal = options[key].value;
					if(options[key].type == "Identifier") {
						output += key+'="{{'+ optionsVal.replace(/\"/g,'&quot;')+'}}" ';						
					} else if(options[key].type == "Literal") {
						if(typeof optionsVal == "boolean") {
							output += key+"="+optionsVal+' ';
						} else if(typeof optionsVal == "string") {
							if(optionsVal == "true" || optionsVal == "false") {
								output += key+"="+JSON.parse(optionsVal)+' ';
							} else {
								output += key+"='"+optionsVal.replace(/\"/g,'&quot;')+"' ";
							}
						} else {
							output += key+"="+optionsVal+' ';
						}
					}
				}			
			}
			output+='>';
			handleBlockStatement(expressionObjArgs[0].body.body);
			output += "</template>";
		}
			
		function handleProgram(node){
			try  {
				var idname = node.id.name;
				handleFunctionDeclaration(node);				
				idname = idname.replace(/\$/g,'-');			
				if(!errorCount[context.getFilename()]) {											
					json[idname] = minifyHTMLContent(output);										
				} 	
				output = "";
			} catch(e) {
				output = "";
				checkForError({errorMsg : e.message,node :node});
			}
		}
		
		function handleFunctionDeclaration(node){
			// var params = node.params;
			// var body = node.body;
			handleBlockStatement(node.body.body);
		}

		function handleSwitchCase(node){
			var i,len = node.length;
			var test;
			var nodeVal;
			for(i=0;i<len;i++){
				nodeVal = node[i]
				test = nodeVal.test;
				if(!test){//default case handling
					output += '<template default>';
				}else{
					output += '<template case=' ;
					handleSwitchCondition(test);
					output += '>';
				}
				handleBlockStatement(nodeVal.consequent);
				output += "</template>"
			}
		}

		function handleSwitchCondition(node){
			try {
				var type = node.type;
				if(type === "Identifier" || type == "MemberExpression"){
					returnFromFn = expHandlers.getValueBasedOnType(node,false);
					output += '"{{' +returnFromFn+'}}"';		
				} else if(type == "Literal") {
					var val = expHandlers.getValueBasedOnType(node,false,true);
					if(typeof val != "boolean" && typeof val != "number") {
						output += val.replace(/^('|")$/g,'');
					} else {
						output += val;
					}
				} else {
					output += '"{{'+replaceSpecialCharWithHTML(sourceCode.getText(node))+'}}"';
				}
			} catch(e) {
				checkForError({errorMsg : e.message,node :e.node});
			}
		}

		function handleIfStatement(node){
			output += '<template is="if" value="{{';
			try {				
				output += replaceSpecialCharWithHTML(sourceCode.getText(node.test));			
			} catch(e) {
				checkForError({errorMsg : e.message,node :e.node});
			}
			output += '}}"><template case="true">';
			var consequent = node.consequent
			var conbody = consequent.body
			if(conbody) {
				handleBlockStatement(conbody);
			} else {
				checkForError({errorMsg : "If statement body should be written within an curly braces",node :consequent})
			}		
			output += "</template>";
			var alternate = node.alternate;
			
			if(alternate) {
				
				if(alternate.type == "BlockStatement") {
					var altbody = alternate.body;
					output += '<template case="false">';
					handleBlockStatement(altbody);
					output += '</template>';
				} else if(alternate.type == "IfStatement") {
					output += '<template case="false">';
					handleIfStatement(alternate);
					output += '</template>';
				} else if(alternate.type == "ExpressionStatement") {
					checkForError({errorMsg : "Else statement body should be written within an curly braces",node : alternate})				
				}
			}
			output += '</template>';
		}

		function handleBlockStatement(node){
			//createHelperFn();
			var fnBody = node;
			var i,len = fnBody.length;
			var block;
			for(i=0;i<len;i++){
				block = fnBody[i];
				switch(block.type){
					case "BreakStatement" :
					case "ReturnStatement" :
						output += '<template is="break"></template>';
					break;
					case "VariableDeclaration":
						var k ; 
						var declarations = block.declarations;
						var decllen = declarations.length;
						var variableBlock;
						for(k=0;k<decllen;k++){
							variableBlock = declarations[k];
							output += variableBlock.init.value; //The value assigned to the variable is recieved as init.raw
						}
					break;
					case "ExpressionStatement":
						var expressionObj = block.expression;
						var type = expressionObj.type ;
						var expressionObjProperty;

						if(type === "CallExpression"){
							expressionObjProperty = expressionObj.callee.property 
							if((expressionObjProperty.name == "forEach" || expressionObjProperty.name == "forIn")){
							//take the arguments from argument array to determind item and index.
								handleForEach(expressionObj);
							}
						} else if(type === "AssignmentExpression"){
							output += expressionObj.right.value;
						}
					break;
					case "ForStatement":
						checkForError({errorMsg : "For is not allowed try => forEach instead",node :block});
						//handleForStatement(block);
					break;
					case "IfStatement":
						handleIfStatement(block);
					break;
					case "SwitchStatement":
						var switchCnd = block.discriminant;
						output += '<template is="switch"  value =';
						handleSwitchCondition(switchCnd);
						output += '>';
						handleSwitchCase(block.cases);
						output += "</template>";
					break;
				}
			}
		}
		return {
			"FunctionDeclaration": handleProgram,
			"Program:exit" : writeToFile
		};
	}
} 
