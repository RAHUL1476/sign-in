"use strict";
var flag=1,
	dontEnter=1,
	exist = 0,
	path = require("path");
module.exports = {
	create : function(context) {
		var passtext=context.options[0],
		  	count=0,
		    somearray=[],
		    range,
		    dummyNode;		    
		passtext = passtext.split(path.sep);
		function entryRemove(node){
			var fix  = 	function(fixer) {
							return fixer.removeRange(somearray);
			            }
			if(passtext.length >= 1 && dontEnter) {
				exist = 0;	   
				for(var i = 0;i < node.body.body.length && dontEnter; i++) {
					if(!node.body.body[i].expression || !node.body.body[i].expression.arguments || !node.body.body[i].expression.arguments.length) {
						return ;
					}
					if(node.body.body[i].expression.arguments[0].value == passtext[count] && dontEnter) {
			            count++;
			            exist = 1;
			            if(count == passtext.length && dontEnter) {
			            	//console.log(passtext)
			            	if(node.body.body.length == 1) {	
			            		dummyNode = node;
			            		range = node.range
			            	    var toks = context.getTokensBefore(node);		            	    
								toks = toks[toks.length-1]
								if(toks.value == ',') {
			       				  	somearray[0] = toks.start
								  	somearray[1] = range[1];	
			       				} else {		       	
			       				  	somearray[0] = node.body.body[0].range[0]
			       				  	somearray[1] = node.body.body[0].range[1]
			       				}	       				
			            	} else {	
			            	   dummyNode = node.body.body[i];	   
			            	   range = node.body.body[i].range;
			            	   somearray[0] = range[0];	
			            	   somearray[1] = range[1];				       	   
			            	}		            		            
			            	flag = 0;
			            	context.report({
				    			node: dummyNode,			    			
				    			message: "Missing semicolon",			    			
				    			fix: fix
			                });	 
			                dontEnter = 0;

			            } else {
			            	var nodeReset = node.body.body[i].expression.arguments[node.body.body[i].expression.arguments.length-1];	
			            	if((node.body.body[i].expression.arguments[node.body.body[i].expression.arguments.length-1].type) === "FunctionExpression"){           
				            	entryRemove(nodeReset);
				        	}
						}

					}
				}
				if(exist == 0) {
					dontEnter = 0;
				}
		    }
	    } 
		return {
			"FunctionExpression" :entryRemove
		};
	}
};
