"use strict";
var dontEnter=1;
var flag=0;
var hasFunctionExp = false;
var continueFlag = 0;
module.exports = {
	create : function(context) {
		var route=context.options[0].split('.');
		var argspath=context.options[1];
		var count=0,nodeReset;
		var data=",";
		var sub=[],tab=[];	
		var subNode,expressionToCheck;
		tab[0]='\t';
	    for(var i=1;i<route.length;i++) {
	    	tab[i]=tab[i-1]+'\t';
	    }
	    continueFlag  = 0;
		function subLime(node) {
			if(!continueFlag && (!node.parent || !node.parent.callee || !node.parent.callee.property)) {
				return;
			}

			if(continueFlag || node.parent.callee.property.name  == "configureRoutes" ) {
				hasFunctionExp = true;	
				var fix=function(fixer) {
					if(isCount(count)) {
					 	dontEnter = 0;
					}
					continueFlag = 0;
					return fixer.insertTextAfterRange(sub,data);
		        }  
		        if(route.length > 1 && dontEnter) { 
		        	continueFlag = 0;  /*reset the continueFlag till next match found*/				
					flag=0;
			        for(var i=0;i < node.body.body.length && dontEnter;i++) { 
		        		if(!node.body.body[i].expression|| !node.body.body[i].expression.arguments) {
		        			return;
		        		}
		        		if(node.body.body[i].expression.arguments.length && (node.body.body[i].expression.arguments[0].value == route[count])) {
			             	flag=1;          	
			             	count++;	        
			             	//var parent = node.body.body[i].expression.arguments[node.body.body[i].expression.arguments.length-1];
			             	if(count == route.length-1 && dontEnter) {			             		 		
			             	    sub = dataToWrite(i,count);	
			             	    for(i = 0; i < expressionToCheck.length; i++){
			             	    	if(!checkAlreadyExist(expressionToCheck[i])){
										dontEnter = 0;
										return false;
			             	    	}
			             	    }
			             	    count++;			     
			             	} else {	             	  
				             	nodeReset = node.body.body[i].expression.arguments[node.body.body[i].expression.arguments.length-1];		             	  
				             	if((node.body.body[i].expression.arguments[node.body.body[i].expression.arguments.length-1].type) === "FunctionExpression") {				          	
						            continueFlag = 1; /*match found*/
						            subLime(nodeReset);
						        } 
			                }  
			            }    
			        }
		            if(dontEnter && isCount(count)) {
			            context.report({
			    			node: node,	
			    			message: "Missing semicolon",	
			    			fix: fix
			            });
		            }  	            	
	       			// try {
		    		// 		throw new Error("Error : No matching entry found in router.js")
		    		// } catch(e) {
		    		// 		console.log(e.message);
		    		// }
		    		// return;
	       			// }
		        }
				else {	 
					sub=[];
					if(route.length == 1 && dontEnter)
					{
					    data = "\tthis.route(\""+route[0]+"\"";
						argspath ? data = data +",{ path :\""+argspath+"\"}" : data = data;
						data = data + ");\n";  
					  	sub[0] = node.range[0];
					  	sub[1] = node.range[1]-1;  
					  	if(checkAlreadyExist(node.body,data)) {             
							dontEnter = 0;
							context.report({
				    			node: node,
				    			message: "Missing semicolon",	    			
				    			fix: fix	    			
					        });	
						} else{				
							dontEnter = 0;
							return false;
						}
					}
	        	}
			    function isCount(count) {
			    	return (count === route.length)
			    }

		        function dataToWrite(index,count) {
		        	var parent=node.body.body[index].expression.arguments[node.body.body[index].expression.arguments.length-1];
		        	if(parent.type != "FunctionExpression") {   
		        		expressionToCheck = node.body.body[index].expression.arguments;
			    	    subNode = node.body.body[index].expression.arguments[node.body.body[index].expression.arguments.length -1];
			    	    sub = subNode.range;
			    	    data = data+"function(){\n"+tab[count]+"this.route(\""+route[count]+"\"";
					    argspath ? data = data+",{path :\""+argspath+"\"}"  : data = data;
						data = data+ ");\n"+tab[count-1]+"}";  
					}
					else {
						expressionToCheck = parent.body.body;
						subNode = parent.body.body[parent.body.body.length-1];
		                sub=subNode.range;					    	
				    	data="\n"+tab[count]+"this.route(\""+route[count]+"\"";
				    	argspath ? data = data+",{path :\""+argspath+"\"});" : data =data+')';          
				    }
				    return sub;
		        }
	    	}       
	    } 
		function checkAlreadyExist(nodeName) {
	    	var source = context.getSourceCode();
	    	var token = source.getTokens(nodeName);
	    	var newToken=[],stack=[],setVariable = 0;
	    	for(var k = 0 ; k < token.length ; k++) {
	    		if(token[k].type == "String") {
	    			newToken.push(token[k].value);
	    		}
	    		if(token[k].value == "function") {
	    			for(var j = k+1 ; j < token.length ; j++) {
	    				setVariable = 0;
	    				if(token[j].value == '{') {
	    					stack.push("{");
	    				}    			
	    				if(token[j].value == '}') {
	    					stack.pop('}');
	    					if(stack.length < 1) {
	    						setVariable = 1;
	    					}
	    				}    				
	    				if(setVariable == 1) {
	    					break;
	    				}
	    				k++;
	    			}   			
	    		}
	    	}
	    	var value = '"'+route[count]+'"' ;
	    	if(!newToken.includes(value)) {
	    		return true;
	    	} 	    		
	    	return false;
  		
	    }

	    function checkForError(node)	{
	    	if(!hasFunctionExp) {

	    		try {
	    			throw new Error("No function block detected")
	    		} catch(e){
	    			console.log(e.message);
	    		}
	    	}
	    } 
		return  {		
		    "FunctionExpression": subLime,
		    "Program:exit": checkForError		
		};
	}
};
