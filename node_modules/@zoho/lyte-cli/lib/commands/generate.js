require = global.require;
var utils = require("@zoho/lyte-cli-utils"),
	fileManipulation = utils.fileManipulation,
	stringManipulation = utils.stringManipulation,
	folders = utils.commonCliUtils,
	path = require('path');
function generate(options) {
	/* variable declaration */
	let resolve = this.resolve,
		reject = this.reject,
		validModuleName = options.moduleList,
		_superblueprintPath,
		_localblueprintPath,
		_super = {},
		_local = {},
		dataTokens,
		fileMapTokens,
		userLog = options.log.user,
		srcFolders = options.folders.src,
		module = options.cliArgs[1],
		pluralizeOfmodule = stringManipulation.pluralize(module),
		wrapperFn = function(fn,thenFn){
			fn(options).then(function(){
				thenFn();
			}).catch(function(e){
				reject(e);
			});
		},
		promiseWrapper = function(fn) {
			return new Promise(function(resolve,reject) {
				fn({ resolve : resolve,reject : reject});
			}).catch(function(e){
				if(e.stack) {
					throw e;
				}     
				throw new Error(e); 
			});
			};		
	try {
		initBlueprint(options);	
		if(validateEntityName(options)) { /*validateEntityName always return boolean value*/
			getLocals(options);
			getFileMapTokens(options);
			wrapperFn(beforeInstall,function() {
				wrapperFn(install,function() {
					wrapperFn(afterInstall,function() {
						var afterInstallHook = require(path.join(srcFolders.build,"build.js")).afterInstall;
						if(afterInstallHook) {
							afterInstallHook(options);   							               
						}

						if(options.systemLogs.length){
							fileManipulation.mkdirSync(path.parse(options.logPath).dir);
							fileManipulation.appendSync(options.logPath,options.systemLogs);
						}
						resolve();
					});
				});
			});
		}
	} catch(e) {
		reject(e);
	}
	function initBlueprint(options) {
		srcFolders.blueprints = srcFolders.blueprints || path.join(options.root,"build","blueprints");	
		if(folders.validateModuleName(module,options.moduleList)) {
			_localblueprintPath = path.join(srcFolders.blueprints,pluralizeOfmodule);	
			_superblueprintPath = path.join(options.cliRoot,"blueprints","generate",pluralizeOfmodule);			
			_super = require(path.join(_superblueprintPath,"index.js"));
		} else { /*check remove when opening for custom blueprint*/
			_localblueprintPath = path.join(srcFolders.blueprints,module);	
			if(!fileManipulation.fileExist(_localblueprintPath)) {
				_localblueprintPath = undefined;			
				options.showReleventCommand(module,validModuleName);
				throw new Error("The command 'generate' doesn't support "+module +" Use \"lyte help\"");
			}	
		}

		if(_localblueprintPath && fileManipulation.fileExist(_localblueprintPath)) {
			if(pluralizeOfmodule != "themes") {
				_local = require(path.join(_localblueprintPath,"index.js"));	
			} else {
				throw new Error("For themes custom blueprints are not allowed");
			}		
		} else {
			_localblueprintPath = undefined;
		}
	}

	function validateEntityName(options) {
		if(_super.validateEntityName) {
			if(!_super.validateEntityName(options)) {
				return false;
			}
		}
		if(_local.validateEntityName) {
			return _local.validateEntityName(options);
		}
		return true;
	}
	function getLocals(options) {
		if(_super.locals) {
			dataTokens = _super.locals(options);
			Object.defineProperty(dataTokens,"id",function() {
				writable : false
			});
		}
		
		if(_local.locals) { 			
			dataTokens = Object.assign(_local.locals(options),dataTokens);
		}		
	}

	function getFileMapTokens(options) {
		if(_super.fileMapTokens) {
			fileMapTokens = _super.fileMapTokens(options);
			Object.defineProperty(fileMapTokens,"demo",function() {
				writable : false
			});
		}
		
		if(_local.fileMapTokens) {
			fileMapTokens = Object.assign(_local.fileMapTokens(options),fileMapTokens);
		}
	}
	function copyGenerateFolder(promiseObj,from,to) {
		var fromPath,toPath,fromfileObj,toFileObj,relativePath;
		var returnFilePath;
		var replaceLocalInData = function(data,dataObjKey) {	
			for(var key in dataObjKey) {
				data =data.replace(new RegExp("\\[\\["+key+"\\]\\]",'g'),'"'+dataObjKey[key]+'"');	
			}
			return data;
		};
		var keysOfFileMapTokens = Object.keys(fileMapTokens);
		var fileList = fileManipulation.readdirSync(from);
		var file;
		for(var index = 0,len = fileList.length;index<len;index++) {
			file = fileList[index];
			fromPath = path.join(from,file);				
			fromfileObj = path.parse(file);											
			if(fileManipulation.lstatSync(fromPath).isDirectory()) {					
				toPath = path.join(to,file);
				if(keysOfFileMapTokens.indexOf(fromfileObj.name) != -1) {
					toPath = toPath.replace(fromfileObj.name,fileMapTokens[fromfileObj.name]);
				}
				fileManipulation.mkdirSync(toPath);
				returnFilePath = copyGenerateFolder(promiseObj,fromPath,toPath);
			} else {
				if((file.indexOf(".gitkeep") != -1)|| (fileManipulation.validateFile(file) && file.indexOf("index.js") == -1)) {	   
					if(options.theming && module == "component") {
						if(fromfileObj.ext == '.css') {
							return;		                  	
						}
					} 	
					if(options.d && typeof options.d == "string") {
						toPath = path.join(to,options.d,file);
					} else {
						toPath = path.join(to,file);
					}
					if(keysOfFileMapTokens.indexOf(fromfileObj.name) != -1) {
						toPath = toPath.replace(fromfileObj.name,fileMapTokens[fromfileObj.name]);
					}
					var relativePath = options.test ? path.relative(process.cwd(),toPath) : path.relative(options.root,toPath);											
					var toFileObj = path.parse(toPath);
					if(!fileManipulation.fileExist(toPath)) {
						fileManipulation.mkdirSync(toFileObj.dir);
						var content = replaceLocalInData(fileManipulation.readSync(fromPath,'utf-8'),dataTokens);
						fileManipulation.writeSync(toPath,content,true);	
						userLog({color :"green",msg : "added "+relativePath});					
						if(fileManipulation.fileExist(options.logPath)) {
							options.log.system("added "+relativePath+"\n");
						}
						returnFilePath = toPath;
					} else {
						promiseObj.reject(new Error(relativePath+" file already exist"));			    		
					}			
				}	   			
			}
		}
		return returnFilePath;
	}

	function beforeInstall(options) {
		return promiseWrapper(function(promiseObj) {
			options.ui.startSpinner({module:'generate',msg: "Generating "+options.cliArgs[1]+" named "+options.cliArgs[2]+'...'},options);	
			if(options.addons && (options.cliArgs[1] == "route" )){
				promiseObj.reject(new Error("Generate command doesn't support the generation of "+options.cliArgs[1]+" for addons"));
			}
			_super.beforeInstall && _super.beforeInstall.call(promiseObj,options);					
			_local.beforeInstall && _local.beforeInstall.call(promiseObj,options);
			promiseObj.resolve();
		});
	}

	function install(options)	{
		return promiseWrapper(function(promiseObj) {
			var fromPath,toPath,pathRoute;
			if(module != "blueprint" && module != "theme") {
				fromPath = _localblueprintPath || _superblueprintPath;
				toPath = srcFolders[pluralizeOfmodule] || path.join(options.root,module);				
				pathRoute = copyGenerateFolder(promiseObj,fromPath,toPath);
				if(pathRoute) {
					var appAdded = path.relative(options.root,pathRoute.replace(options.root,options._appOutputFolder));
					if(options.autoBundle == false){
						if(module == 'component'){							
							appAdded = appAdded.replace('templates','javascript').replace('styles','javascript').replace(path.parse(appAdded).ext,'.js');
							userLog({color : 'blue', msg : "Include the file path '"+appAdded+"' in your application"}); 
						} else if(module != 'adapter' && module != 'serializer' && module != 'theme'){
							userLog({color : 'blue', msg : "Include the file path '"+appAdded+"' in your application"}); 
						} 
					}
				}	 
				_super.install && _super.install.call(promiseObj,options);
				_local.install && _local.install.call(promiseObj,options);
			} else {
				_super.install && _super.install.call(promiseObj,options);
			}
			promiseObj.resolve();
		});
	}

	function afterInstall(options) {
		return promiseWrapper(function(promiseObj) {
			_super.afterInstall  && _super.afterInstall.call(promiseObj,options);				
			_local.afterInstall && _local.afterInstall.call(promiseObj,options);
			promiseObj.resolve();
		});
	}
}

module.exports = generate;
