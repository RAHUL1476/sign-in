

require = global.require;
var path = require('path'),
	fs = require('fs'),
	utils = require("@zoho/lyte-cli-utils"),
	fileManipulation = utils.fileManipulation,
	stringManipulation = utils.stringManipulation,
	validateComponentName = utils.commonCliUtils.validateComponentName,
	CLIEngine = require("eslint").CLIEngine;

function rename(options) {
	try {
		let userLog = options.log.user;
		let argCheckRename = function(options) {
			var firstArg = options.cliArgs[1];
			var secondArg  = options.cliArgs[2];
			var thirdArg = options.cliArgs[3];
			if(firstArg) {
				switch(firstArg) {
					case "serializer":
					case "adapter" :
						throw new Error("rename doesn't support for "+firstArg);
					default :
						var defaultBlueprints = options.moduleList;
						if(!defaultBlueprints.includes(firstArg)) {
							options.showReleventCommand(firstArg,defaultBlueprints);
							return false;
						} else { 
							if(secondArg){
								if(!thirdArg) {
									throw new Error("Please enter the new file name");
								} 
								if(secondArg == thirdArg) {
									throw new Error("old name and new name need not be same");
								}
							} else {
								throw new Error("Please enter the file name you want to rename");
							}
						}
				}
			} else {
				throw new Error("Please enter the module name");

			}
			return true;
		}
		if(argCheckRename(options)) {
			var secondArg = options.cliArgs[2];
			var thirdArg = options.cliArgs[3];
			var srcFolders = options.folders.src,
				blueprintfolders = { 
					routes : 'routes',
					components : 'components',
					adapters : 'adapters',
					models : 'models',
					serializers : 'serializers',
					mixins :'mixins',
					tests:path.join("tests","__path__"),
					javascript : path.join('components','javascript'),
					templates : path.join('components','templates'),
					helpers : 'helpers',
					services : 'services',
					styles : path.join('components','styles')
				},
				module = options.cliArgs[1],
				pluralizeModule = stringManipulation.pluralize(module),
				blueprintContent,
				fromSeg,
				toSeg,
				to,from,
				values = {};
			let checkFolderExist  = function(fromPath,toPath,blueprintContent) {
				var fromPathObj = path.parse(fromPath);
				var toPathObj = path.parse(toPath);
				var fromPathWithoutExt =  path.join(fromPathObj.dir,fromPathObj.name);
				var toPathWithoutExt = path.join(toPathObj.dir,toPathObj.name);
				if(fileManipulation.fileExist(fromPathWithoutExt)) {
					if(fileManipulation.lstatSync(fromPathWithoutExt).isDirectory()) {
						var dir = fileManipulation.getFilesListSync(fromPathWithoutExt);
						dir.forEach(function(file) {
							from = file;
							to = file.replace(fromPathWithoutExt,toPathWithoutExt);
							applyValues(blueprintContent,readTheInputFile(file,to),values);
						});
						fs.rmdirSync(fromPathWithoutExt);
					}	
				}			
			};
			let getBlueprintContent = function(mod,type) {
				type = type || ".js";		
				var folder = blueprintfolders[mod];
				return fileManipulation.readSync(path.join(options.cliRoot,'blueprints','generate',folder,'__demo__'+type),'utf-8');
			};
			let readTheInputFile = function(from,to) {
				if(fileManipulation.fileExist(to)){
					if(process.env.PRODUCTION) {
						this.reject(new Error("File already exist "+to));
					} else {
						var result = fileManipulation.prompt('Are you sure want to modify the already existing file '+to+'?? Yes/No',"red");
						if(result)  {
							return fileManipulation.readSync(from,'utf8');
						} else {
							process.exit(2);
						} 
					}            
				} 
				return fileManipulation.readSync(from,'utf8');	
			};
			let  applyValues = function(blueprintContent,distFileContent,values) {
				
				try {
					if(distFileContent.length) {
						var blueprintSplit = blueprintContent.split(/\r\n|\r|\n/),
							toApply = [],
							startIndex,
							endIndex;
						if(distFileContent.indexOf("</template>") == -1) {
							blueprintSplit.forEach(function(line) {
								if((startIndex = line.indexOf('[[')) != -1 && (endIndex = line.indexOf(']]')) != -1) {
									toApply.push({line,startIndex,endIndex});
								}
							});
						} else {
							var distFileSplit = distFileContent.split(/\r\n|\r|\n/);
							distFileSplit.forEach(function(line){
								if((line.indexOf('tag-name')) != -1){
									line = line.substring(line.indexOf('tag-name'));
									var match=line.match(/"(.*?)"|'(.*?)'/);
									if(match[0].charAt(0)=="\""){
										line = match[1];
									} else {
										line=match[2];				
									}		
									if(match) {
										if(line == options.cliArgs[2]) {
											distFileContent = distFileContent.replace(line,values.id);
										}
									}
								}
							});
						}
						toApply.forEach(function(obj) {// template needs to be checked with id attribute instead of string.
							var refText = obj.line.substring(0,obj.startIndex),
								key = obj.line.substring(obj.startIndex+2,obj.endIndex),
								fromIndex = distFileContent.indexOf(refText)+refText.length,
								quoteTypte = distFileContent.substr(fromIndex,1);
							var content = distFileContent.substring(0,fromIndex+1);
							var remContent = distFileContent.substring(fromIndex+1,distFileContent.length),
								replacedKey=distFileContent.substr(fromIndex+1,remContent.indexOf(quoteTypte)),
								remContent = remContent.substring(remContent.indexOf(quoteTypte),distFileContent.length);
								replacedKey=replacedKey.replace(options.cliArgs[2].split('/').join('.'),values[key])
								distFileContent = content+replacedKey+remContent;
						});
						fileManipulation.mkdirSync(path.parse(to).dir);
						fileManipulation.writeSync(to,distFileContent,true);		
						fs.unlinkSync(from);
					} else {
						fileManipulation.mkdirSync(path.parse(to).dir);
						fileManipulation.writeSync(to,'',true);	
						fs.unlinkSync(from);			
					}
					options.multispinner.spinners['rename'].text = 'Renaming '+module+' '+fromSeg+' => '+toSeg+' completed';
					
				} catch(e) {
					throw e;
				}
			}.bind(this);
			switch(module) {
				case "route" :
					var replacePath = options.cliArgs[4];
					fromSeg = secondArg.split('.').join(path.sep);
					toSeg = thirdArg.split('.').join(path.sep);
					values = {
						id : thirdArg
					};

					from = path.join(srcFolders[pluralizeModule],fromSeg)+'.js';
					to = path.join(srcFolders[pluralizeModule],toSeg)+'.js';
					options.ui.startSpinner({module:'rename',msg:'Renaming '+module+' '+fromSeg+' => '+toSeg},options);
					if(fileManipulation.fileExist(from)) {
						blueprintContent = getBlueprintContent(pluralizeModule);
						applyValues(blueprintContent,readTheInputFile(from,to),values);
						var eslintRule = new CLIEngine({
							useEslintrc: false,
							rulePaths : [path.join(options.cliRoot,'lib','rules','renameRule')],
							rules: {
								renamerouter:[2,fromSeg,toSeg,replacePath]
							},
							allowInlineConfig : false,
							fix : true
						});
						var report = eslintRule.executeOnFiles([srcFolders.routers]);
						if(report.errorCount) {
							var formatter = CLIEngine.getFormatter("stylish");
							var message = formatter(report.results);
							this.reject(new Error(message));
						} else {
							CLIEngine.outputFixes(report);
						}
						checkFolderExist(from,to,blueprintContent);
					} else {
						this.reject(new Error("File given for rename not found "+from));
					}
					break;
				case "component":
					fromSeg = options.d ? path.join(options.d,secondArg) :  secondArg;
					toSeg = options.d ? path.join(options.d,thirdArg) : thirdArg;
					values = {
						id : thirdArg
					};
					options.ui.startSpinner({module:"rename",msg:'Renaming '+module+' '+fromSeg+' => '+toSeg},options);
					if(validateComponentName(secondArg)) {					
						var subModules = {
							'javascript' : '.js',
							'templates' : '.html',					
							'styles' : '.css'
						};
						var jsFilePath = path.join(srcFolders.javascript,fromSeg+'.js');
						if(fileManipulation.fileExist(jsFilePath)) {
							for(var mod in subModules) {
								var type = subModules[mod];
								from = path.join(srcFolders[mod],fromSeg+type);
								to = path.join(srcFolders[mod],toSeg+type);
								if(fileManipulation.fileExist(from)) {
									blueprintContent = getBlueprintContent(mod,type),
									applyValues(blueprintContent,readTheInputFile(from,to),values);
									checkFolderExist(from,to,blueprintContent);
								} else {
									userLog({color :"red",msg :"Component named "+from+" doesn't exist"});
								}
							}
						} else {
							this.reject(new Error("Component named "+jsFilePath));
						}
					} else {
						this.reject(new Error("Component name should be hypenated"));
					}
					break;

				case "helper":	
				case "mixin" :
				case "service":		
					fromSeg = options.d ? path.join(options.d,secondArg) :secondArg;
					toSeg = options.d ? path.join(options.d,thirdArg) :  thirdArg;
					options.ui.startSpinner({module:'rename',msg:'Renaming '+module+' '+fromSeg+' => '+toSeg},options);
					values = {
						id : thirdArg
					};
					from = path.join(srcFolders[pluralizeModule],fromSeg+'.js');
					to = path.join(srcFolders[pluralizeModule],toSeg+'.js');
					if(fileManipulation.fileExist(from)) {
						var content = readTheInputFile(from,to);
						blueprintContent = getBlueprintContent(pluralizeModule);
						applyValues(blueprintContent,content,values);
						checkFolderExist(from,to,blueprintContent);
					} else {
						this.reject(new Error("File given for rename not found"+fromSeg));
					}
					break;
				
				case "model":
					fromSeg = options.d ? path.join(options.d,secondArg) :  secondArg;
					toSeg = options.d ? path.join(options.d,thirdArg) :  thirdArg;
					values = {
						id : thirdArg
					};
					options.ui.startSpinner({module:'rename',msg:'Renaming '+module+' '+fromSeg+' => '+toSeg},options);
					var fromModelFile = path.join(srcFolders.models,fromSeg+'.js');
					var toModelFile = path.join(srcFolders.models,toSeg+'.js');
					if(fileManipulation.fileExist(fromModelFile)) {
						['models','serializers','adapters'].forEach(function(mod) {
							from = fromModelFile.replace(srcFolders.models,srcFolders[mod]);
							to = toModelFile.replace(srcFolders.models,srcFolders[mod]);
				
							if(fileManipulation.fileExist(from)) {
								
								blueprintContent = getBlueprintContent(mod);
								applyValues(blueprintContent,readTheInputFile(from,to),values);
								checkFolderExist(from,to,blueprintContent);
							} else {
								userLog({color : "red",msg :"File not found "+from});
							}
						});
					} else {
						this.reject(new Error("File not found "+fromModelFile));
					}		
					break;
				
				case "test" :
					options.testType = options["functional-test"]? "functional_tests" : "unit_tests";
					fromSeg = path.join(options.testType,(options.d ? path.join(options.d,secondArg) :  secondArg));
					toSeg = path.join(options.testType,(options.d ? path.join(options.d,thirdArg) :  thirdArg));
					values = {
						id : thirdArg
					}
					options.ui.startSpinner({module:'rename',msg:'Renaming '+module+' '+fromSeg+' => '+toSeg},options);
					let actualFrom = path.join(srcFolders[pluralizeModule],fromSeg+'.spec.js');
					from = path.join(srcFolders[pluralizeModule],fromSeg+'.js');
					to = path.join(srcFolders[pluralizeModule],toSeg+'.spec.js');
					if(fileManipulation.fileExist(actualFrom)){
						from = actualFrom;
					}
					if(fileManipulation.fileExist(from)) {
						blueprintContent = getBlueprintContent(pluralizeModule);
						applyValues(blueprintContent,readTheInputFile(from,to),values);
						checkFolderExist(from,to,blueprintContent);
					} else {
						this.reject(new Error("File not found "+from))
					}
					break;

			}
			this.resolve();
		}
	} catch(e){
		this.reject(e);
	}
}

module.exports = rename;
