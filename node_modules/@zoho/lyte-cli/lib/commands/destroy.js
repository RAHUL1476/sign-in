require = global.require;
var utils = require("@zoho/lyte-cli-utils"),
   fileManipulation = utils.fileManipulation,
   path = require('path'),
   stringManipulation = utils.stringManipulation,
   folders = utils.commonCliUtils;
function destroy(options) {
      /* variable declaration */
      let resolve = this.resolve,
         reject = this.reject,
         validModuleName = options.moduleList,
         _superblueprintPath,
         _localblueprintPath,
         _super = {},
         _local = {},
         srcFolders = options.folders.src,
         userLog = options.log.user,
         module = options.cliArgs[1],
         pluralizeOfmodule = stringManipulation.pluralize(module),
         wrapperFn = function(fn,thenFn){
            fn(options).then(function(){
               thenFn();
            }).catch(function(e){
               reject(e);
            });
         },
         promiseWrapper = function(fn) {
            return new Promise(function(resolve,reject) {
               fn({ resolve : resolve,reject : reject});
            }).catch(function(e){
               if(e.stack) {
                  throw e;
               }     
               throw new Error(e); 
            });
         };

      try {
         initBlueprint(options); 
         if(validateEntityName(options)) { /*validateEntityName always return boolean value*/
            wrapperFn(beforeUninstall,function() {
               wrapperFn(uninstall,function() {
                  wrapperFn(afterUninstall,function() {
                     var afterUninstallHook = require(path.join(srcFolders.build,"build.js")).afterUninstall;
                     if(afterUninstallHook) {
                        afterUninstallHook(options);   							               
                     }
                     if(options.systemLogs.length){
                        fileManipulation.mkdirSync(path.parse(options.logPath).dir);
                        fileManipulation.appendSync(options.logPath,options.systemLogs);
                     }
                     resolve();
                  });
               });
            });
         }
      } catch(e) {
         reject(e);
      } 
      function initBlueprint(options) {
         srcFolders.blueprints = srcFolders.blueprints || path.join(options.root,"build","blueprints");	
        			
         if(folders.validateModuleName(module,options.moduleList)) {
            _superblueprintPath = path.join(options.cliRoot,"blueprints","generate",pluralizeOfmodule);			
            _super = require(path.join(_superblueprintPath,"index.js"));
            _localblueprintPath = path.join(srcFolders.blueprints,pluralizeOfmodule);	
         } else { /*check remove when opening for custom blueprint*/
            _localblueprintPath = path.join(srcFolders.blueprints,module);	
            if(!fileManipulation.fileExist(_localblueprintPath)) {
               _localblueprintPath = undefined;			
               options.showReleventCommand(module,validModuleName);   
               throw new Error("The command 'generate' doesn't support "+module +" Use \"lyte help\"");
            }	
         }
         if(_localblueprintPath && fileManipulation.fileExist(_localblueprintPath)) {
            if(pluralizeOfmodule != "themes") {
               _local = require(path.join(_localblueprintPath,"index.js"));	
            } else {
               throw new Error("For themes custom blueprints are not allowed");
            }		
         } else {
            _localblueprintPath = undefined;
         }
      }
      function validateEntityName(options) {
         if(_super.validateEntityName) {
            if(!_super.validateEntityName(options)) {
               return false;
            }
         }
         if(_local.validateEntityName) {
            return _local.validateEntityName(options);
         }
         return true;
      }

      function beforeUninstall(options) {
         var firstArgs = options.cliArgs[1];
         if(options.addons && ( firstArgs == "route")){        
            
            if(process.env.PRODUCTION) {
               throw(new Error("Destroy command doesn't support the destruction of "+firstArgs+" for addons.Delete the files manually"));
            } else {
               userLog({color : "red" ,msg:"Destroy command doesn't support the destruction of "+firstArgs+" for addons"});
               var res=fileManipulation.prompt("If you have created it manually and want to remove it,enter Y for yes and N for no(Y/N)","red");
               if(!res){
                  throw new Error("Permission denied in removing the files");
               }
            }
         }
         return promiseWrapper(function(promiseObj) {
            options.ui.startSpinner({module:'destroy',msg: "Destroying "+options.cliArgs[1]+" named "+options.cliArgs[2]+'...'},options);                              
            _super.beforeUninstall && _super.beforeUninstall.call(promiseObj,options);          
            _local.beforeUninstall && _local.beforeUninstall.call(promiseObj,options);         
            promiseObj.resolve();
         });
      }

      function uninstall(options) {
         return promiseWrapper(function(promiseObj) {
            let subFolder = (options.d && options.d!='.' && typeof options.d == "string") ? options.d : '';
            let  destroyFn = function(from,to) {
               var fromPath,toPath,fromfileObj,relativePath;
               var keysOfFileMapTokens = {};
               keysOfFileMapTokens = _local.fileMapTokens(options);
               var fileList = fileManipulation.readdirSync(from);
               var file;
               for(var index = 0,len = fileList.length;index<len;index++) {
                  file = fileList[index];
                  fromPath = path.join(from,file);				
                  fromfileObj = path.parse(file);											
                  if(fileManipulation.lstatSync(fromPath).isDirectory()) {					
                     toPath = path.join(to,file);
                     if(keysOfFileMapTokens[fromfileObj.name]) {
                        toPath = toPath.replace(fromfileObj.name,keysOfFileMapTokens[fromfileObj.name]);
                     }
                     destroyFn(fromPath,toPath);
                  } else {
                     if(fileManipulation.validateFile(file) && file.indexOf("index.js") == -1) {	  
                        toPath = path.join(to,subFolder,file);
                        if(keysOfFileMapTokens[fromfileObj.name]) {
                           toPath = toPath.replace(fromfileObj.name,keysOfFileMapTokens[fromfileObj.name]);
                        }
                        var relativePath = options.test ? path.relative(process.cwd(),toPath) : path.relative(options.root,toPath);										
                        if(fileManipulation.fileExist(toPath)) {
                           fileManipulation.removeSync(toPath,true);	
                           userLog({color :"green",msg : "Removed "+relativePath});					
                           if(fileManipulation.fileExist(options.logPath)) {
                              options.log.system("Removed "+relativePath+"\n");
                           }
                        }  else {
                           userLog({color :"red",msg : "File "+relativePath+" doesn't exist"});
                        }
                     }	   			
                  }
               }
            };
            _super.uninstall && _super.uninstall.call(promiseObj,options);
            if(_local.uninstall) {
               if(!folders.validateModuleName(module,options.moduleList)) {             
                  destroyFn(path.join(options.folders.src.blueprints,module),path.join(options.root,module));
               }
               _local.uninstall.call(promiseObj,options);
            }
            promiseObj.resolve();
         });
      }

      function afterUninstall(options) {
         return promiseWrapper(function(promiseObj) {
            _super.afterUninstall &&  _super.afterUninstall.call(promiseObj,options);
            _local.afterUninstall &&  _local.afterUninstall.call(promiseObj,options);
            promiseObj.resolve();
         });
      }

}
module.exports = destroy;
